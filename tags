!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
ABO_NEWTYPE_HPP	include/newtype.hpp	/^#define ABO_NEWTYPE_HPP$/;"	d
ABO_UNION_HPP	include/union.hpp	/^#define ABO_UNION_HPP$/;"	d
AB_GIT_H	include/git_.hpp	/^#define AB_GIT_H$/;"	d
Addable	include/newtype.hpp	/^template <typename T> struct Addable : crtp<T, Addable> {$/;"	s	namespace:abo::nt
Addable	include/ntskills.hpp	/^template <typename T> struct Addable : crtp<T, Addable> {$/;"	s	namespace:nt
Bark	include/git_.hpp	/^template <typename Pith> struct Bark {$/;"	s	namespace:abo
Base	include/range/v3/view/partial_sum.hpp	/^            using Base = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::partial_sum_view::cursor	typeref:typename:meta::const_if_c<IsConst,Rng>
Base	include/range/v3/view/sample.hpp	/^            using Base = meta::const_if_c<IsConst, Rng>;$/;"	t	class:ranges::sample_view::cursor	typeref:typename:meta::const_if_c<IsConst,Rng>
Base	include/range/v3/view/split.hpp	/^            using Base = meta::const_if_c<Const, V>;$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:meta::const_if_c<Const,V>
Base	include/range/v3/view/split.hpp	/^            using Base = meta::const_if_c<Const, V>;$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:meta::const_if_c<Const,V>
Base	include/range/v3/view/take.hpp	/^            using Base = detail::if_then_t<Const, Rng const, Rng>;$/;"	t	struct:ranges::take_view::sentinel	typeref:typename:detail::if_then_t<Const,Rng const,Rng>
BaseIterCategory	include/range/v3/view/split.hpp	/^            using BaseIterCategory =$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:std::iterator_traits<iterator_t<Base>>::iterator_category
BlobId	include/git.hpp	/^using BlobId = nt::NamedType<std::string, struct BlobIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct BlobIdTag>
Boost_USE_MULTITHREADED	example/CMakeLists.txt	/^    set(Boost_USE_MULTITHREADED     OFF)$/;"	v
Boost_USE_STATIC_LIBS	example/CMakeLists.txt	/^    set(Boost_USE_STATIC_LIBS        ON)$/;"	v
Boost_USE_STATIC_RUNTIME	example/CMakeLists.txt	/^    set(Boost_USE_STATIC_RUNTIME    OFF)$/;"	v
C	include/git.hpp	/^  using C = int (*)(T **, Args...);$/;"	t	struct:git::make
C	include/git.hpp	/^  using C = int (*)(T *, Args...);$/;"	t	struct:git::make2
C	include/range/v3/action/insert.hpp	/^                using C = cpp17_iterator_t<I, S>;$/;"	t	function:ranges::adl_insert_detail::detail::insert_impl	typeref:typename:cpp17_iterator_t<I,S>
C	include/range/v3/action/insert.hpp	/^                using C = range_cpp17_iterator_t<Rng>;$/;"	t	function:ranges::adl_insert_detail::detail::insert_impl	typeref:typename:range_cpp17_iterator_t<Rng>
C	include/range/v3/range/conversion.hpp	/^                using C = common_type_t<range_size_t<Rng>, size_type>;$/;"	t	function:ranges::detail::to_container::fn::impl	typeref:typename:common_type_t<range_size_t<Rng>,size_type>
C	include/range/v3/view/span.hpp	/^            using C = common_type_t<To, From>;$/;"	t	function:ranges::detail::narrow_cast	typeref:typename:common_type_t<To,From>
CI	include/range/v3/view/take.hpp	/^            using CI = counted_iterator<iterator_t<Base>>;$/;"	t	struct:ranges::take_view::sentinel	typeref:typename:counted_iterator<iterator_t<Base>>
CInner	include/range/v3/view/join.hpp	/^            using CInner = range_reference_t<COuter>;$/;"	t	struct:ranges::join_view::cursor	typeref:typename:range_reference_t<COuter>
CMAKE_FOLDER	example/CMakeLists.txt	/^set(CMAKE_FOLDER "example")$/;"	v
COuter	include/range/v3/view/join.hpp	/^            using COuter = detail::if_then_t<Const, Rng const, Rng>;$/;"	t	struct:ranges::join_view::cursor	typeref:typename:detail::if_then_t<Const,Rng const,Rng>
CPP_AUTO_FUN_DECLTYPE_NOEXCEPT_	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_DECLTYPE_NOEXCEPT_(/;"	d
CPP_AUTO_FUN_IMPL_	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_IMPL_(/;"	d
CPP_AUTO_FUN_RETURNS_	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_RETURNS_(/;"	d
CPP_AUTO_FUN_RETURNS_CONST_0	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_RETURNS_CONST_0(/;"	d
CPP_AUTO_FUN_RETURNS_CONST_1	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_RETURNS_CONST_1(/;"	d
CPP_AUTO_FUN_RETURNS_CONST_2	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_RETURNS_CONST_2(/;"	d
CPP_AUTO_FUN_RETURNS_return	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_RETURNS_return$/;"	d
CPP_AUTO_FUN_SELECT_RETURNS_	include/concepts/concepts.hpp	/^#define CPP_AUTO_FUN_SELECT_RETURNS_(/;"	d
CPP_CONCEPTS_HPP	include/concepts/concepts.hpp	/^#define CPP_CONCEPTS_HPP$/;"	d
CPP_CTOR_IMPL_1_	include/concepts/concepts.hpp	/^#define CPP_CTOR_IMPL_1_(/;"	d
CPP_CTOR_SFINAE_EAT_NOEXCEPT_noexcept	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_EAT_NOEXCEPT_noexcept(/;"	d
CPP_CTOR_SFINAE_IMPL_1_	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_IMPL_1_(/;"	d
CPP_CTOR_SFINAE_MAKE_PROBE	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_MAKE_PROBE(/;"	d
CPP_CTOR_SFINAE_PROBE_NOEXCEPT_noexcept	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_PROBE_NOEXCEPT_noexcept /;"	d
CPP_CTOR_SFINAE_REQUIRES	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_REQUIRES(/;"	d
CPP_CTOR_SFINAE_REQUIRES_0	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_REQUIRES_0(/;"	d
CPP_CTOR_SFINAE_REQUIRES_1	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_REQUIRES_1(/;"	d
CPP_CTOR_SFINAE_SHOW_NOEXCEPT_noexcept	include/concepts/concepts.hpp	/^#define CPP_CTOR_SFINAE_SHOW_NOEXCEPT_noexcept(/;"	d
CPP_CXX14_CONSTEXPR	include/concepts/swap.hpp	/^#define CPP_CXX14_CONSTEXPR /;"	d
CPP_CXX_CONCEPTS	include/concepts/concepts.hpp	/^#define CPP_CXX_CONCEPTS /;"	d
CPP_CXX_INLINE_VARIABLES	include/concepts/swap.hpp	/^#define CPP_CXX_INLINE_VARIABLES /;"	d
CPP_CXX_VA_OPT	include/concepts/concepts.hpp	/^#define CPP_CXX_VA_OPT /;"	d
CPP_CXX_VA_OPT_	include/concepts/concepts.hpp	/^#define CPP_CXX_VA_OPT_(/;"	d
CPP_DEFINE_CPO	include/concepts/swap.hpp	/^#define CPP_DEFINE_CPO(/;"	d
CPP_DIAGNOSTIC_IGNORE	include/concepts/swap.hpp	/^#define CPP_DIAGNOSTIC_IGNORE(/;"	d
CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME	include/concepts/swap.hpp	/^#define CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME /;"	d
CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME	include/concepts/swap.hpp	/^#define CPP_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME$/;"	d
CPP_DIAGNOSTIC_IGNORE_PRAGMAS	include/concepts/swap.hpp	/^#define CPP_DIAGNOSTIC_IGNORE_PRAGMAS /;"	d
CPP_FORCE_TO_BOOL	include/concepts/concepts.hpp	/^#define CPP_FORCE_TO_BOOL /;"	d
CPP_FUN_IMPL_1_	include/concepts/concepts.hpp	/^#define CPP_FUN_IMPL_1_(/;"	d
CPP_INLINE_VAR	include/concepts/swap.hpp	/^#define CPP_INLINE_VAR /;"	d
CPP_INLINE_VAR	include/concepts/swap.hpp	/^#define CPP_INLINE_VAR$/;"	d
CPP_INLINE_VARIABLE	include/concepts/swap.hpp	/^#define CPP_INLINE_VARIABLE(/;"	d
CPP_INSTANCE	include/concepts/concepts.hpp	/^#define CPP_INSTANCE(/;"	d
CPP_PP_AUX_template	include/concepts/concepts.hpp	/^#define CPP_PP_AUX_template(/;"	d
CPP_PP_CAT	include/concepts/concepts.hpp	/^#define CPP_PP_CAT(/;"	d
CPP_PP_CAT2	include/concepts/concepts.hpp	/^#define CPP_PP_CAT2(/;"	d
CPP_PP_CAT2_	include/concepts/concepts.hpp	/^#define CPP_PP_CAT2_(/;"	d
CPP_PP_CAT_	include/concepts/concepts.hpp	/^#define CPP_PP_CAT_(/;"	d
CPP_PP_CHECK	include/concepts/concepts.hpp	/^#define CPP_PP_CHECK(/;"	d
CPP_PP_CHECK_N	include/concepts/concepts.hpp	/^#define CPP_PP_CHECK_N(/;"	d
CPP_PP_COMMA	include/concepts/concepts.hpp	/^#define CPP_PP_COMMA(/;"	d
CPP_PP_COMMA_IIF	include/concepts/concepts.hpp	/^#define CPP_PP_COMMA_IIF(/;"	d
CPP_PP_COUNT	include/concepts/concepts.hpp	/^#define CPP_PP_COUNT(/;"	d
CPP_PP_COUNT_	include/concepts/concepts.hpp	/^    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, N, ...)                   \\$/;"	d
CPP_PP_DECL_DEF	include/concepts/concepts.hpp	/^#define CPP_PP_DECL_DEF(/;"	d
CPP_PP_DECL_DEF_0	include/concepts/concepts.hpp	/^#define CPP_PP_DECL_DEF_0(/;"	d
CPP_PP_DECL_DEF_1	include/concepts/concepts.hpp	/^#define CPP_PP_DECL_DEF_1(/;"	d
CPP_PP_DECL_DEF_IMPL	include/concepts/concepts.hpp	/^#define CPP_PP_DECL_DEF_IMPL(/;"	d
CPP_PP_DECL_DEF_NAME	include/concepts/concepts.hpp	/^#define CPP_PP_DECL_DEF_NAME(/;"	d
CPP_PP_DEF_DECL_template	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_DECL_template(/;"	d
CPP_PP_DEF_IMPL	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL(/;"	d
CPP_PP_DEF_IMPL_0	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_0(/;"	d
CPP_PP_DEF_IMPL_1	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_1(/;"	d
CPP_PP_DEF_IMPL_1_REQUIRES	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_1_REQUIRES(/;"	d
CPP_PP_DEF_IMPL_1_REQUIRES_BODY	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_1_REQUIRES_BODY(/;"	d
CPP_PP_DEF_IMPL_1_requires	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_1_requires /;"	d
CPP_PP_DEF_IMPL_IS_PAREN_0	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_IS_PAREN_0(/;"	d
CPP_PP_DEF_IMPL_IS_PAREN_1	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_IMPL_IS_PAREN_1(/;"	d
CPP_PP_DEF_bool	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_bool$/;"	d
CPP_PP_DEF_class	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_class$/;"	d
CPP_PP_DEF_concept	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_concept$/;"	d
CPP_PP_DEF_int	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_int$/;"	d
CPP_PP_DEF_size_t	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_size_t$/;"	d
CPP_PP_DEF_template	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_template(/;"	d
CPP_PP_DEF_typename	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_typename$/;"	d
CPP_PP_DEF_unsigned	include/concepts/concepts.hpp	/^#define CPP_PP_DEF_unsigned$/;"	d
CPP_PP_EAT	include/concepts/concepts.hpp	/^#define CPP_PP_EAT(/;"	d
CPP_PP_EAT_MUTABLE_mutable	include/concepts/concepts.hpp	/^#define CPP_PP_EAT_MUTABLE_mutable$/;"	d
CPP_PP_EMPTY	include/concepts/concepts.hpp	/^#define CPP_PP_EMPTY(/;"	d
CPP_PP_EVAL	include/concepts/concepts.hpp	/^#define CPP_PP_EVAL(/;"	d
CPP_PP_EVAL2	include/concepts/concepts.hpp	/^#define CPP_PP_EVAL2(/;"	d
CPP_PP_EXPAND	include/concepts/concepts.hpp	/^#define CPP_PP_EXPAND(/;"	d
CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN	include/concepts/concepts.hpp	/^#define CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN /;"	d
CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN	include/concepts/concepts.hpp	/^#define CPP_PP_IGNORE_CXX2A_COMPAT_BEGIN$/;"	d
CPP_PP_IGNORE_CXX2A_COMPAT_END	include/concepts/concepts.hpp	/^#define CPP_PP_IGNORE_CXX2A_COMPAT_END /;"	d
CPP_PP_IGNORE_CXX2A_COMPAT_END	include/concepts/concepts.hpp	/^#define CPP_PP_IGNORE_CXX2A_COMPAT_END$/;"	d
CPP_PP_IIF	include/concepts/concepts.hpp	/^#define CPP_PP_IIF(/;"	d
CPP_PP_IIF_0	include/concepts/concepts.hpp	/^#define CPP_PP_IIF_0(/;"	d
CPP_PP_IIF_1	include/concepts/concepts.hpp	/^#define CPP_PP_IIF_1(/;"	d
CPP_PP_IS_NOT_EMPTY	include/concepts/concepts.hpp	/^#define CPP_PP_IS_NOT_EMPTY(/;"	d
CPP_PP_IS_PAREN	include/concepts/concepts.hpp	/^#define CPP_PP_IS_PAREN(/;"	d
CPP_PP_IS_PAREN_PROBE	include/concepts/concepts.hpp	/^#define CPP_PP_IS_PAREN_PROBE(/;"	d
CPP_PP_LBRACE	include/concepts/concepts.hpp	/^#define CPP_PP_LBRACE(/;"	d
CPP_PP_LPAREN	include/concepts/concepts.hpp	/^#define CPP_PP_LPAREN /;"	d
CPP_PP_NOT	include/concepts/concepts.hpp	/^#define CPP_PP_NOT(/;"	d
CPP_PP_NOT_0	include/concepts/concepts.hpp	/^#define CPP_PP_NOT_0 /;"	d
CPP_PP_NOT_1	include/concepts/concepts.hpp	/^#define CPP_PP_NOT_1 /;"	d
CPP_PP_PROBE	include/concepts/concepts.hpp	/^#define CPP_PP_PROBE(/;"	d
CPP_PP_PROBE_CONST_MUTABLE_PROBE_const	include/concepts/concepts.hpp	/^#define CPP_PP_PROBE_CONST_MUTABLE_PROBE_const /;"	d
CPP_PP_PROBE_CONST_MUTABLE_PROBE_mutable	include/concepts/concepts.hpp	/^#define CPP_PP_PROBE_CONST_MUTABLE_PROBE_mutable /;"	d
CPP_PP_PROBE_EMPTY	include/concepts/concepts.hpp	/^#define CPP_PP_PROBE_EMPTY(/;"	d
CPP_PP_PROBE_EMPTY_PROBE_CPP_PP_PROBE_EMPTY	include/concepts/concepts.hpp	/^#define CPP_PP_PROBE_EMPTY_PROBE_CPP_PP_PROBE_EMPTY /;"	d
CPP_PP_PROBE_N	include/concepts/concepts.hpp	/^#define CPP_PP_PROBE_N(/;"	d
CPP_PP_RBRACE	include/concepts/concepts.hpp	/^#define CPP_PP_RBRACE(/;"	d
CPP_PP_REQUIRES_PROBE_requires	include/concepts/concepts.hpp	/^#define CPP_PP_REQUIRES_PROBE_requires /;"	d
CPP_PP_TPARAM_1	include/concepts/concepts.hpp	/^#define CPP_PP_TPARAM_1(/;"	d
CPP_PP_TPARAM_2	include/concepts/concepts.hpp	/^#define CPP_PP_TPARAM_2(/;"	d
CPP_PP_TPARAM_3	include/concepts/concepts.hpp	/^#define CPP_PP_TPARAM_3(/;"	d
CPP_PP_TPARAM_4	include/concepts/concepts.hpp	/^#define CPP_PP_TPARAM_4(/;"	d
CPP_PP_TPARAM_5	include/concepts/concepts.hpp	/^#define CPP_PP_TPARAM_5(/;"	d
CPP_PRAGMA	include/concepts/swap.hpp	/^#define CPP_PRAGMA(/;"	d
CPP_SWAP_HPP	include/concepts/swap.hpp	/^#define CPP_SWAP_HPP$/;"	d
CPP_TEMPLATE_DEF_SFINAE_AUX_	include/concepts/concepts.hpp	/^#define CPP_TEMPLATE_DEF_SFINAE_AUX_(/;"	d
CPP_TEMPLATE_SFINAE_AUX_	include/concepts/concepts.hpp	/^#define CPP_TEMPLATE_SFINAE_AUX_(/;"	d
CPP_TEMPLATE_SFINAE_AUX_3_requires	include/concepts/concepts.hpp	/^#define CPP_TEMPLATE_SFINAE_AUX_3_requires$/;"	d
CPP_TYPE_TRAITS_HPP	include/concepts/type_traits.hpp	/^#define CPP_TYPE_TRAITS_HPP$/;"	d
CPP_WORKAROUND_MSVC_654601	include/concepts/concepts.hpp	/^#define CPP_WORKAROUND_MSVC_654601 /;"	d
CPP_WORKAROUND_MSVC_779763	include/concepts/concepts.hpp	/^#define CPP_WORKAROUND_MSVC_779763 /;"	d
CPP_WORKAROUND_MSVC_780775	include/concepts/concepts.hpp	/^#define CPP_WORKAROUND_MSVC_780775 /;"	d
CPP_WORKAROUND_MSVC_895622	include/concepts/swap.hpp	/^#define CPP_WORKAROUND_MSVC_895622 /;"	d
CPP_assert	include/concepts/concepts.hpp	/^#define CPP_assert(/;"	d
CPP_assert_msg	include/concepts/concepts.hpp	/^#define CPP_assert_msg /;"	d
CPP_auto_fun	include/concepts/concepts.hpp	/^#define CPP_auto_fun(/;"	d
CPP_auto_fun	include/range/v3/utility/get.hpp	/^        constexpr auto CPP_auto_fun(get)(TupleLike &&t)$/;"	f	namespace:ranges::_get_	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/adaptor.hpp	/^        static constexpr auto CPP_auto_fun(begin)(Rng &rng)$/;"	f	struct:ranges::adaptor_base	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/cycle.hpp	/^            auto CPP_auto_fun(read)()(const)$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/set_algorithm.hpp	/^            auto CPP_auto_fun(read)()(const)$/;"	f	struct:ranges::detail::set_difference_cursor	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/set_algorithm.hpp	/^            auto CPP_auto_fun(read)()(const)$/;"	f	struct:ranges::detail::set_intersection_cursor	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/transform.hpp	/^            auto CPP_auto_fun(read)()(const)$/;"	f	struct:ranges::iter_transform2_view::cursor	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/zip_with.hpp	/^            auto CPP_auto_fun(move_)(meta::index_sequence<Is...>)(const)$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:auto
CPP_auto_fun	include/range/v3/view/zip_with.hpp	/^            auto CPP_auto_fun(read)()(const)$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:auto
CPP_broken_friend_ret	include/concepts/concepts.hpp	/^#define CPP_broken_friend_ret(/;"	d
CPP_ctor	include/concepts/concepts.hpp	/^#define CPP_ctor(/;"	d
CPP_ctor	include/range/v3/detail/adl_get.hpp	/^            constexpr CPP_ctor(forward_tuple_interface)(TupleLike && base)(    \/\/$/;"	f	struct:ranges::_tuple_wrapper_::forward_tuple_interface	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/detail/adl_get.hpp	/^            constexpr CPP_ctor(forward_tuple_interface)(TupleLike const & base)( \/\/$/;"	f	struct:ranges::_tuple_wrapper_::forward_tuple_interface	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/detail/variant.hpp	/^            constexpr CPP_ctor(indexed_datum)()(                          \/\/$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/detail/variant.hpp	/^            constexpr CPP_ctor(indexed_datum)(indexed_datum<U, Index> that)( \/\/$/;"	f	struct:ranges::detail::indexed_datum
CPP_ctor	include/range/v3/detail/variant.hpp	/^        CPP_ctor(variant)(variant<Args...> that)( \/\/$/;"	f	struct:ranges::variant
CPP_ctor	include/range/v3/detail/variant.hpp	/^        constexpr CPP_ctor(variant)()(                                         \/\/$/;"	f	struct:ranges::variant	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/detail/variant.hpp	/^        constexpr CPP_ctor(variant)(RANGES_EMPLACED_INDEX_T(N), meta::nil_)(       \/\/$/;"	f	struct:ranges::variant
CPP_ctor	include/range/v3/functional/not_fn.hpp	/^        constexpr CPP_ctor(logical_negate)()(                          \/\/$/;"	f	struct:ranges::logical_negate	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/functional/not_fn.hpp	/^        explicit constexpr CPP_ctor(logical_negate)(T && pred)( \/\/$/;"	f	struct:ranges::logical_negate
CPP_ctor	include/range/v3/functional/reference_wrapper.hpp	/^        constexpr CPP_ctor(reference_wrapper)(U && u)(               \/\/$/;"	f	struct:ranges::reference_wrapper
CPP_ctor	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr CPP_ctor(basic_proxy_reference_)($/;"	f	struct:ranges::detail::basic_proxy_reference_
CPP_ctor	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr CPP_ctor(basic_iterator)(basic_iterator<OtherCur> that)( \/\/$/;"	f	struct:basic_iterator
CPP_ctor	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr CPP_ctor(basic_mixin)()(                            \/\/$/;"	f	struct:ranges::basic_mixin	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/iterator/basic_iterator.hpp	/^        explicit constexpr CPP_ctor(basic_mixin)(T && t)(          \/\/$/;"	f	struct:ranges::basic_mixin	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/iterator/basic_iterator.hpp	/^        explicit constexpr CPP_ctor(basic_mixin)(T const & t)(     \/\/$/;"	f	struct:ranges::basic_mixin	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/iterator/common_iterator.hpp	/^        CPP_ctor(common_iterator)(common_iterator<I2, S2> const & that)( \/\/$/;"	f	struct:ranges::common_iterator
CPP_ctor	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr CPP_ctor(counted_iterator)(counted_iterator<I2> const & i)( \/\/$/;"	f	struct:ranges::counted_iterator
CPP_ctor	include/range/v3/iterator/diffmax_t.hpp	/^            constexpr CPP_ctor(diffmax_t)(T val)(noexcept(true) \/\/$/;"	f	struct:ranges::detail::diffmax_t
CPP_ctor	include/range/v3/iterator/move_iterators.hpp	/^        CPP_ctor(move_iterator)(move_iterator<O> const & i)( \/\/$/;"	f	struct:ranges::move_iterator
CPP_ctor	include/range/v3/iterator/move_iterators.hpp	/^        constexpr explicit CPP_ctor(move_sentinel)(move_sentinel<OS> const & that)( \/\/$/;"	f	struct:ranges::move_sentinel
CPP_ctor	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr CPP_ctor(reverse_cursor)(reverse_cursor<U> const & u)( \/\/$/;"	f	struct:ranges::detail::reverse_cursor
CPP_ctor	include/range/v3/iterator_range.hpp	/^        RANGES_NDEBUG_CONSTEXPR CPP_ctor(sized_iterator_range)($/;"	f	struct:ranges::sized_iterator_range	typeref:typename:RANGES_NDEBUG_CONSTEXPR
CPP_ctor	include/range/v3/iterator_range.hpp	/^        RANGES_NDEBUG_CONSTEXPR CPP_ctor(sized_iterator_range)(iterator_range<X, Y> rng,$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:RANGES_NDEBUG_CONSTEXPR
CPP_ctor	include/range/v3/iterator_range.hpp	/^        RANGES_NDEBUG_CONSTEXPR CPP_ctor(sized_iterator_range)(std::pair<X, Y> rng,$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:RANGES_NDEBUG_CONSTEXPR
CPP_ctor	include/range/v3/iterator_range.hpp	/^        constexpr CPP_ctor(iterator_range)(iterator_range<X, Y> rng)( \/\/$/;"	f	struct:ranges::iterator_range
CPP_ctor	include/range/v3/iterator_range.hpp	/^        explicit constexpr CPP_ctor(iterator_range)(std::pair<X, Y> rng)( \/\/$/;"	f	struct:ranges::iterator_range
CPP_ctor	include/range/v3/range/dangling.hpp	/^        constexpr CPP_ctor(dangling)(T &&)( \/\/$/;"	f	struct:ranges::dangling
CPP_ctor	include/range/v3/utility/any.hpp	/^        CPP_ctor(any)(TRef && t)( \/\/$/;"	f	struct:ranges::any
CPP_ctor	include/range/v3/utility/box.hpp	/^        constexpr CPP_ctor(box)()(                                          \/\/$/;"	f	class:ranges::box	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/utility/box.hpp	/^        constexpr CPP_ctor(box)(E && e)(                               \/\/$/;"	f	class:ranges::box
CPP_ctor	include/range/v3/utility/box.hpp	/^        constexpr CPP_ctor(box)(E &&)( \/\/$/;"	f	class:ranges::box
CPP_ctor	include/range/v3/utility/box.hpp	/^        constexpr CPP_ctor(mutable_)()( \/\/$/;"	f	struct:ranges::mutable_	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/utility/box.hpp	/^        constexpr explicit CPP_ctor(box)(E && e)(                      \/\/$/;"	f	class:ranges::box
CPP_ctor	include/range/v3/utility/box.hpp	/^        constexpr explicit CPP_ctor(box)(E &&)( \/\/$/;"	f	class:ranges::box
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_pair)()( \/\/$/;"	f	struct:ranges::common_pair	typeref:typename:CPP_member
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_pair)(F2 && f2, S2 && s2)( \/\/$/;"	f	struct:ranges::common_pair
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_pair)(std::pair<F2, S2> & that)( \/\/$/;"	f	struct:ranges::common_pair
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_pair)(std::pair<F2, S2> && that)( \/\/$/;"	f	struct:ranges::common_pair
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_pair)(std::pair<F2, S2> const & that)( \/\/$/;"	f	struct:ranges::common_pair
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)()( \/\/$/;"	f	struct:ranges::common_tuple	typeref:typename:CPP_member
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)(common_tuple<Us...> & that)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)(common_tuple<Us...> && that)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)(common_tuple<Us...> const & that)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)(std::tuple<Us...> & that)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)(std::tuple<Us...> && that)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_ctor	include/range/v3/utility/common_tuple.hpp	/^        CPP_ctor(common_tuple)(std::tuple<Us...> const & that)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_ctor	include/range/v3/utility/optional.hpp	/^                constexpr explicit CPP_ctor(optional_base)(in_place_t, Arg && arg)( \/\/$/;"	f	struct:ranges::detail::optional_adl::optional_base
CPP_ctor	include/range/v3/utility/optional.hpp	/^        CPP_ctor(optional)(optional<U> && that)( \/\/$/;"	f	struct:ranges::optional
CPP_ctor	include/range/v3/utility/optional.hpp	/^        CPP_ctor(optional)(optional<U> const & that)( \/\/$/;"	f	struct:ranges::optional
CPP_ctor	include/range/v3/utility/optional.hpp	/^        constexpr CPP_ctor(optional)(U && v)( \/\/$/;"	f	struct:ranges::optional
CPP_ctor	include/range/v3/utility/optional.hpp	/^        explicit CPP_ctor(optional)(optional<U> && that)( \/\/$/;"	f	struct:ranges::optional
CPP_ctor	include/range/v3/utility/optional.hpp	/^        explicit CPP_ctor(optional)(optional<U> const & that)( \/\/$/;"	f	struct:ranges::optional
CPP_ctor	include/range/v3/utility/optional.hpp	/^        explicit constexpr CPP_ctor(optional)(U && v)( \/\/$/;"	f	struct:ranges::optional
CPP_ctor	include/range/v3/utility/random.hpp	/^                CPP_ctor(seed_seq_fe)(I first, S last)( \/\/$/;"	f	struct:ranges::detail::randutils::seed_seq_fe
CPP_ctor	include/range/v3/utility/random.hpp	/^                CPP_ctor(seed_seq_fe)(std::initializer_list<T> init)( \/\/$/;"	f	struct:ranges::detail::randutils::seed_seq_fe
CPP_ctor	include/range/v3/utility/semiregular_box.hpp	/^        CPP_ctor(semiregular_box)(in_place_t, Arg & arg)( \/\/$/;"	f	struct:ranges::semiregular_box
CPP_ctor	include/range/v3/utility/semiregular_box.hpp	/^        CPP_ctor(semiregular_box)(in_place_t, Arg && arg)( \/\/$/;"	f	struct:ranges::semiregular_box
CPP_ctor	include/range/v3/utility/semiregular_box.hpp	/^        constexpr CPP_ctor(semiregular_box)(U && u)(             \/\/$/;"	f	struct:ranges::semiregular_box
CPP_ctor	include/range/v3/utility/semiregular_box.hpp	/^        explicit constexpr CPP_ctor(semiregular_box)(U && u)(    \/\/$/;"	f	struct:ranges::semiregular_box
CPP_ctor	include/range/v3/utility/semiregular_box.hpp	/^        explicit(!convertible_to<U, T>) constexpr CPP_ctor(semiregular_box)(U && u)( \/\/$/;"	f	struct:ranges::semiregular_box	typeref:typename:(!convertible_to<U,T>)
CPP_ctor	include/range/v3/utility/tagged_pair.hpp	/^        constexpr CPP_ctor(tagged)(tagged<Other, Tags...> && that)(     \/\/$/;"	f	class:ranges::tagged
CPP_ctor	include/range/v3/utility/tagged_pair.hpp	/^        constexpr CPP_ctor(tagged)(tagged<Other, Tags...> const & that)(        \/\/$/;"	f	class:ranges::tagged
CPP_ctor	include/range/v3/utility/variant.hpp	/^            CPP_ctor(indexed_datum)(I first, S last)( \/\/$/;"	f	struct:ranges::detail::indexed_datum
CPP_ctor	include/range/v3/utility/variant.hpp	/^            CPP_ctor(indexed_datum)(indexed_datum && that)(requires move_constructible<T>)$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_member
CPP_ctor	include/range/v3/utility/variant.hpp	/^            CPP_ctor(indexed_datum)(indexed_datum const & that)($/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_member
CPP_ctor	include/range/v3/utility/variant.hpp	/^            constexpr CPP_ctor(indexed_datum)(meta::nil_ = {})($/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/utility/variant.hpp	/^            explicit CPP_ctor(indexed_datum)(R && r)( \/\/$/;"	f	struct:ranges::detail::indexed_datum
CPP_ctor	include/range/v3/view/adaptor.hpp	/^        CPP_ctor(adaptor_cursor)(adaptor_cursor<OtherIter, OtherAdapt> that)($/;"	f	struct:ranges::adaptor_cursor
CPP_ctor	include/range/v3/view/interface.hpp	/^            constexpr CPP_ctor(slice_bounds)(F f, T t)( \/\/$/;"	f	struct:ranges::detail::slice_bounds
CPP_ctor	include/range/v3/view/sliding.hpp	/^            CPP_ctor(adaptor)(adaptor<Other> that)( \/\/$/;"	f	struct:ranges::sliding_view::adaptor
CPP_ctor	include/range/v3/view/split.hpp	/^            constexpr CPP_ctor(split_outer_iterator)(Parent & parent,$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/view/split.hpp	/^            constexpr explicit CPP_ctor(split_outer_iterator)(Parent & parent)( \/\/$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/view/split.hpp	/^        constexpr CPP_ctor(split_view)(V base, range_value_t<V> e)($/;"	f	struct:ranges::split_view	typeref:typename:CPP_member 
CPP_ctor	include/range/v3/view/subrange.hpp	/^        constexpr CPP_ctor(subrange)(I2 && i, S s)( \/\/$/;"	f	struct:ranges::subrange
CPP_ctor	include/range/v3/view/subrange.hpp	/^        constexpr CPP_ctor(subrange)(I2 && i, S s, size_type n)( \/\/$/;"	f	struct:ranges::subrange
CPP_ctor	include/range/v3/view/subrange.hpp	/^        constexpr CPP_ctor(subrange)(R && r)($/;"	f	struct:ranges::subrange
CPP_ctor	include/range/v3/view/subrange.hpp	/^        constexpr CPP_ctor(subrange)(R && r, size_type n)($/;"	f	struct:ranges::subrange
CPP_ctor_sfinae	include/concepts/concepts.hpp	/^#define CPP_ctor_sfinae(/;"	d
CPP_def	include/concepts/concepts.hpp	/^#define CPP_def(/;"	d
CPP_fun	include/concepts/concepts.hpp	/^#define CPP_fun(/;"	d
CPP_fun	include/range/v3/action/adjacent_remove_if.hpp	/^            constexpr auto CPP_fun(operator())(Pred pred,$/;"	f	struct:ranges::actions::adjacent_remove_if_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/drop.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::actions::drop_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/drop_while.hpp	/^            constexpr auto CPP_fun(operator())(Fun fun)(const \/\/$/;"	f	struct:ranges::actions::drop_while_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/remove.hpp	/^            constexpr auto CPP_fun(operator())(V && value, P proj)(const \/\/$/;"	f	struct:ranges::actions::remove_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/remove_if.hpp	/^            constexpr auto CPP_fun(operator())(C pred, P proj = P{})(const \/\/$/;"	f	struct:ranges::actions::remove_if_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/shuffle.hpp	/^            constexpr auto CPP_fun(operator())(Gen & gen)($/;"	f	struct:ranges::actions::shuffle_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/shuffle.hpp	/^            constexpr auto CPP_fun(operator())(Gen && gen)($/;"	f	struct:ranges::actions::shuffle_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/slice.hpp	/^            constexpr auto CPP_fun(operator())(D from, D to)(const \/\/$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/slice.hpp	/^            constexpr auto CPP_fun(operator())(D from, detail::from_end_<D> to)($/;"	f	struct:ranges::actions::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/slice.hpp	/^            constexpr auto CPP_fun(operator())(D from,$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/slice.hpp	/^            constexpr auto CPP_fun(operator())(detail::from_end_<D> from,$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/sort.hpp	/^            constexpr auto CPP_fun(operator())(C pred, P proj = {})(const \/\/$/;"	f	struct:ranges::actions::sort_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/stable_sort.hpp	/^            constexpr auto CPP_fun(operator())(C pred, P proj = P{})(const \/\/$/;"	f	struct:ranges::actions::stable_sort_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/stride.hpp	/^            constexpr auto CPP_fun(operator())(D step)(const \/\/$/;"	f	struct:ranges::actions::stride_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/take.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::actions::take_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/take_while.hpp	/^            constexpr auto CPP_fun(operator())(Fun fun)(const \/\/$/;"	f	struct:ranges::actions::take_while_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/transform.hpp	/^            constexpr auto CPP_fun(operator())(F fun, P proj = P{})(const \/\/$/;"	f	struct:ranges::actions::transform_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/unique.hpp	/^            constexpr auto CPP_fun(operator())(C pred, P proj = P{})(const \/\/$/;"	f	struct:ranges::actions::unique_fn	typeref:typename:auto
CPP_fun	include/range/v3/action/unstable_remove_if.hpp	/^            constexpr auto CPP_fun(operator())(C pred, P proj = P{})(const \/\/$/;"	f	struct:ranges::actions::unstable_remove_if_fn	typeref:typename:auto
CPP_fun	include/range/v3/experimental/view/shared.hpp	/^            auto CPP_fun(size)()(const requires sized_range<Rng>)$/;"	f	struct:ranges::experimental::shared_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/functional/invoke.hpp	/^        static constexpr decltype(auto) CPP_fun(coerce)(T1 && t1, int)($/;"	f	struct:ranges::invoke_fn	typeref:typename:decltype (auto)
CPP_fun	include/range/v3/functional/invoke.hpp	/^        static constexpr decltype(auto) CPP_fun(coerce)(T1 && t1, long)( \/\/$/;"	f	struct:ranges::invoke_fn	typeref:typename:decltype (auto)
CPP_fun	include/range/v3/range/access.hpp	/^            constexpr auto CPP_fun(operator())(R && r)($/;"	f	struct:ranges::_begin_::fn	typeref:typename:auto
CPP_fun	include/range/v3/range/access.hpp	/^            constexpr auto CPP_fun(operator())(R && r)($/;"	f	struct:ranges::_end_::fn	typeref:typename:auto
CPP_fun	include/range/v3/range/access.hpp	/^            constexpr auto CPP_fun(operator())(R && r)($/;"	f	struct:ranges::_rbegin_::fn	typeref:typename:auto
CPP_fun	include/range/v3/range/access.hpp	/^            constexpr auto CPP_fun(operator())(R && r)($/;"	f	struct:ranges::_rend_::fn	typeref:typename:auto
CPP_fun	include/range/v3/view/all.hpp	/^            constexpr auto CPP_fun(operator())(T && t)(const requires viewable_range<T>)$/;"	f	struct:ranges::views::all_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/cache1.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::cache1_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/cartesian_product.hpp	/^            auto CPP_fun(distance_to)(cursor const & that)($/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/cartesian_product.hpp	/^        auto CPP_fun(size)()(const \/\/$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/cartesian_product.hpp	/^        auto CPP_fun(size)()(requires(my_cardinality < 0) &&$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/chunk.hpp	/^                constexpr auto CPP_fun(size)()($/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/chunk.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::chunk_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/chunk.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::chunk_view_	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/chunk.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::chunk_view_	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/common.hpp	/^        auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::common_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/common.hpp	/^        auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::common_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/concat.hpp	/^        constexpr auto CPP_fun(size)()($/;"	f	struct:ranges::concat_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/const.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::const_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/const.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::const_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/cycle.hpp	/^            auto CPP_fun(distance_to)(cursor const & that)($/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop.hpp	/^            auto CPP_fun(operator())(Rng && rng, range_difference_t<Rng> n)($/;"	f	struct:ranges::views::drop_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/drop.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::drop_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/drop.hpp	/^        auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::drop_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop.hpp	/^        auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::drop_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop_exactly.hpp	/^            auto CPP_fun(operator())(Rng && rng, range_difference_t<Rng> n)($/;"	f	struct:ranges::views::drop_exactly_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/drop_exactly.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::drop_exactly_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/drop_exactly.hpp	/^        auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop_exactly.hpp	/^        auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop_last.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::drop_last_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/drop_last.hpp	/^        auto CPP_fun(size)()( \/\/$/;"	f	struct:ranges::drop_last_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop_last.hpp	/^        auto CPP_fun(size)()( \/\/$/;"	f	struct:ranges::drop_last_view	typeref:typename:auto
CPP_fun	include/range/v3/view/drop_last.hpp	/^        auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::drop_last_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/drop_while.hpp	/^            constexpr auto CPP_fun(operator())(Pred && pred,$/;"	f	struct:ranges::views::drop_while_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/enumerate.hpp	/^            auto CPP_fun(operator())(Rng && rng)(const requires viewable_range<Rng>)$/;"	f	struct:ranges::views::enumerate_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/exclusive_scan.hpp	/^        auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::exclusive_scan_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/exclusive_scan.hpp	/^        auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::exclusive_scan_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/for_each.hpp	/^            constexpr auto CPP_fun(operator())(Rng && rng, Fun fun)($/;"	f	struct:ranges::views::for_each_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/indirect.hpp	/^            constexpr auto CPP_fun(operator())(Rng && rng)($/;"	f	struct:ranges::views::indirect_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/indirect.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::indirect_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/indirect.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::indirect_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/intersperse.hpp	/^            constexpr auto CPP_fun(operator())(T t)(const \/\/$/;"	f	struct:ranges::views::intersperse_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/intersperse.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::intersperse_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/intersperse.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::intersperse_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/iota.hpp	/^        auto CPP_fun(end_cursor)()(const requires(!same_as<To, unreachable_sentinel_t>))$/;"	f	struct:ranges::iota_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/iota.hpp	/^        auto CPP_fun(end_cursor)()(const requires(same_as<To, unreachable_sentinel_t>))$/;"	f	struct:ranges::iota_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/join.hpp	/^            constexpr auto CPP_fun(operator())(T && t)(const \/\/$/;"	f	struct:ranges::views::join_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/join.hpp	/^        auto CPP_fun(size)()(const requires(detail::join_cardinality<Rng, ValRng>() <$/;"	f	struct:ranges::join_with_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/join.hpp	/^        constexpr auto CPP_fun(end_cursor)()($/;"	f	struct:ranges::join_view	typeref:typename:auto
CPP_fun	include/range/v3/view/join.hpp	/^        constexpr auto CPP_fun(size)()(requires(detail::join_cardinality<Rng>() < 0) &&$/;"	f	struct:ranges::join_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/linear_distribute.hpp	/^            constexpr auto CPP_fun(operator())(T from, T to, std::ptrdiff_t n)($/;"	f	struct:ranges::views::linear_distribute_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/move.hpp	/^        auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::move_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/move.hpp	/^        auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::move_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/partial_sum.hpp	/^            constexpr auto CPP_fun(operator())(Fun && fun)(const \/\/$/;"	f	struct:ranges::views::partial_sum_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/partial_sum.hpp	/^            constexpr bool CPP_fun(equal)(cursor const & that)($/;"	f	struct:ranges::partial_sum_view::cursor	typeref:typename:CPP_member bool
CPP_fun	include/range/v3/view/partial_sum.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::partial_sum_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/partial_sum.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::partial_sum_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/ref.hpp	/^        constexpr auto CPP_fun(data)()(const noexcept(noexcept(ranges::data(*rng_))) \/\/$/;"	f	struct:ranges::ref_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/ref.hpp	/^        constexpr auto CPP_fun(size)()(const noexcept(noexcept(ranges::size(*rng_))) \/\/$/;"	f	struct:ranges::ref_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/remove.hpp	/^            constexpr auto CPP_fun(operator())(Rng && rng, Value value)($/;"	f	struct:ranges::views::remove_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/remove.hpp	/^            constexpr auto CPP_fun(operator())(Rng && rng, Value value, Proj proj)($/;"	f	struct:ranges::views::remove_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/remove.hpp	/^            constexpr auto CPP_fun(operator())(Value && value,$/;"	f	struct:ranges::views::remove_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/remove_if.hpp	/^            constexpr auto CPP_fun(operator())(Pred && pred,$/;"	f	struct:ranges::views::remove_if_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/replace.hpp	/^            constexpr auto CPP_fun(operator())(Val1 old_value, Val2 new_value)($/;"	f	struct:ranges::views::replace_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/reverse.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::reverse_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/reverse.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::reverse_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/sample.hpp	/^            constexpr auto CPP_fun(operator())(Size n,$/;"	f	struct:ranges::views::sample_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/set_algorithm.hpp	/^            constexpr auto CPP_fun(operator())(Rng2 && rng2, C && pred = C{},$/;"	f	struct:ranges::views::set_difference_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/set_algorithm.hpp	/^            constexpr auto CPP_fun(operator())(Rng2 && rng2, C && pred = C{},$/;"	f	struct:ranges::views::set_intersection_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/set_algorithm.hpp	/^            constexpr auto CPP_fun(operator())(Rng2 && rng2, C && pred = C{},$/;"	f	struct:ranges::views::set_symmetric_difference_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/set_algorithm.hpp	/^            constexpr auto CPP_fun(operator())(Rng2 && rng2, C && pred = C{},$/;"	f	struct:ranges::views::set_union_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            auto CPP_fun(operator())( \/\/$/;"	f	struct:ranges::views::slice_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            auto CPP_fun(operator())(Rng && rng, detail::from_end_of_t<Rng> from,$/;"	f	struct:ranges::views::slice_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            auto CPP_fun(operator())(Rng && rng, range_difference_t<Rng> from, end_fn)($/;"	f	struct:ranges::views::slice_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            constexpr auto CPP_fun(operator())( \/\/$/;"	f	struct:ranges::views::slice_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            constexpr auto CPP_fun(operator())(Int from, Int to)($/;"	f	struct:ranges::views::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            constexpr auto CPP_fun(operator())(Int from, end_fn)($/;"	f	struct:ranges::views::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            constexpr auto CPP_fun(operator())(Int from,$/;"	f	struct:ranges::views::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/slice.hpp	/^            constexpr auto CPP_fun(operator())(detail::from_end_<Int> from,$/;"	f	struct:ranges::views::slice_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/sliding.hpp	/^            auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::sliding_view_detail::sv_base	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/sliding.hpp	/^            auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::sliding_view_detail::sv_base	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/sliding.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::sliding_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/stride.hpp	/^            constexpr auto CPP_fun(operator())(Difference step)($/;"	f	struct:ranges::views::stride_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/stride.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::stride_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/stride.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::stride_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/tail.hpp	/^        constexpr auto CPP_fun(size)()(const requires(bool(sized_range<Rng const>)))$/;"	f	struct:ranges::tail_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/tail.hpp	/^        constexpr auto CPP_fun(size)()(requires(bool(sized_range<Rng>)))$/;"	f	struct:ranges::tail_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::take_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/take.hpp	/^        constexpr auto CPP_fun(begin)()(const requires range<Rng const>)$/;"	f	struct:ranges::take_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take.hpp	/^        constexpr auto CPP_fun(begin)()(requires(!simple_view<Rng>()))$/;"	f	struct:ranges::take_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take.hpp	/^        constexpr auto CPP_fun(end)()(const requires range<Rng const>)$/;"	f	struct:ranges::take_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take.hpp	/^        constexpr auto CPP_fun(end)()(requires(!simple_view<Rng>()))$/;"	f	struct:ranges::take_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::take_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::take_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take_exactly.hpp	/^            auto CPP_fun(begin)()(const requires range<Rng const>)$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take_exactly.hpp	/^            auto CPP_fun(end)()(const requires range<Rng const>)$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/take_exactly.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::take_exactly_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/take_exactly.hpp	/^            constexpr auto CPP_fun(operator())(Rng && rng, range_difference_t<Rng> n)($/;"	f	struct:ranges::views::take_exactly_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/take_last.hpp	/^            auto CPP_fun(operator())(Rng && rng, range_difference_t<Rng> n)($/;"	f	struct:ranges::views::take_last_base_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/take_last.hpp	/^            constexpr auto CPP_fun(operator())(Int n)(const \/\/$/;"	f	struct:ranges::views::take_last_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/take_while.hpp	/^            constexpr auto CPP_fun(operator())(Pred && pred,$/;"	f	struct:ranges::views::take_while_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/transform.hpp	/^        constexpr auto CPP_fun(size)()(const requires sized_range<Rng const>)$/;"	f	struct:ranges::iter_transform_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/transform.hpp	/^        constexpr auto CPP_fun(size)()(requires sized_range<Rng>)$/;"	f	struct:ranges::iter_transform_view	typeref:typename:CPP_member auto
CPP_fun	include/range/v3/view/trim.hpp	/^            constexpr auto CPP_fun(operator())(Pred && pred,$/;"	f	struct:ranges::views::trim_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/unique.hpp	/^            constexpr auto CPP_fun(operator())(C && pred)(const \/\/$/;"	f	struct:ranges::views::unique_fn	typeref:typename:auto
CPP_fun	include/range/v3/view/view.hpp	/^            static constexpr auto CPP_fun(pipe)(Rng && rng, Vw && v)( \/\/$/;"	f	struct:ranges::views::old_view_	typeref:typename:auto
CPP_fun	include/range/v3/view/zip_with.hpp	/^        constexpr auto CPP_fun(size)()(const requires and_v<sized_range<Rngs const>...>)$/;"	f	struct:ranges::iter_zip_with_view	typeref:typename:CPP_member auto
CPP_member	include/concepts/concepts.hpp	/^#define CPP_member$/;"	d
CPP_member_sfinae	include/concepts/concepts.hpp	/^#define CPP_member_sfinae /;"	d
CPP_ret	include/concepts/concepts.hpp	/^#define CPP_ret(/;"	d
CPP_template	include/concepts/concepts.hpp	/^#define CPP_template(/;"	d
CPP_template	include/range/v3/detail/adl_get.hpp	/^            CPP_template(typename B = TupleLike)( \/\/$/;"	f	struct:ranges::_tuple_wrapper_::forward_tuple_interface
CPP_template	include/range/v3/detail/variant.hpp	/^            CPP_template(typename... Ts)(                                      \/\/$/;"	f	struct:ranges::detail::indexed_datum
CPP_template	include/range/v3/detail/variant.hpp	/^        CPP_template(std::size_t N, typename T, typename... Args)( \/\/$/;"	f	struct:ranges::variant
CPP_template	include/range/v3/detail/variant.hpp	/^        CPP_template(std::size_t N, typename... Args)(        \/\/$/;"	f	struct:ranges::variant
CPP_template	include/range/v3/functional/reference_wrapper.hpp	/^        CPP_template(typename U)( \/\/$/;"	f	struct:ranges::reference_wrapper
CPP_template	include/range/v3/functional/reference_wrapper.hpp	/^        CPP_template(typename...)(                         \/\/$/;"	f	struct:ranges::reference_wrapper
CPP_template	include/range/v3/iterator/diffmax_t.hpp	/^            CPP_template(typename T)( \/\/$/;"	f	struct:ranges::detail::diffmax_t
CPP_template	include/range/v3/iterator_range.hpp	/^        CPP_template(std::size_t N)( \/\/$/;"	f	namespace:ranges
CPP_template	include/range/v3/iterator_range.hpp	/^        CPP_template(typename X, typename Y)(                      \/\/$/;"	f	struct:ranges::iterator_range
CPP_template	include/range/v3/iterator_range.hpp	/^        CPP_template(typename X, typename Y)(                      \/\/$/;"	f	struct:ranges::sized_iterator_range
CPP_template	include/range/v3/utility/common_tuple.hpp	/^        CPP_template(typename F2, typename S2)(                                  \/\/$/;"	f	struct:ranges::common_pair
CPP_template	include/range/v3/utility/common_tuple.hpp	/^        CPP_template(typename F2, typename S2)(                              \/\/$/;"	f	struct:ranges::common_pair
CPP_template	include/range/v3/utility/common_tuple.hpp	/^        CPP_template(typename F2, typename S2)( \/\/$/;"	f	struct:ranges::common_pair
CPP_template	include/range/v3/utility/common_tuple.hpp	/^        CPP_template(typename... Us)(                                               \/\/$/;"	f	struct:ranges::common_tuple
CPP_template	include/range/v3/utility/common_tuple.hpp	/^        CPP_template(typename... Us)(                                              \/\/$/;"	f	struct:ranges::common_tuple
CPP_template	include/range/v3/utility/common_tuple.hpp	/^        CPP_template(typename... Us)( \/\/$/;"	f	struct:ranges::common_tuple
CPP_template	include/range/v3/utility/compressed_pair.hpp	/^        CPP_template(typename F, typename S)( \/\/$/;"	f	struct:ranges::compressed_pair
CPP_template	include/range/v3/utility/compressed_pair.hpp	/^        CPP_template(typename U, typename V)(                                       \/\/$/;"	f	struct:ranges::compressed_pair
CPP_template	include/range/v3/utility/optional.hpp	/^                CPP_template(typename... Args)(              \/\/$/;"	f	struct:ranges::detail::optional_adl::optional_storage
CPP_template	include/range/v3/utility/optional.hpp	/^        CPP_template(typename E, typename... Args)(                              \/\/$/;"	f	struct:ranges::optional
CPP_template	include/range/v3/utility/optional.hpp	/^        CPP_template(typename U)(                                   \/\/$/;"	f	struct:ranges::optional
CPP_template	include/range/v3/utility/semiregular_box.hpp	/^        CPP_template(typename... Args)(                            \/\/$/;"	f	struct:ranges::semiregular_box
CPP_template	include/range/v3/utility/tagged_pair.hpp	/^        CPP_template(typename Other)(                             \/\/$/;"	f	class:ranges::tagged
CPP_template	include/range/v3/utility/tagged_pair.hpp	/^        CPP_template(typename Other)(                        \/\/$/;"	f	class:ranges::tagged
CPP_template	include/range/v3/view/adjacent_filter.hpp	/^            CPP_template(bool Other)(       \/\/$/;"	f	struct:ranges::adjacent_filter_view::adaptor
CPP_template	include/range/v3/view/cartesian_product.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::cartesian_product_view::cursor
CPP_template	include/range/v3/view/cartesian_product.hpp	/^        CPP_template(int = 42)(            \/\/$/;"	f	struct:ranges::cartesian_product_view
CPP_template	include/range/v3/view/chunk.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::chunk_view_::adaptor
CPP_template	include/range/v3/view/concat.hpp	/^            CPP_template(bool Other)(         \/\/$/;"	f	struct:ranges::concat_view::cursor
CPP_template	include/range/v3/view/concat.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::concat_view::sentinel
CPP_template	include/range/v3/view/const.hpp	/^            CPP_template(bool Other)(       \/\/$/;"	f	struct:ranges::const_view::adaptor
CPP_template	include/range/v3/view/cycle.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::cycled_view::cursor
CPP_template	include/range/v3/view/cycle.hpp	/^            CPP_template(typename Diff)( \/\/$/;"	f	struct:ranges::cycled_view::cursor
CPP_template	include/range/v3/view/exclusive_scan.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::exclusive_scan_view::adaptor
CPP_template	include/range/v3/view/group_by.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::group_by_view::cursor
CPP_template	include/range/v3/view/indirect.hpp	/^            CPP_template(bool Other)(         \/\/$/;"	f	struct:ranges::indirect_view::adaptor
CPP_template	include/range/v3/view/interface.hpp	/^            CPP_template(typename Other)(                                               \/\/$/;"	f	struct:ranges::detail::from_end_
CPP_template	include/range/v3/view/interface.hpp	/^        CPP_template(bool True = true, typename Slice = views::slice_fn)(      \/\/$/;"	f	struct:ranges::view_interface
CPP_template	include/range/v3/view/interface.hpp	/^        CPP_template(bool True = true, typename Slice = views::slice_fn)(  \/\/$/;"	f	struct:ranges::view_interface
CPP_template	include/range/v3/view/interface.hpp	/^        CPP_template(bool True = true, typename Slice = views::slice_fn)( \/\/$/;"	f	struct:ranges::view_interface
CPP_template	include/range/v3/view/interface.hpp	/^        CPP_template(typename Container, bool True = true)( \/\/ clang-format off$/;"	f	struct:ranges::view_interface
CPP_template	include/range/v3/view/intersperse.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::intersperse_view::cursor_adaptor
CPP_template	include/range/v3/view/intersperse.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::intersperse_view::sentinel_adaptor
CPP_template	include/range/v3/view/join.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::join_view::cursor
CPP_template	include/range/v3/view/move.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::move_view::adaptor
CPP_template	include/range/v3/view/partial_sum.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::partial_sum_view::cursor
CPP_template	include/range/v3/view/sample.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	class:ranges::sample_view::cursor
CPP_template	include/range/v3/view/set_algorithm.hpp	/^            CPP_template(bool Other)(         \/\/$/;"	f	struct:ranges::detail::set_difference_cursor
CPP_template	include/range/v3/view/set_algorithm.hpp	/^            CPP_template(bool Other)(         \/\/$/;"	f	struct:ranges::detail::set_intersection_cursor
CPP_template	include/range/v3/view/set_algorithm.hpp	/^            CPP_template(bool Other)(         \/\/$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor
CPP_template	include/range/v3/view/set_algorithm.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::detail::set_union_cursor
CPP_template	include/range/v3/view/single.hpp	/^        CPP_template(class... Args)(                 \/\/$/;"	f	struct:ranges::single_view
CPP_template	include/range/v3/view/span.hpp	/^        CPP_template(typename Rng)( \/\/$/;"	f	struct:ranges::span
CPP_template	include/range/v3/view/span.hpp	/^    CPP_template(typename Rng)( \/\/$/;"	f	namespace:ranges
CPP_template	include/range/v3/view/split.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::detail::split_outer_iterator
CPP_template	include/range/v3/view/split_when.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::split_when_view::cursor
CPP_template	include/range/v3/view/stride.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::stride_view::adaptor
CPP_template	include/range/v3/view/subrange.hpp	/^        CPP_template(typename PairLike)( \/\/$/;"	f	struct:ranges::subrange
CPP_template	include/range/v3/view/take.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::take_view::sentinel
CPP_template	include/range/v3/view/take_while.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::iter_take_while_view::sentinel_adaptor
CPP_template	include/range/v3/view/transform.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::iter_transform2_view::cursor
CPP_template	include/range/v3/view/transform.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::iter_transform2_view::sentinel
CPP_template	include/range/v3/view/transform.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::iter_transform_view::adaptor
CPP_template	include/range/v3/view/transform.hpp	/^        CPP_template(bool True = true)( \/\/$/;"	f	struct:ranges::iter_transform2_view
CPP_template	include/range/v3/view/zip_with.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::iter_zip_with_view::cursor
CPP_template	include/range/v3/view/zip_with.hpp	/^            CPP_template(bool Other)( \/\/$/;"	f	struct:ranges::iter_zip_with_view::sentinel
CPP_template_def	include/concepts/concepts.hpp	/^#define CPP_template_def /;"	d
CPP_template_def_sfinae	include/concepts/concepts.hpp	/^#define CPP_template_def_sfinae(/;"	d
CPP_template_gcc_workaround	include/range/v3/view/interface.hpp	/^        CPP_template_gcc_workaround(bool True = true)(          \/\/$/;"	f	struct:ranges::view_interface
CPP_template_gcc_workaround	include/range/v3/view/interface.hpp	/^        CPP_template_gcc_workaround(bool True = true)(    \/\/$/;"	f	struct:ranges::view_interface
CPP_template_gcc_workaround	include/range/v3/view/interface.hpp	/^#define CPP_template_gcc_workaround /;"	d
CPP_template_sfinae	include/concepts/concepts.hpp	/^#define CPP_template_sfinae(/;"	d
CPP_true	include/concepts/concepts.hpp	/^        constexpr std::true_type CPP_true(Nil)$/;"	f	namespace:concepts::detail	typeref:typename:std::true_type
CPP_true	include/concepts/concepts.hpp	/^        constexpr std::true_type CPP_true(xNil)$/;"	f	namespace:concepts::detail	typeref:typename:std::true_type
CPP_true_	include/concepts/concepts.hpp	/^        CPP_INLINE_VAR constexpr CPP_true_t CPP_true_{};$/;"	v	namespace:concepts::detail	typeref:typename:CPP_INLINE_VAR CPP_true_t
CPP_true_t	include/concepts/concepts.hpp	/^        struct CPP_true_t$/;"	s	namespace:concepts::detail
CRng	include/range/v3/view/adjacent_filter.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::adjacent_filter_view::adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/chunk.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::chunk_view_::adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/const.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::const_view::adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/cycle.hpp	/^            using CRng = constify_if<Rng>;$/;"	t	struct:ranges::cycled_view::cursor	typeref:typename:constify_if<Rng>
CRng	include/range/v3/view/exclusive_scan.hpp	/^            using CRng = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:meta::const_if_c<IsConst,Rng>
CRng	include/range/v3/view/group_by.hpp	/^            using CRng = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::group_by_view::cursor	typeref:typename:meta::const_if_c<IsConst,Rng>
CRng	include/range/v3/view/indirect.hpp	/^            using CRng = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::indirect_view::adaptor	typeref:typename:meta::const_if_c<IsConst,Rng>
CRng	include/range/v3/view/intersperse.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/intersperse.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::intersperse_view::sentinel_adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/join.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	function:ranges::join_view::CPP_fun	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/move.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::move_view::adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/sliding.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::sliding_view::adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/split_when.hpp	/^            using CRng = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::split_when_view::cursor	typeref:typename:meta::const_if_c<IsConst,Rng>
CRng	include/range/v3/view/stride.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	function:ranges::stride_view::can_bound	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/stride.hpp	/^            using CRng = meta::const_if_c<Const, Rng>;$/;"	t	struct:ranges::stride_view::adaptor	typeref:typename:meta::const_if_c<Const,Rng>
CRng	include/range/v3/view/take_while.hpp	/^            using CRng = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::iter_take_while_view::sentinel_adaptor	typeref:typename:meta::const_if_c<IsConst,Rng>
CRng	include/range/v3/view/transform.hpp	/^            using CRng = meta::const_if_c<IsConst, Rng>;$/;"	t	struct:ranges::iter_transform_view::adaptor	typeref:typename:meta::const_if_c<IsConst,Rng>
CommitId	include/git.hpp	/^using CommitId = nt::NamedType<std::string, struct CommIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct CommIdTag>
Comparable	include/ntskills.hpp	/^template <typename T> struct Comparable : crtp<T, Comparable> {$/;"	s	namespace:nt
Current	include/range/v3/view/split.hpp	/^            using Current = split_outer_iterator_base<iterator_t<Base>>;$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:split_outer_iterator_base<iterator_t<Base>>
D	include/git.hpp	/^  using D = void (*)(T *);$/;"	t	struct:git::make
D	include/range/v3/algorithm/inplace_merge.hpp	/^                using D = iter_difference_t<I>;$/;"	t	function:ranges::detail::merge_adaptive_fn::operator ()	typeref:typename:iter_difference_t<I>
D	include/range/v3/algorithm/stable_sort.hpp	/^            using D = iter_difference_t<I>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:iter_difference_t<I>
D	include/range/v3/range/operations.hpp	/^            using D = range_difference_t<Rng>;$/;"	t	function:ranges::index_fn::operator ()	typeref:typename:range_difference_t<Rng>
D	include/range/v3/view/cartesian_product.hpp	/^                using D = iter_difference_t<decltype(first)>;$/;"	t	function:ranges::cartesian_product_view::cursor::advance_
D	include/range/v3/view/cycle.hpp	/^                using D = range_difference_t<Rng>;$/;"	t	function:ranges::cycled_view::cursor::CPP_template	typeref:typename:range_difference_t<Rng>
D	include/range/v3/view/enumerate.hpp	/^                using D = range_difference_t<Rng>;$/;"	t	function:ranges::views::enumerate_fn::CPP_fun	typeref:typename:range_difference_t<Rng>
D	include/range/v3/view/interface.hpp	/^        using D = meta::invoke<detail::dependent_<B>, Derived>;$/;"	t	struct:ranges::view_interface	typeref:typename:meta::invoke<detail::dependent_<B>,Derived>
D	include/range/v3/view/iota.hpp	/^                using D = difference_type;$/;"	t	function:ranges::closed_iota_view::cursor::distance_to	typeref:typename:difference_type
D	include/range/v3/view/sample.hpp	/^        using D = range_difference_t<Rng>;$/;"	t	class:ranges::sample_view	typeref:typename:range_difference_t<Rng>
D	include/range/v3/view/subrange.hpp	/^                using D = iter_difference_t<I>;$/;"	t	function:ranges::subrange::CPP_ctor	typeref:typename:iter_difference_t<I>
D1	include/range/v3/algorithm/shuffle.hpp	/^            using D1 = iter_difference_t<I>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:iter_difference_t<I>
D2	include/range/v3/algorithm/shuffle.hpp	/^            using D2 = detail::if_then_t<std::is_integral<D1>::value, D1, std::ptrdiff_t>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:detail::if_then_t<std::is_integral<D1>::value,D1,std::ptrdiff_t>
Dist	include/range/v3/view/sample.hpp	/^                    using Dist = std::uniform_int_distribution<D>;$/;"	t	function:ranges::sample_view::cursor::advance	typeref:typename:std::uniform_int_distribution<D>
Entry	include/git.hpp	/^using Entry =$/;"	t	namespace:git	typeref:typename:std::tuple<Name,std::variant<TreeId,BlobId,ExecId,LinkId,CommitId>>
ExecId	include/git.hpp	/^using ExecId = nt::NamedType<std::string, struct ExecIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct ExecIdTag>
F	include/range/v3/view/partial_sum.hpp	/^                    using F = meta::const_if_c<IsConst, Fun>;$/;"	t	function:ranges::partial_sum_view::cursor::next	typeref:typename:meta::const_if_c<IsConst,Fun>
FIRST	include/range/v3/view/set_algorithm.hpp	/^                FIRST,$/;"	e	enum:ranges::detail::set_symmetric_difference_cursor::state_t
FIRST	include/range/v3/view/set_algorithm.hpp	/^                FIRST,$/;"	e	enum:ranges::detail::set_union_cursor::state_t
FLUENT_EBCO	include/nt.hpp	/^#define FLUENT_EBCO /;"	d
FLUENT_EBCO	include/nt.hpp	/^#define FLUENT_EBCO$/;"	d
From	include/range/v3/detail/variant.hpp	/^        using From = variant<Ts...>;$/;"	t	function:ranges::unique_variant	typeref:typename:variant<Ts...>
GIT_H	include/git.hpp	/^#define GIT_H /;"	d
Hashable	include/ntskills.hpp	/^template <typename T> struct Hashable {$/;"	s	namespace:nt
Head	include/range/v3/detail/variant.hpp	/^            using Head = typename Data0::head_t;$/;"	t	function:ranges::detail::variant_move_copy_	typeref:typename:Data0::head_t
I	include/range/v3/action/stride.hpp	/^                using I = iterator_t<Rng>;$/;"	t	function:ranges::actions::stride_fn::operator ()	typeref:typename:iterator_t<Rng>
I	include/range/v3/range/conversion.hpp	/^            using I = range_cpp17_iterator_t<Rng>;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:range_cpp17_iterator_t<Rng>
I	include/range/v3/view/chunk.hpp	/^            using I = iterator_t<meta::const_if_c<Const, Rng>>;$/;"	t	function:ranges::detail::can_sized_sentinel_	typeref:typename:iterator_t<meta::const_if_c<Const,Rng>>
INIT_A	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t INIT_A = 0x43b0d7e5;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
INIT_B	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t INIT_B = 0x8b51f9dd;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
ImplicitlyConvertibleTo	include/ntskills.hpp	/^template <typename Destination> struct ImplicitlyConvertibleTo {$/;"	s	namespace:nt
Incrementable	include/ntskills.hpp	/^template <typename T> struct Incrementable : crtp<T, Incrementable> {$/;"	s	namespace:nt
Inner	include/range/v3/view/join.hpp	/^        using Inner = views::all_t<range_reference_t<Outer>>;$/;"	t	struct:ranges::join_with_view	typeref:typename:views::all_t<range_reference_t<Outer>>
IsConst	include/range/v3/view/cartesian_product.hpp	/^            using IsConst = meta::bool_<IsConst_>;$/;"	t	struct:ranges::cartesian_product_view::cursor	typeref:typename:meta::bool_<IsConst_>
IsNotReference	include/nt.hpp	/^using IsNotReference =$/;"	t	namespace:nt	typeref:typename:std::enable_if<!std::is_reference<T> void>::type
It	include/range/v3/view/split.hpp	/^        using split_view_base = meta::invoke<here_or_there_<!forward_iterator<It>>, It>;$/;"	t	namespace:ranges::detail	typeref:typename:meta::invoke<here_or_there_<!forward_iterator<>>
L	include/lr.hpp	/^struct L {$/;"	s	namespace:lr
LOGICAL_OP	include/range/v3/utility/common_tuple.hpp	/^#define LOGICAL_OP(/;"	d
LR	include/git.hpp	/^template <typename R> using LR = lr::LR<R>;$/;"	t	namespace:git	typeref:typename:lr::LR<R>
LR	include/lr.hpp	/^template <typename... Rights> using LR = std::variant<L, Rights...>;$/;"	t	namespace:lr	typeref:typename:std::variant<L,Rights...>
LR_H	include/lr.hpp	/^#define LR_H /;"	d
Limits	include/range/v3/view/chunk.hpp	/^                using Limits = std::numeric_limits<range_difference_t<CRng>>;$/;"	t	function:ranges::chunk_view_::adaptor::advance	typeref:typename:std::numeric_limits<range_difference_t<CRng>>
LinkId	include/git.hpp	/^using LinkId = nt::NamedType<std::string, struct LinkIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct LinkIdTag>
META_BEGIN_NAMESPACE_CONTAINER	include/meta/meta_fwd.hpp	/^#define META_BEGIN_NAMESPACE_CONTAINER /;"	d
META_BEGIN_NAMESPACE_CONTAINER	include/meta/meta_fwd.hpp	/^#define META_BEGIN_NAMESPACE_CONTAINER$/;"	d
META_BEGIN_NAMESPACE_STD	include/meta/meta_fwd.hpp	/^#define META_BEGIN_NAMESPACE_STD /;"	d
META_BEGIN_NAMESPACE_VERSION	include/meta/meta_fwd.hpp	/^#define META_BEGIN_NAMESPACE_VERSION /;"	d
META_BEGIN_NAMESPACE_VERSION	include/meta/meta_fwd.hpp	/^#define META_BEGIN_NAMESPACE_VERSION$/;"	d
META_CONCEPT	include/meta/meta_fwd.hpp	/^#define META_CONCEPT /;"	d
META_CONCEPT_BARRIER	include/meta/meta_fwd.hpp	/^#define META_CONCEPT_BARRIER(/;"	d
META_CXX_FOLD_EXPRESSIONS	include/meta/meta_fwd.hpp	/^#define META_CXX_FOLD_EXPRESSIONS /;"	d
META_CXX_INLINE_VARIABLES	include/meta/meta_fwd.hpp	/^#define META_CXX_INLINE_VARIABLES /;"	d
META_CXX_INTEGER_SEQUENCE	include/meta/meta_fwd.hpp	/^#define META_CXX_INTEGER_SEQUENCE /;"	d
META_CXX_STD_14	include/meta/meta_fwd.hpp	/^#define META_CXX_STD_14 /;"	d
META_CXX_STD_17	include/meta/meta_fwd.hpp	/^#define META_CXX_STD_17 /;"	d
META_CXX_TRAIT_VARIABLE_TEMPLATES	include/meta/meta_fwd.hpp	/^#define META_CXX_TRAIT_VARIABLE_TEMPLATES /;"	d
META_CXX_VARIABLE_TEMPLATES	include/meta/meta_fwd.hpp	/^#define META_CXX_VARIABLE_TEMPLATES /;"	d
META_CXX_VER	include/meta/meta_fwd.hpp	/^#define META_CXX_VER /;"	d
META_DEPRECATED	include/meta/meta_fwd.hpp	/^#define META_DEPRECATED(/;"	d
META_END_NAMESPACE_CONTAINER	include/meta/meta_fwd.hpp	/^#define META_END_NAMESPACE_CONTAINER /;"	d
META_END_NAMESPACE_CONTAINER	include/meta/meta_fwd.hpp	/^#define META_END_NAMESPACE_CONTAINER$/;"	d
META_END_NAMESPACE_STD	include/meta/meta_fwd.hpp	/^#define META_END_NAMESPACE_STD /;"	d
META_END_NAMESPACE_VERSION	include/meta/meta_fwd.hpp	/^#define META_END_NAMESPACE_VERSION /;"	d
META_END_NAMESPACE_VERSION	include/meta/meta_fwd.hpp	/^#define META_END_NAMESPACE_VERSION$/;"	d
META_FWD_HPP	include/meta/meta_fwd.hpp	/^#define META_FWD_HPP$/;"	d
META_HAS_MAKE_INTEGER_SEQ	include/meta/meta_fwd.hpp	/^#define META_HAS_MAKE_INTEGER_SEQ /;"	d
META_HAS_TYPE_PACK_ELEMENT	include/meta/meta_fwd.hpp	/^#define META_HAS_TYPE_PACK_ELEMENT /;"	d
META_HPP	include/meta/meta.hpp	/^#define META_HPP$/;"	d
META_INLINE_VAR	include/meta/meta_fwd.hpp	/^#define META_INLINE_VAR /;"	d
META_INLINE_VAR	include/meta/meta_fwd.hpp	/^#define META_INLINE_VAR$/;"	d
META_IS_BASE_OF	include/meta/meta_fwd.hpp	/^#define META_IS_BASE_OF(/;"	d
META_IS_CONSTRUCTIBLE	include/meta/meta_fwd.hpp	/^#define META_IS_CONSTRUCTIBLE(/;"	d
META_IS_SAME	include/meta/meta_fwd.hpp	/^#define META_IS_SAME(/;"	d
META_TEMPLATE_VIS	include/meta/meta_fwd.hpp	/^#define META_TEMPLATE_VIS /;"	d
META_TEMPLATE_VIS	include/meta/meta_fwd.hpp	/^#define META_TEMPLATE_VIS$/;"	d
META_TYPE_CONSTRAINT	include/meta/meta_fwd.hpp	/^#define META_TYPE_CONSTRAINT(/;"	d
META_WORKAROUND_CWG_1558	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_CWG_1558 /;"	d
META_WORKAROUND_GCC_66405	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_GCC_66405 /;"	d
META_WORKAROUND_GCC_86356	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_GCC_86356 /;"	d
META_WORKAROUND_GCC_UNKNOWN1	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_GCC_UNKNOWN1 /;"	d
META_WORKAROUND_LLVM_28385	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_LLVM_28385 /;"	d
META_WORKAROUND_MSVC_702792	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_MSVC_702792 /;"	d
META_WORKAROUND_MSVC_703656	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_MSVC_703656 /;"	d
META_WORKAROUND_MSVC_756112	include/meta/meta_fwd.hpp	/^#define META_WORKAROUND_MSVC_756112 /;"	d
MIX_MULT_L	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t MIX_MULT_L = 0xca01f9dd;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
MIX_MULT_R	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t MIX_MULT_R = 0x4973f715;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
MULT_A	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t MULT_A = 0x931e8875;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
MULT_B	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t MULT_B = 0x58f38ded;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
Multiplicable	include/ntskills.hpp	/^template <typename T> struct Multiplicable : crtp<T, Multiplicable> {$/;"	s	namespace:nt
Name	include/git.hpp	/^using Name = nt::NamedType<std::string, struct NameTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct NameTag>
NamedType	include/nt.hpp	/^  explicit constexpr NamedType(T &&value) : value_(std::move(value)) {}$/;"	f	class:nt::NamedType
NamedType	include/nt.hpp	/^  explicit constexpr NamedType(T const &value) : value_(value) {}$/;"	f	class:nt::NamedType
NamedType	include/nt.hpp	/^class FLUENT_EBCO NamedType$/;"	c	namespace:nt
Negatable	include/ntskills.hpp	/^template <typename T> struct Negatable : crtp<T, Negatable> {$/;"	s	namespace:nt
NewType	include/newtype.hpp	/^#define NewType(/;"	d
Nil	include/concepts/concepts.hpp	/^        struct Nil$/;"	s	namespace:concepts::detail
O	include/git.hpp	/^  struct O {$/;"	s	struct:git::TreeBark
O	include/git_.hpp	/^struct O {};$/;"	s	namespace:abo
ONLY_FIRST	include/range/v3/view/set_algorithm.hpp	/^                ONLY_FIRST,$/;"	e	enum:ranges::detail::set_symmetric_difference_cursor::state_t
ONLY_SECOND	include/range/v3/view/set_algorithm.hpp	/^                ONLY_SECOND$/;"	e	enum:ranges::detail::set_symmetric_difference_cursor::state_t
OVERLOADED_H	include/overloaded.hpp	/^#define OVERLOADED_H /;"	d
Outer	include/range/v3/view/join.hpp	/^        using Outer = views::all_t<Rng>;$/;"	t	struct:ranges::join_with_view	typeref:typename:views::all_t<Rng>
Outer	include/range/v3/view/split.hpp	/^            using Outer = split_outer_iterator<split_view<V, Pattern>, Const>;$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:split_outer_iterator<split_view<V,Pattern>,Const>
Parent	include/range/v3/view/adjacent_filter.hpp	/^            using Parent = meta::const_if_c<Const, adjacent_filter_view>;$/;"	t	struct:ranges::adjacent_filter_view::adaptor	typeref:typename:meta::const_if_c<Const,adjacent_filter_view>
Parent	include/range/v3/view/join.hpp	/^            using Parent = detail::if_then_t<Const, join_view const, join_view>;$/;"	t	struct:ranges::join_view::cursor	typeref:typename:detail::if_then_t<Const,join_view const,join_view>
Parent	include/range/v3/view/partial_sum.hpp	/^            using Parent = meta::const_if_c<IsConst, partial_sum_view>;$/;"	t	struct:ranges::partial_sum_view::cursor	typeref:typename:meta::const_if_c<IsConst,partial_sum_view>
Parent	include/range/v3/view/split.hpp	/^            using Parent = meta::const_if_c<Const, split_view<V, Pattern>>;$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:meta::const_if_c<Const,split_view<V,Pattern>>
PreIncrementable	include/ntskills.hpp	/^template <typename T> struct PreIncrementable : crtp<T, PreIncrementable> {$/;"	s	namespace:nt
Printable	include/ntskills.hpp	/^template <typename T> struct Printable : crtp<T, Printable> {$/;"	s	namespace:nt
R	include/range/v3/algorithm/minmax.hpp	/^            using R = minmax_result<T const &>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:minmax_result<T const &>
R	include/range/v3/algorithm/minmax.hpp	/^            using R = minmax_result<range_value_t<Rng>>;$/;"	t	function:ranges::RANGES_FUNC	typeref:typename:minmax_result<range_value_t<Rng>>
R	include/range/v3/view/adaptor.hpp	/^            using R = decltype(this->data_.second().read(this->data_.first()));$/;"	t	function:ranges::adaptor_cursor::iter_move_
R1	include/range/v3/iterator/basic_iterator.hpp	/^            using R1 = reference_t_;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:reference_t_
R1	include/range/v3/view/set_algorithm.hpp	/^            using R1 = constify_if<Rng1>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:constify_if<Rng1>
R1	include/range/v3/view/set_algorithm.hpp	/^            using R1 = constify_if<Rng1>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:constify_if<Rng1>
R1	include/range/v3/view/set_algorithm.hpp	/^            using R1 = constify_if<Rng1>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:constify_if<Rng1>
R1	include/range/v3/view/set_algorithm.hpp	/^            using R1 = constify_if<Rng1>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:constify_if<Rng1>
R1	include/range/v3/view/transform.hpp	/^            using R1 = meta::const_if_c<Const, Rng1>;$/;"	t	struct:ranges::iter_transform2_view::cursor	typeref:typename:meta::const_if_c<Const,Rng1>
R1	include/range/v3/view/transform.hpp	/^        using R1 = meta::invoke<detail::dependent_<B>, Rng1>;$/;"	t	struct:ranges::iter_transform2_view	typeref:typename:meta::invoke<detail::dependent_<B>,Rng1>
R2	include/range/v3/iterator/basic_iterator.hpp	/^            using R2 = common_reference_t<reference_t_, value_t_ &>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:common_reference_t<reference_t_,value_t_ &>
R2	include/range/v3/view/set_algorithm.hpp	/^            using R2 = constify_if<Rng2>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:constify_if<Rng2>
R2	include/range/v3/view/set_algorithm.hpp	/^            using R2 = constify_if<Rng2>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:constify_if<Rng2>
R2	include/range/v3/view/set_algorithm.hpp	/^            using R2 = constify_if<Rng2>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:constify_if<Rng2>
R2	include/range/v3/view/set_algorithm.hpp	/^            using R2 = constify_if<Rng2>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:constify_if<Rng2>
R2	include/range/v3/view/transform.hpp	/^            using R2 = meta::const_if_c<Const, Rng2>;$/;"	t	struct:ranges::iter_transform2_view::cursor	typeref:typename:meta::const_if_c<Const,Rng2>
R2	include/range/v3/view/transform.hpp	/^        using R2 = meta::invoke<detail::dependent_<B>, Rng2>;$/;"	t	struct:ranges::iter_transform2_view	typeref:typename:meta::invoke<detail::dependent_<B>,Rng2>
R3	include/range/v3/iterator/basic_iterator.hpp	/^            using R3 = common_reference_t<reference_t_, rvalue_reference_t_>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:common_reference_t<reference_t_,rvalue_reference_t_>
RANGES_ALGO_RESULT_AUX_2	include/range/v3/algorithm/result_types.hpp	/^#define RANGES_ALGO_RESULT_AUX_2(/;"	d
RANGES_ALGO_RESULT_AUX_3	include/range/v3/algorithm/result_types.hpp	/^#define RANGES_ALGO_RESULT_AUX_3(/;"	d
RANGES_ASSERT	include/range/v3/detail/config.hpp	/^#define RANGES_ASSERT /;"	d
RANGES_ASSERT	include/range/v3/detail/config.hpp	/^#define RANGES_ASSERT(/;"	d
RANGES_ASSUME	include/range/v3/detail/config.hpp	/^#define RANGES_ASSUME(/;"	d
RANGES_AUTO_RETURN_NOEXCEPT	include/range/v3/detail/config.hpp	/^#define RANGES_AUTO_RETURN_NOEXCEPT(/;"	d
RANGES_BEGIN_NAMESPACE_CONTAINER	include/range/v3/detail/config.hpp	/^#define RANGES_BEGIN_NAMESPACE_CONTAINER /;"	d
RANGES_BEGIN_NAMESPACE_STD	include/range/v3/detail/config.hpp	/^#define RANGES_BEGIN_NAMESPACE_STD /;"	d
RANGES_BEGIN_NAMESPACE_VERSION	include/range/v3/detail/config.hpp	/^#define RANGES_BEGIN_NAMESPACE_VERSION /;"	d
RANGES_BROKEN_CPO_LOOKUP	include/range/v3/detail/config.hpp	/^#define RANGES_BROKEN_CPO_LOOKUP /;"	d
RANGES_CONSTEXPR_IF	include/range/v3/detail/config.hpp	/^#define RANGES_CONSTEXPR_IF(/;"	d
RANGES_CONSTEXPR_INVOKE	include/range/v3/functional/invoke.hpp	/^#define RANGES_CONSTEXPR_INVOKE /;"	d
RANGES_CXX14_CONSTEXPR	include/range/v3/detail/config.hpp	/^#define RANGES_CXX14_CONSTEXPR /;"	d
RANGES_CXX_ALIGNED_NEW	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ALIGNED_NEW /;"	d
RANGES_CXX_ALIGNED_NEW_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ALIGNED_NEW_11 /;"	d
RANGES_CXX_ALIGNED_NEW_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ALIGNED_NEW_14 /;"	d
RANGES_CXX_ALIGNED_NEW_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ALIGNED_NEW_17 /;"	d
RANGES_CXX_ATTRIBUTE_DEPRECATED	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ATTRIBUTE_DEPRECATED /;"	d
RANGES_CXX_ATTRIBUTE_DEPRECATED_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ATTRIBUTE_DEPRECATED_11 /;"	d
RANGES_CXX_ATTRIBUTE_DEPRECATED_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ATTRIBUTE_DEPRECATED_14 /;"	d
RANGES_CXX_ATTRIBUTE_DEPRECATED_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_ATTRIBUTE_DEPRECATED_17 /;"	d
RANGES_CXX_CONSTEXPR	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_CONSTEXPR /;"	d
RANGES_CXX_CONSTEXPR_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_CONSTEXPR_11 /;"	d
RANGES_CXX_CONSTEXPR_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_CONSTEXPR_14 /;"	d
RANGES_CXX_CONSTEXPR_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_CONSTEXPR_17 /;"	d
RANGES_CXX_CONSTEXPR_LAMBDAS	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_CONSTEXPR_LAMBDAS /;"	d
RANGES_CXX_COROUTINES	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_COROUTINES /;"	d
RANGES_CXX_COROUTINES_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_COROUTINES_11 /;"	d
RANGES_CXX_COROUTINES_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_COROUTINES_14 /;"	d
RANGES_CXX_COROUTINES_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_COROUTINES_17 /;"	d
RANGES_CXX_COROUTINES_TS1	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_COROUTINES_TS1 /;"	d
RANGES_CXX_DEDUCTION_GUIDES	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_DEDUCTION_GUIDES /;"	d
RANGES_CXX_DEDUCTION_GUIDES_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_DEDUCTION_GUIDES_11 /;"	d
RANGES_CXX_DEDUCTION_GUIDES_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_DEDUCTION_GUIDES_14 /;"	d
RANGES_CXX_DEDUCTION_GUIDES_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_DEDUCTION_GUIDES_17 /;"	d
RANGES_CXX_FEATURE	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_FEATURE(/;"	d
RANGES_CXX_FEATURE_CONCAT	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_FEATURE_CONCAT(/;"	d
RANGES_CXX_FEATURE_CONCAT2	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_FEATURE_CONCAT2(/;"	d
RANGES_CXX_GENERIC_LAMBDAS	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_GENERIC_LAMBDAS /;"	d
RANGES_CXX_GENERIC_LAMBDAS_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_GENERIC_LAMBDAS_11 /;"	d
RANGES_CXX_GENERIC_LAMBDAS_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_GENERIC_LAMBDAS_14 /;"	d
RANGES_CXX_GENERIC_LAMBDAS_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_GENERIC_LAMBDAS_17 /;"	d
RANGES_CXX_IF_CONSTEXPR	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_IF_CONSTEXPR /;"	d
RANGES_CXX_IF_CONSTEXPR_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_IF_CONSTEXPR_11 /;"	d
RANGES_CXX_IF_CONSTEXPR_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_IF_CONSTEXPR_14 /;"	d
RANGES_CXX_IF_CONSTEXPR_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_IF_CONSTEXPR_17 /;"	d
RANGES_CXX_INLINE_VARIABLES	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_INLINE_VARIABLES /;"	d
RANGES_CXX_INLINE_VARIABLES_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_INLINE_VARIABLES_11 /;"	d
RANGES_CXX_INLINE_VARIABLES_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_INLINE_VARIABLES_14 /;"	d
RANGES_CXX_INLINE_VARIABLES_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_INLINE_VARIABLES_17 /;"	d
RANGES_CXX_LIB_IS_FINAL	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_LIB_IS_FINAL /;"	d
RANGES_CXX_LIB_IS_FINAL_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_LIB_IS_FINAL_11 /;"	d
RANGES_CXX_LIB_IS_FINAL_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_LIB_IS_FINAL_14 /;"	d
RANGES_CXX_LIB_IS_FINAL_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_LIB_IS_FINAL_17 /;"	d
RANGES_CXX_RANGE_BASED_FOR	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RANGE_BASED_FOR /;"	d
RANGES_CXX_RANGE_BASED_FOR_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RANGE_BASED_FOR_11 /;"	d
RANGES_CXX_RANGE_BASED_FOR_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RANGE_BASED_FOR_14 /;"	d
RANGES_CXX_RANGE_BASED_FOR_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RANGE_BASED_FOR_17 /;"	d
RANGES_CXX_RETURN_TYPE_DEDUCTION	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RETURN_TYPE_DEDUCTION /;"	d
RANGES_CXX_RETURN_TYPE_DEDUCTION_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RETURN_TYPE_DEDUCTION_11 /;"	d
RANGES_CXX_RETURN_TYPE_DEDUCTION_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RETURN_TYPE_DEDUCTION_14 /;"	d
RANGES_CXX_RETURN_TYPE_DEDUCTION_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_RETURN_TYPE_DEDUCTION_17 /;"	d
RANGES_CXX_STATIC_ASSERT	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STATIC_ASSERT /;"	d
RANGES_CXX_STATIC_ASSERT_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STATIC_ASSERT_11 /;"	d
RANGES_CXX_STATIC_ASSERT_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STATIC_ASSERT_14 /;"	d
RANGES_CXX_STATIC_ASSERT_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STATIC_ASSERT_17 /;"	d
RANGES_CXX_STD	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STD /;"	d
RANGES_CXX_STD_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STD_11 /;"	d
RANGES_CXX_STD_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STD_14 /;"	d
RANGES_CXX_STD_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_STD_17 /;"	d
RANGES_CXX_THIRD_ARG_	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_THIRD_ARG_(/;"	d
RANGES_CXX_THREAD_LOCAL	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_THREAD_LOCAL /;"	d
RANGES_CXX_THREAD_LOCAL_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_THREAD_LOCAL_11 /;"	d
RANGES_CXX_THREAD_LOCAL_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_THREAD_LOCAL_14 /;"	d
RANGES_CXX_THREAD_LOCAL_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_THREAD_LOCAL_17 /;"	d
RANGES_CXX_THREAD_LOCAL_PRE_STANDARD	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_THREAD_LOCAL_PRE_STANDARD /;"	d
RANGES_CXX_TRAIT_VARIABLE_TEMPLATES	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_TRAIT_VARIABLE_TEMPLATES /;"	d
RANGES_CXX_VARIABLE_TEMPLATES	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VARIABLE_TEMPLATES /;"	d
RANGES_CXX_VARIABLE_TEMPLATES_11	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VARIABLE_TEMPLATES_11 /;"	d
RANGES_CXX_VARIABLE_TEMPLATES_14	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VARIABLE_TEMPLATES_14 /;"	d
RANGES_CXX_VARIABLE_TEMPLATES_17	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VARIABLE_TEMPLATES_17 /;"	d
RANGES_CXX_VA_OPT	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VA_OPT /;"	d
RANGES_CXX_VA_OPT_I_	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VA_OPT_I_(/;"	d
RANGES_CXX_VER	include/range/v3/detail/config.hpp	/^#define RANGES_CXX_VER /;"	d
RANGES_DECLTYPE_AUTO_RETURN	include/range/v3/detail/config.hpp	/^#define RANGES_DECLTYPE_AUTO_RETURN(/;"	d
RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT	include/range/v3/detail/config.hpp	/^#define RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(/;"	d
RANGES_DECLTYPE_NOEXCEPT	include/range/v3/detail/config.hpp	/^#define RANGES_DECLTYPE_NOEXCEPT(/;"	d
RANGES_DEFINE_CPO	include/range/v3/detail/config.hpp	/^#define RANGES_DEFINE_CPO(/;"	d
RANGES_DEFINE_TAG_SPECIFIER	include/range/v3/utility/tagged_pair.hpp	/^#define RANGES_DEFINE_TAG_SPECIFIER(/;"	d
RANGES_DEPRECATED	include/range/v3/detail/config.hpp	/^#define RANGES_DEPRECATED(/;"	d
RANGES_DEPRECATED	include/range/v3/utility/any.hpp	/^    struct RANGES_DEPRECATED($/;"	v	namespace:ranges	typeref:typename:struct
RANGES_DEPRECATED_HEADER	include/range/v3/detail/config.hpp	/^#define RANGES_DEPRECATED_HEADER(/;"	d
RANGES_DIAGNOSTIC_IGNORE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE(/;"	d
RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT /;"	d
RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT$/;"	d
RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS /;"	d
RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_DECLARATIONS$/;"	d
RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE /;"	d
RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_DEPRECATED_THIS_CAPTURE$/;"	d
RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO /;"	d
RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO$/;"	d
RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL /;"	d
RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL$/;"	d
RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS /;"	d
RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS$/;"	d
RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE /;"	d
RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_INCONSISTENT_OVERRIDE$/;"	d
RANGES_DIAGNOSTIC_IGNORE_INDENTATION	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION /;"	d
RANGES_DIAGNOSTIC_IGNORE_INDENTATION	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION$/;"	d
RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME /;"	d
RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_INIT_LIST_LIFETIME$/;"	d
RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS /;"	d
RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS$/;"	d
RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES /;"	d
RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_MISSING_BRACES$/;"	d
RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS /;"	d
RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_MULTIPLE_ASSIGNMENT_OPERATORS$/;"	d
RANGES_DIAGNOSTIC_IGNORE_PRAGMAS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS /;"	d
RANGES_DIAGNOSTIC_IGNORE_PRAGMAS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS$/;"	d
RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS /;"	d
RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_RANGE_LOOP_ANALYSIS$/;"	d
RANGES_DIAGNOSTIC_IGNORE_SHADOWING	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING /;"	d
RANGES_DIAGNOSTIC_IGNORE_SHADOWING	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING$/;"	d
RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION /;"	d
RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION$/;"	d
RANGES_DIAGNOSTIC_IGNORE_TRUNCATION	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_TRUNCATION /;"	d
RANGES_DIAGNOSTIC_IGNORE_TRUNCATION	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_TRUNCATION$/;"	d
RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE /;"	d
RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_FUNC_TEMPLATE$/;"	d
RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL /;"	d
RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL$/;"	d
RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL /;"	d
RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL$/;"	d
RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER /;"	d
RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER$/;"	d
RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH /;"	d
RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_UNSIGNED_MATH$/;"	d
RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY /;"	d
RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY$/;"	d
RANGES_DIAGNOSTIC_POP	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_POP /;"	d
RANGES_DIAGNOSTIC_POP	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_POP$/;"	d
RANGES_DIAGNOSTIC_PUSH	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_PUSH /;"	d
RANGES_DIAGNOSTIC_PUSH	include/range/v3/detail/config.hpp	/^#define RANGES_DIAGNOSTIC_PUSH$/;"	d
RANGES_DISABLE_WARNINGS	include/range/v3/detail/config.hpp	/^#define RANGES_DISABLE_WARNINGS /;"	d
RANGES_DISABLE_WARNINGS	include/range/v3/detail/config.hpp	/^#define RANGES_DISABLE_WARNINGS$/;"	d
RANGES_EMPLACED_INDEX_T	include/range/v3/detail/variant.hpp	/^#define RANGES_EMPLACED_INDEX_T(/;"	d
RANGES_EMPTY_BASES	include/range/v3/detail/config.hpp	/^#define RANGES_EMPTY_BASES /;"	d
RANGES_EMPTY_BASES	include/range/v3/detail/config.hpp	/^#define RANGES_EMPTY_BASES$/;"	d
RANGES_END_NAMESPACE_CONTAINER	include/range/v3/detail/config.hpp	/^#define RANGES_END_NAMESPACE_CONTAINER /;"	d
RANGES_END_NAMESPACE_STD	include/range/v3/detail/config.hpp	/^#define RANGES_END_NAMESPACE_STD /;"	d
RANGES_END_NAMESPACE_VERSION	include/range/v3/detail/config.hpp	/^#define RANGES_END_NAMESPACE_VERSION /;"	d
RANGES_ENSURE	include/range/v3/detail/config.hpp	/^#define RANGES_ENSURE(/;"	d
RANGES_ENSURE_MSG	include/range/v3/detail/config.hpp	/^#define RANGES_ENSURE_MSG(/;"	d
RANGES_EXPECT	include/range/v3/detail/config.hpp	/^#define RANGES_EXPECT(/;"	d
RANGES_FOR	include/range/v3/range_for.hpp	/^#define RANGES_FOR(/;"	d
RANGES_FUNC	include/range/v3/algorithm/adjacent_find.hpp	/^        auto RANGES_FUNC(adjacent_find)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/adjacent_remove_if.hpp	/^        auto RANGES_FUNC(adjacent_remove_if)(Rng && rng, Pred pred, Proj proj = {}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/all_of.hpp	/^        auto RANGES_FUNC(all_of)(Rng && rng, F pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/any_of.hpp	/^        auto RANGES_FUNC(any_of)(Rng && rng, F pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/binary_search.hpp	/^        auto RANGES_FUNC(binary_search)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/copy.hpp	/^        constexpr auto RANGES_FUNC(copy)(Rng && rng, O out)  \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/copy_backward.hpp	/^        auto RANGES_FUNC(copy_backward)(Rng && rng, O out)$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/copy_if.hpp	/^        auto RANGES_FUNC(copy_if)(Rng && rng, O out, F pred, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/count.hpp	/^        auto RANGES_FUNC(count)(Rng && rng, V const & val, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/count_if.hpp	/^        auto RANGES_FUNC(count_if)(Rng && rng, R pred, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/ends_with.hpp	/^        constexpr auto RANGES_FUNC(ends_with)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/equal.hpp	/^        constexpr auto RANGES_FUNC(equal)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/equal.hpp	/^        constexpr auto RANGES_FUNC(equal)(I0 begin0,$/;"	f	namespace:ranges
RANGES_FUNC	include/range/v3/algorithm/equal.hpp	/^        constexpr auto RANGES_FUNC(equal)(I0 begin0,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/equal.hpp	/^        constexpr auto RANGES_FUNC(equal)(Rng0 && rng0,$/;"	f	namespace:ranges	typeref:typename:RANGES_DEPRECATED ("Use the variant of ranges::equal that takes an upper bound for ""both sequences")auto
RANGES_FUNC	include/range/v3/algorithm/equal_range.hpp	/^        auto RANGES_FUNC(equal_range)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/fill.hpp	/^        auto RANGES_FUNC(fill)(Rng && rng, V const & val)$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/find.hpp	/^        auto RANGES_FUNC(find)(Rng && rng, V const & val, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/find_end.hpp	/^        auto RANGES_FUNC(find_end)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/find_first_of.hpp	/^        constexpr auto RANGES_FUNC(find_first_of)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/find_if.hpp	/^        auto RANGES_FUNC(find_if)(Rng && rng, F pred, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/find_if_not.hpp	/^        auto RANGES_FUNC(find_if_not)(Rng && rng, F pred, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/for_each.hpp	/^        auto RANGES_FUNC(for_each)(Rng && rng, F fun, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/for_each_n.hpp	/^        auto RANGES_FUNC(for_each_n)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/generate.hpp	/^        auto RANGES_FUNC(generate)(Rng && rng, F fun)$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/heap_algorithm.hpp	/^        auto RANGES_FUNC(is_heap)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/heap_algorithm.hpp	/^        auto RANGES_FUNC(is_heap_until)(Rng && rng, C pred = C{}, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/heap_algorithm.hpp	/^        auto RANGES_FUNC(make_heap)(Rng && rng, C pred = C{}, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/heap_algorithm.hpp	/^        auto RANGES_FUNC(pop_heap)(Rng && rng, C pred = C{}, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/heap_algorithm.hpp	/^        auto RANGES_FUNC(push_heap)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/heap_algorithm.hpp	/^        auto RANGES_FUNC(sort_heap)(Rng && rng, C pred = C{}, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/inplace_merge.hpp	/^        auto RANGES_FUNC(inplace_merge)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/is_partitioned.hpp	/^        auto RANGES_FUNC(is_partitioned)(Rng && rng, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/is_sorted.hpp	/^        auto RANGES_FUNC(is_sorted)(Rng && rng, R rel = R{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/is_sorted_until.hpp	/^        auto RANGES_FUNC(is_sorted_until)(Rng && rng, R pred = R{}, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/lexicographical_compare.hpp	/^        auto RANGES_FUNC(lexicographical_compare)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/lower_bound.hpp	/^        auto RANGES_FUNC(lower_bound)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/max.hpp	/^        constexpr auto RANGES_FUNC(max)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/max.hpp	/^        constexpr auto RANGES_FUNC(max)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/max_element.hpp	/^        auto RANGES_FUNC(max_element)(Rng && rng, C pred = C{}, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/merge.hpp	/^        auto RANGES_FUNC(merge)(Rng0 && rng0,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/min.hpp	/^        constexpr auto RANGES_FUNC(min)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/min.hpp	/^        constexpr auto RANGES_FUNC(min)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/min_element.hpp	/^        auto RANGES_FUNC(min_element)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/minmax.hpp	/^        constexpr auto RANGES_FUNC(minmax)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/minmax.hpp	/^        constexpr auto RANGES_FUNC(minmax)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/minmax_element.hpp	/^        auto RANGES_FUNC(minmax_element)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/mismatch.hpp	/^        auto RANGES_FUNC(mismatch)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/mismatch.hpp	/^        auto RANGES_FUNC(mismatch)(I1 begin1,$/;"	f	namespace:ranges
RANGES_FUNC	include/range/v3/algorithm/mismatch.hpp	/^        auto RANGES_FUNC(mismatch)(I1 begin1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/mismatch.hpp	/^        auto RANGES_FUNC(mismatch)(Rng1 && rng1,$/;"	f	namespace:ranges	typeref:typename:RANGES_DEPRECATED ("Use the variant of ranges::mismatch that takes an upper bound for ""both sequences")auto
RANGES_FUNC	include/range/v3/algorithm/move.hpp	/^        auto RANGES_FUNC(move)(Rng && rng, O out)            \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/move_backward.hpp	/^        auto RANGES_FUNC(move_backward)(Rng && rng, O out)            \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/none_of.hpp	/^        auto RANGES_FUNC(none_of)(Rng && rng, F pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/nth_element.hpp	/^        auto RANGES_FUNC(nth_element)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/partial_sort.hpp	/^        auto RANGES_FUNC(partial_sort)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/partial_sort_copy.hpp	/^        auto RANGES_FUNC(partial_sort_copy)(InRng && in_rng,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/partition.hpp	/^        auto RANGES_FUNC(partition)(Rng && rng, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/partition_copy.hpp	/^        auto RANGES_FUNC(partition_copy)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/partition_point.hpp	/^        auto RANGES_FUNC(partition_point)(Rng && rng, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/permutation.hpp	/^        auto RANGES_FUNC(is_permutation)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/permutation.hpp	/^        auto RANGES_FUNC(is_permutation)(I1 begin1,$/;"	f	namespace:ranges
RANGES_FUNC	include/range/v3/algorithm/permutation.hpp	/^        auto RANGES_FUNC(is_permutation)(I1 begin1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/permutation.hpp	/^        auto RANGES_FUNC(is_permutation)(Rng1 && rng1,$/;"	f	namespace:ranges	typeref:typename:RANGES_DEPRECATED ("Use the variant of ranges::is_permutation that takes an upper bound ""for both sequences")auto
RANGES_FUNC	include/range/v3/algorithm/permutation.hpp	/^        auto RANGES_FUNC(next_permutation)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/permutation.hpp	/^        auto RANGES_FUNC(prev_permutation)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/remove.hpp	/^        auto RANGES_FUNC(remove)(Rng && rng, T const & val, P proj = P{})$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/remove_copy.hpp	/^        auto RANGES_FUNC(remove_copy)(Rng && rng, O out, T const & val, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/remove_copy_if.hpp	/^        auto RANGES_FUNC(remove_copy_if)(Rng && rng, O out, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/remove_if.hpp	/^        auto RANGES_FUNC(remove_if)(Rng && rng, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/replace.hpp	/^        auto RANGES_FUNC(replace)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/replace_copy.hpp	/^        auto RANGES_FUNC(replace_copy)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/replace_copy_if.hpp	/^        auto RANGES_FUNC(replace_copy_if)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/replace_if.hpp	/^        auto RANGES_FUNC(replace_if)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/reverse.hpp	/^        auto RANGES_FUNC(reverse)(Rng && rng) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/reverse_copy.hpp	/^        auto RANGES_FUNC(reverse_copy)(Rng && rng, O out)            \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/rotate.hpp	/^        auto RANGES_FUNC(rotate)(Rng && rng, I middle) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/rotate_copy.hpp	/^        auto RANGES_FUNC(rotate_copy)(Rng && rng, iterator_t<Rng> middle, O out) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/sample.hpp	/^        auto RANGES_FUNC(sample)(I first,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/sample.hpp	/^        auto RANGES_FUNC(sample)(IRng && rng,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/sample.hpp	/^        auto RANGES_FUNC(sample)(Rng && rng,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/search.hpp	/^        auto RANGES_FUNC(search)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/search_n.hpp	/^        auto RANGES_FUNC(search_n)(Rng && rng,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/set_algorithm.hpp	/^        auto RANGES_FUNC(includes)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/set_algorithm.hpp	/^        auto RANGES_FUNC(set_difference)(Rng1 && rng1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/set_algorithm.hpp	/^        auto RANGES_FUNC(set_intersection)(Rng1 && rng1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/set_algorithm.hpp	/^        auto RANGES_FUNC(set_symmetric_difference)(Rng1 && rng1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/set_algorithm.hpp	/^        auto RANGES_FUNC(set_union)(Rng1 && rng1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/shuffle.hpp	/^        auto RANGES_FUNC(shuffle)(Rng && rng,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/sort.hpp	/^        auto RANGES_FUNC(sort)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/stable_partition.hpp	/^        auto RANGES_FUNC(stable_partition)(Rng && rng, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/stable_sort.hpp	/^        auto RANGES_FUNC(stable_sort)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/starts_with.hpp	/^        constexpr auto RANGES_FUNC(starts_with)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/swap_ranges.hpp	/^        auto RANGES_FUNC(swap_ranges)(I1 begin1,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/swap_ranges.hpp	/^        auto RANGES_FUNC(swap_ranges)(Rng1 && rng1, I2_ && begin2)           \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/swap_ranges.hpp	/^        auto RANGES_FUNC(swap_ranges)(Rng1 && rng1, Rng2 && rng2) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/transform.hpp	/^        auto RANGES_FUNC(transform)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/transform.hpp	/^        auto RANGES_FUNC(transform)(I0 begin0,$/;"	f	namespace:ranges	typeref:typename:RANGES_DEPRECATED ("Use the variant of ranges::transform that takes an upper bound ""for both input ranges")auto
RANGES_FUNC	include/range/v3/algorithm/transform.hpp	/^        auto RANGES_FUNC(transform)(I0 begin0,$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/transform.hpp	/^        auto RANGES_FUNC(transform)(Rng && rng, O out, F fun, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/transform.hpp	/^        auto RANGES_FUNC(transform)(Rng0 && rng0,$/;"	f	namespace:ranges	typeref:typename:RANGES_DEPRECATED ("Use the variant of ranges::transform that takes an upper bound ""for both input ranges")auto
RANGES_FUNC	include/range/v3/algorithm/unique.hpp	/^        auto RANGES_FUNC(unique)(Rng && rng, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/unique_copy.hpp	/^        auto RANGES_FUNC(unique_copy)(Rng && rng, O out, C pred = C{}, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/unstable_remove_if.hpp	/^        auto RANGES_FUNC(unstable_remove_if)(Rng && rng, C pred, P proj = P{}) \/\/$/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/algorithm/upper_bound.hpp	/^        auto RANGES_FUNC(upper_bound)($/;"	f	namespace:ranges	typeref:typename:auto
RANGES_FUNC	include/range/v3/detail/config.hpp	/^#define RANGES_FUNC(/;"	d
RANGES_FUNC_BEGIN	include/range/v3/algorithm/adjacent_find.hpp	/^    RANGES_FUNC_BEGIN(adjacent_find)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/adjacent_remove_if.hpp	/^    RANGES_FUNC_BEGIN(adjacent_remove_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/all_of.hpp	/^    RANGES_FUNC_BEGIN(all_of)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/any_of.hpp	/^    RANGES_FUNC_BEGIN(any_of)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/binary_search.hpp	/^    RANGES_FUNC_BEGIN(binary_search)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/copy.hpp	/^    RANGES_FUNC_BEGIN(copy)$/;"	f	namespace:ranges	typeref:typename:namespace _copy CPP_PP_LBRACE ()
RANGES_FUNC_BEGIN	include/range/v3/algorithm/copy_backward.hpp	/^    RANGES_FUNC_BEGIN(copy_backward)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/copy_if.hpp	/^    RANGES_FUNC_BEGIN(copy_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/copy_n.hpp	/^    RANGES_FUNC_BEGIN(copy_n)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/count.hpp	/^    RANGES_FUNC_BEGIN(count)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/count_if.hpp	/^    RANGES_FUNC_BEGIN(count_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/ends_with.hpp	/^    RANGES_FUNC_BEGIN(ends_with)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/equal_range.hpp	/^    RANGES_FUNC_BEGIN(equal_range)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/fill.hpp	/^    RANGES_FUNC_BEGIN(fill)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/fill_n.hpp	/^    RANGES_FUNC_BEGIN(fill_n)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/find.hpp	/^    RANGES_FUNC_BEGIN(find)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/find_end.hpp	/^    RANGES_FUNC_BEGIN(find_end)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/find_first_of.hpp	/^    RANGES_FUNC_BEGIN(find_first_of)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/find_if.hpp	/^    RANGES_FUNC_BEGIN(find_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/find_if_not.hpp	/^    RANGES_FUNC_BEGIN(find_if_not)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/for_each.hpp	/^    RANGES_FUNC_BEGIN(for_each)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/for_each_n.hpp	/^    RANGES_FUNC_BEGIN(for_each_n)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/generate.hpp	/^    RANGES_FUNC_BEGIN(generate)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/generate_n.hpp	/^    RANGES_FUNC_BEGIN(generate_n)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/heap_algorithm.hpp	/^    RANGES_FUNC_BEGIN(is_heap)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/heap_algorithm.hpp	/^    RANGES_FUNC_BEGIN(is_heap_until)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/heap_algorithm.hpp	/^    RANGES_FUNC_BEGIN(make_heap)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/heap_algorithm.hpp	/^    RANGES_FUNC_BEGIN(pop_heap)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/heap_algorithm.hpp	/^    RANGES_FUNC_BEGIN(push_heap)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/heap_algorithm.hpp	/^    RANGES_FUNC_BEGIN(sort_heap)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/inplace_merge.hpp	/^    RANGES_FUNC_BEGIN(inplace_merge)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/is_partitioned.hpp	/^    RANGES_FUNC_BEGIN(is_partitioned)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/is_sorted.hpp	/^    RANGES_FUNC_BEGIN(is_sorted)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/is_sorted_until.hpp	/^    RANGES_FUNC_BEGIN(is_sorted_until)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/lexicographical_compare.hpp	/^    RANGES_FUNC_BEGIN(lexicographical_compare)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/lower_bound.hpp	/^    RANGES_FUNC_BEGIN(lower_bound)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/max.hpp	/^    RANGES_FUNC_BEGIN(max)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/max_element.hpp	/^    RANGES_FUNC_BEGIN(max_element)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/merge.hpp	/^    RANGES_FUNC_BEGIN(merge)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/min.hpp	/^    RANGES_FUNC_BEGIN(min)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/min_element.hpp	/^    RANGES_FUNC_BEGIN(min_element)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/minmax.hpp	/^    RANGES_FUNC_BEGIN(minmax)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/minmax_element.hpp	/^    RANGES_FUNC_BEGIN(minmax_element)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/move.hpp	/^    RANGES_FUNC_BEGIN(move)$/;"	f	namespace:ranges	typeref:typename:namespace _move CPP_PP_LBRACE ()
RANGES_FUNC_BEGIN	include/range/v3/algorithm/move_backward.hpp	/^    RANGES_FUNC_BEGIN(move_backward)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/none_of.hpp	/^    RANGES_FUNC_BEGIN(none_of)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/nth_element.hpp	/^    RANGES_FUNC_BEGIN(nth_element)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/partial_sort.hpp	/^    RANGES_FUNC_BEGIN(partial_sort)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/partial_sort_copy.hpp	/^    RANGES_FUNC_BEGIN(partial_sort_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/partition.hpp	/^    RANGES_FUNC_BEGIN(partition)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/partition_copy.hpp	/^    RANGES_FUNC_BEGIN(partition_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/partition_point.hpp	/^    RANGES_FUNC_BEGIN(partition_point)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/permutation.hpp	/^    RANGES_FUNC_BEGIN(next_permutation)$/;"	f	namespace:ranges	typeref:typename:is_permutation
RANGES_FUNC_BEGIN	include/range/v3/algorithm/permutation.hpp	/^    RANGES_FUNC_BEGIN(prev_permutation)$/;"	f	namespace:ranges	typeref:typename:next_permutation
RANGES_FUNC_BEGIN	include/range/v3/algorithm/remove.hpp	/^    RANGES_FUNC_BEGIN(remove)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/remove_copy.hpp	/^    RANGES_FUNC_BEGIN(remove_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/remove_copy_if.hpp	/^    RANGES_FUNC_BEGIN(remove_copy_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/remove_if.hpp	/^    RANGES_FUNC_BEGIN(remove_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/replace.hpp	/^    RANGES_FUNC_BEGIN(replace)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/replace_copy.hpp	/^    RANGES_FUNC_BEGIN(replace_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/replace_copy_if.hpp	/^    RANGES_FUNC_BEGIN(replace_copy_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/replace_if.hpp	/^    RANGES_FUNC_BEGIN(replace_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/reverse.hpp	/^    RANGES_FUNC_BEGIN(reverse)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/reverse_copy.hpp	/^    RANGES_FUNC_BEGIN(reverse_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/rotate.hpp	/^    RANGES_FUNC_BEGIN(rotate)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/rotate_copy.hpp	/^    RANGES_FUNC_BEGIN(rotate_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/sample.hpp	/^    RANGES_FUNC_BEGIN(sample)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/search.hpp	/^    RANGES_FUNC_BEGIN(search)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/search_n.hpp	/^    RANGES_FUNC_BEGIN(search_n)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/set_algorithm.hpp	/^    RANGES_FUNC_BEGIN(includes)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/set_algorithm.hpp	/^    RANGES_FUNC_BEGIN(set_difference)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/set_algorithm.hpp	/^    RANGES_FUNC_BEGIN(set_intersection)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/set_algorithm.hpp	/^    RANGES_FUNC_BEGIN(set_symmetric_difference)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/set_algorithm.hpp	/^    RANGES_FUNC_BEGIN(set_union)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/shuffle.hpp	/^    RANGES_FUNC_BEGIN(shuffle)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/sort.hpp	/^    RANGES_FUNC_BEGIN(sort)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/stable_partition.hpp	/^    RANGES_FUNC_BEGIN(stable_partition)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/stable_sort.hpp	/^    RANGES_FUNC_BEGIN(stable_sort)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/starts_with.hpp	/^    RANGES_FUNC_BEGIN(starts_with)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/swap_ranges.hpp	/^    RANGES_FUNC_BEGIN(swap_ranges)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/transform.hpp	/^    RANGES_FUNC_BEGIN(transform)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/unique.hpp	/^    RANGES_FUNC_BEGIN(unique)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/unique_copy.hpp	/^    RANGES_FUNC_BEGIN(unique_copy)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/unstable_remove_if.hpp	/^    RANGES_FUNC_BEGIN(unstable_remove_if)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/algorithm/upper_bound.hpp	/^    RANGES_FUNC_BEGIN(upper_bound)$/;"	f	namespace:ranges
RANGES_FUNC_BEGIN	include/range/v3/detail/config.hpp	/^#define RANGES_FUNC_BEGIN(/;"	d
RANGES_FUNC_CONST_	include/range/v3/detail/config.hpp	/^#define RANGES_FUNC_CONST_(/;"	d
RANGES_FUNC_END	include/range/v3/detail/config.hpp	/^#define RANGES_FUNC_END(/;"	d
RANGES_HIDDEN_DETAIL	include/range/v3/detail/config.hpp	/^#define RANGES_HIDDEN_DETAIL(/;"	d
RANGES_INLINE_VAR	include/range/v3/detail/config.hpp	/^#define RANGES_INLINE_VAR /;"	d
RANGES_INLINE_VAR	include/range/v3/detail/config.hpp	/^#define RANGES_INLINE_VAR$/;"	d
RANGES_INLINE_VARIABLE	include/range/v3/detail/config.hpp	/^#define RANGES_INLINE_VARIABLE(/;"	d
RANGES_INLINE_VARIABLE	include/range/v3/iterator/operations.hpp	/^    RANGES_INLINE_VARIABLE(advance_fn, advance)$/;"	f	namespace:ranges
RANGES_INLINE_VARIABLE	include/range/v3/view/for_each.hpp	/^    RANGES_INLINE_VARIABLE(lazy_yield_if_fn, lazy_yield_if)$/;"	f	namespace:ranges
RANGES_INTENDED_MODULAR_ARITHMETIC	include/range/v3/detail/config.hpp	/^#define RANGES_INTENDED_MODULAR_ARITHMETIC /;"	d
RANGES_INTENDED_MODULAR_ARITHMETIC	include/range/v3/detail/config.hpp	/^#define RANGES_INTENDED_MODULAR_ARITHMETIC$/;"	d
RANGES_IS_SAME	include/range/v3/detail/config.hpp	/^#define RANGES_IS_SAME(/;"	d
RANGES_NDEBUG_CONSTEXPR	include/range/v3/detail/config.hpp	/^#define RANGES_NDEBUG_CONSTEXPR /;"	d
RANGES_NODISCARD	include/range/v3/detail/config.hpp	/^#define RANGES_NODISCARD /;"	d
RANGES_NODISCARD	include/range/v3/detail/config.hpp	/^#define RANGES_NODISCARD$/;"	d
RANGES_NO_UNIQUE_ADDRESS	include/range/v3/detail/config.hpp	/^#define RANGES_NO_UNIQUE_ADDRESS /;"	d
RANGES_NO_UNIQUE_ADDRESS	include/range/v3/detail/config.hpp	/^#define RANGES_NO_UNIQUE_ADDRESS$/;"	d
RANGES_PRAGMA	include/range/v3/detail/config.hpp	/^#define RANGES_PRAGMA(/;"	d
RANGES_RE_ENABLE_WARNINGS	include/range/v3/detail/config.hpp	/^#define RANGES_RE_ENABLE_WARNINGS /;"	d
RANGES_RE_ENABLE_WARNINGS	include/range/v3/detail/config.hpp	/^#define RANGES_RE_ENABLE_WARNINGS$/;"	d
RANGES_SATISFY_BOOST_RANGE	include/range/v3/detail/satisfy_boost_range.hpp	/^#define RANGES_SATISFY_BOOST_RANGE(/;"	d
RANGES_STRINGIZE	include/range/v3/detail/config.hpp	/^#define RANGES_STRINGIZE(/;"	d
RANGES_STRINGIZE_	include/range/v3/detail/config.hpp	/^#define RANGES_STRINGIZE_(/;"	d
RANGES_V3_ACTION_ADJACENT_REMOVE_IF_HPP	include/range/v3/action/adjacent_remove_if.hpp	/^#define RANGES_V3_ACTION_ADJACENT_REMOVE_IF_HPP$/;"	d
RANGES_V3_ACTION_CONCEPTS_HPP	include/range/v3/action/concepts.hpp	/^#define RANGES_V3_ACTION_CONCEPTS_HPP$/;"	d
RANGES_V3_ACTION_DROP_HPP	include/range/v3/action/drop.hpp	/^#define RANGES_V3_ACTION_DROP_HPP$/;"	d
RANGES_V3_ACTION_DROP_WHILE_HPP	include/range/v3/action/drop_while.hpp	/^#define RANGES_V3_ACTION_DROP_WHILE_HPP$/;"	d
RANGES_V3_ACTION_ERASE_HPP	include/range/v3/action/erase.hpp	/^#define RANGES_V3_ACTION_ERASE_HPP$/;"	d
RANGES_V3_ACTION_HPP	include/range/v3/action.hpp	/^#define RANGES_V3_ACTION_HPP$/;"	d
RANGES_V3_ACTION_INSERT_HPP	include/range/v3/action/insert.hpp	/^#define RANGES_V3_ACTION_INSERT_HPP$/;"	d
RANGES_V3_ACTION_JOIN_HPP	include/range/v3/action/join.hpp	/^#define RANGES_V3_ACTION_JOIN_HPP$/;"	d
RANGES_V3_ACTION_PUSH_BACK_HPP	include/range/v3/action/push_back.hpp	/^#define RANGES_V3_ACTION_PUSH_BACK_HPP$/;"	d
RANGES_V3_ACTION_PUSH_FRONT_HPP	include/range/v3/action/push_front.hpp	/^#define RANGES_V3_ACTION_PUSH_FRONT_HPP$/;"	d
RANGES_V3_ACTION_REMOVE_HPP	include/range/v3/action/remove.hpp	/^#define RANGES_V3_ACTION_REMOVE_HPP$/;"	d
RANGES_V3_ACTION_REMOVE_IF_HPP	include/range/v3/action/remove_if.hpp	/^#define RANGES_V3_ACTION_REMOVE_IF_HPP$/;"	d
RANGES_V3_ACTION_REVERSE_HPP	include/range/v3/action/reverse.hpp	/^#define RANGES_V3_ACTION_REVERSE_HPP$/;"	d
RANGES_V3_ACTION_SHUFFLE_HPP	include/range/v3/action/shuffle.hpp	/^#define RANGES_V3_ACTION_SHUFFLE_HPP$/;"	d
RANGES_V3_ACTION_SLICE_HPP	include/range/v3/action/slice.hpp	/^#define RANGES_V3_ACTION_SLICE_HPP$/;"	d
RANGES_V3_ACTION_SORT_HPP	include/range/v3/action/sort.hpp	/^#define RANGES_V3_ACTION_SORT_HPP$/;"	d
RANGES_V3_ACTION_SPLIT_HPP	include/range/v3/action/split.hpp	/^#define RANGES_V3_ACTION_SPLIT_HPP$/;"	d
RANGES_V3_ACTION_SPLIT_WHEN_HPP	include/range/v3/action/split_when.hpp	/^#define RANGES_V3_ACTION_SPLIT_WHEN_HPP$/;"	d
RANGES_V3_ACTION_STABLE_SORT_HPP	include/range/v3/action/stable_sort.hpp	/^#define RANGES_V3_ACTION_STABLE_SORT_HPP$/;"	d
RANGES_V3_ACTION_STRIDE_HPP	include/range/v3/action/stride.hpp	/^#define RANGES_V3_ACTION_STRIDE_HPP$/;"	d
RANGES_V3_ACTION_TAKE_HPP	include/range/v3/action/take.hpp	/^#define RANGES_V3_ACTION_TAKE_HPP$/;"	d
RANGES_V3_ACTION_TAKE_WHILE_HPP	include/range/v3/action/take_while.hpp	/^#define RANGES_V3_ACTION_TAKE_WHILE_HPP$/;"	d
RANGES_V3_ACTION_TRANSFORM_HPP	include/range/v3/action/transform.hpp	/^#define RANGES_V3_ACTION_TRANSFORM_HPP$/;"	d
RANGES_V3_ACTION_UNIQUE_HPP	include/range/v3/action/unique.hpp	/^#define RANGES_V3_ACTION_UNIQUE_HPP$/;"	d
RANGES_V3_ACTION_UNSTABLE_REMOVE_IF_HPP	include/range/v3/action/unstable_remove_if.hpp	/^#define RANGES_V3_ACTION_UNSTABLE_REMOVE_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_ADJACENT_FIND_HPP	include/range/v3/algorithm/adjacent_find.hpp	/^#define RANGES_V3_ALGORITHM_ADJACENT_FIND_HPP$/;"	d
RANGES_V3_ALGORITHM_ADJACENT_REMOVE_IF_HPP	include/range/v3/algorithm/adjacent_remove_if.hpp	/^#define RANGES_V3_ALGORITHM_ADJACENT_REMOVE_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_ALL_OF_HPP	include/range/v3/algorithm/all_of.hpp	/^#define RANGES_V3_ALGORITHM_ALL_OF_HPP$/;"	d
RANGES_V3_ALGORITHM_ANY_OF_HPP	include/range/v3/algorithm/any_of.hpp	/^#define RANGES_V3_ALGORITHM_ANY_OF_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_EQUAL_RANGE_N_HPP	include/range/v3/algorithm/aux_/equal_range_n.hpp	/^#define RANGES_V3_ALGORITHM_AUX_EQUAL_RANGE_N_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_LOWER_BOUND_N_HPP	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^#define RANGES_V3_ALGORITHM_AUX_LOWER_BOUND_N_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_MERGE_N_HPP	include/range/v3/algorithm/aux_/merge_n.hpp	/^#define RANGES_V3_ALGORITHM_AUX_MERGE_N_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_MERGE_N_WITH_BUFFER_HPP	include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp	/^#define RANGES_V3_ALGORITHM_AUX_MERGE_N_WITH_BUFFER_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_PARTITION_POINT_N_HPP	include/range/v3/algorithm/aux_/partition_point_n.hpp	/^#define RANGES_V3_ALGORITHM_AUX_PARTITION_POINT_N_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_SORT_N_WITH_BUFFER_HPP	include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp	/^#define RANGES_V3_ALGORITHM_AUX_SORT_N_WITH_BUFFER_HPP$/;"	d
RANGES_V3_ALGORITHM_AUX_UPPER_BOUND_N_HPP	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^#define RANGES_V3_ALGORITHM_AUX_UPPER_BOUND_N_HPP$/;"	d
RANGES_V3_ALGORITHM_BINARY_SEARCH_HPP	include/range/v3/algorithm/binary_search.hpp	/^#define RANGES_V3_ALGORITHM_BINARY_SEARCH_HPP$/;"	d
RANGES_V3_ALGORITHM_COPY_BACKWARD_HPP	include/range/v3/algorithm/copy_backward.hpp	/^#define RANGES_V3_ALGORITHM_COPY_BACKWARD_HPP$/;"	d
RANGES_V3_ALGORITHM_COPY_HPP	include/range/v3/algorithm/copy.hpp	/^#define RANGES_V3_ALGORITHM_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_COPY_IF_HPP	include/range/v3/algorithm/copy_if.hpp	/^#define RANGES_V3_ALGORITHM_COPY_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_COPY_N_HPP	include/range/v3/algorithm/copy_n.hpp	/^#define RANGES_V3_ALGORITHM_COPY_N_HPP$/;"	d
RANGES_V3_ALGORITHM_COUNT_HPP	include/range/v3/algorithm/count.hpp	/^#define RANGES_V3_ALGORITHM_COUNT_HPP$/;"	d
RANGES_V3_ALGORITHM_COUNT_IF_HPP	include/range/v3/algorithm/count_if.hpp	/^#define RANGES_V3_ALGORITHM_COUNT_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_ENDS_WITH_HPP	include/range/v3/algorithm/ends_with.hpp	/^#define RANGES_V3_ALGORITHM_ENDS_WITH_HPP$/;"	d
RANGES_V3_ALGORITHM_EQUAL_HPP	include/range/v3/algorithm/equal.hpp	/^#define RANGES_V3_ALGORITHM_EQUAL_HPP$/;"	d
RANGES_V3_ALGORITHM_EQUAL_RANGE_HPP	include/range/v3/algorithm/equal_range.hpp	/^#define RANGES_V3_ALGORITHM_EQUAL_RANGE_HPP$/;"	d
RANGES_V3_ALGORITHM_FILL_HPP	include/range/v3/algorithm/fill.hpp	/^#define RANGES_V3_ALGORITHM_FILL_HPP$/;"	d
RANGES_V3_ALGORITHM_FILL_N_HPP	include/range/v3/algorithm/fill_n.hpp	/^#define RANGES_V3_ALGORITHM_FILL_N_HPP$/;"	d
RANGES_V3_ALGORITHM_FIND_END_HPP	include/range/v3/algorithm/find_end.hpp	/^#define RANGES_V3_ALGORITHM_FIND_END_HPP$/;"	d
RANGES_V3_ALGORITHM_FIND_FIRST_OF_HPP	include/range/v3/algorithm/find_first_of.hpp	/^#define RANGES_V3_ALGORITHM_FIND_FIRST_OF_HPP$/;"	d
RANGES_V3_ALGORITHM_FIND_HPP	include/range/v3/algorithm/find.hpp	/^#define RANGES_V3_ALGORITHM_FIND_HPP$/;"	d
RANGES_V3_ALGORITHM_FIND_IF_HPP	include/range/v3/algorithm/find_if.hpp	/^#define RANGES_V3_ALGORITHM_FIND_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_FIND_IF_NOT_HPP	include/range/v3/algorithm/find_if_not.hpp	/^#define RANGES_V3_ALGORITHM_FIND_IF_NOT_HPP$/;"	d
RANGES_V3_ALGORITHM_FOR_EACH_HPP	include/range/v3/algorithm/for_each.hpp	/^#define RANGES_V3_ALGORITHM_FOR_EACH_HPP$/;"	d
RANGES_V3_ALGORITHM_FOR_EACH_N_HPP	include/range/v3/algorithm/for_each_n.hpp	/^#define RANGES_V3_ALGORITHM_FOR_EACH_N_HPP$/;"	d
RANGES_V3_ALGORITHM_GENERATE_HPP	include/range/v3/algorithm/generate.hpp	/^#define RANGES_V3_ALGORITHM_GENERATE_HPP$/;"	d
RANGES_V3_ALGORITHM_GENERATE_N_HPP	include/range/v3/algorithm/generate_n.hpp	/^#define RANGES_V3_ALGORITHM_GENERATE_N_HPP$/;"	d
RANGES_V3_ALGORITHM_HEAP_ALGORITHM_HPP	include/range/v3/algorithm/heap_algorithm.hpp	/^#define RANGES_V3_ALGORITHM_HEAP_ALGORITHM_HPP$/;"	d
RANGES_V3_ALGORITHM_HPP	include/range/v3/algorithm.hpp	/^#define RANGES_V3_ALGORITHM_HPP$/;"	d
RANGES_V3_ALGORITHM_INPLACE_MERGE_HPP	include/range/v3/algorithm/inplace_merge.hpp	/^#define RANGES_V3_ALGORITHM_INPLACE_MERGE_HPP$/;"	d
RANGES_V3_ALGORITHM_IS_PARTITIONED_HPP	include/range/v3/algorithm/is_partitioned.hpp	/^#define RANGES_V3_ALGORITHM_IS_PARTITIONED_HPP$/;"	d
RANGES_V3_ALGORITHM_IS_SORTED_HPP	include/range/v3/algorithm/is_sorted.hpp	/^#define RANGES_V3_ALGORITHM_IS_SORTED_HPP$/;"	d
RANGES_V3_ALGORITHM_IS_SORTED_UNTIL_HPP	include/range/v3/algorithm/is_sorted_until.hpp	/^#define RANGES_V3_ALGORITHM_IS_SORTED_UNTIL_HPP$/;"	d
RANGES_V3_ALGORITHM_LEXICOGRAPHICAL_COMPARE_HPP	include/range/v3/algorithm/lexicographical_compare.hpp	/^#define RANGES_V3_ALGORITHM_LEXICOGRAPHICAL_COMPARE_HPP$/;"	d
RANGES_V3_ALGORITHM_LOWER_BOUND_HPP	include/range/v3/algorithm/lower_bound.hpp	/^#define RANGES_V3_ALGORITHM_LOWER_BOUND_HPP$/;"	d
RANGES_V3_ALGORITHM_MAX_ELEMENT_HPP	include/range/v3/algorithm/max_element.hpp	/^#define RANGES_V3_ALGORITHM_MAX_ELEMENT_HPP$/;"	d
RANGES_V3_ALGORITHM_MAX_HPP	include/range/v3/algorithm/max.hpp	/^#define RANGES_V3_ALGORITHM_MAX_HPP$/;"	d
RANGES_V3_ALGORITHM_MERGE_HPP	include/range/v3/algorithm/merge.hpp	/^#define RANGES_V3_ALGORITHM_MERGE_HPP$/;"	d
RANGES_V3_ALGORITHM_MINMAX_ELEMENT_HPP	include/range/v3/algorithm/minmax_element.hpp	/^#define RANGES_V3_ALGORITHM_MINMAX_ELEMENT_HPP$/;"	d
RANGES_V3_ALGORITHM_MINMAX_HPP	include/range/v3/algorithm/minmax.hpp	/^#define RANGES_V3_ALGORITHM_MINMAX_HPP$/;"	d
RANGES_V3_ALGORITHM_MIN_ELEMENT_HPP	include/range/v3/algorithm/min_element.hpp	/^#define RANGES_V3_ALGORITHM_MIN_ELEMENT_HPP$/;"	d
RANGES_V3_ALGORITHM_MIN_HPP	include/range/v3/algorithm/min.hpp	/^#define RANGES_V3_ALGORITHM_MIN_HPP$/;"	d
RANGES_V3_ALGORITHM_MISMATCH_HPP	include/range/v3/algorithm/mismatch.hpp	/^#define RANGES_V3_ALGORITHM_MISMATCH_HPP$/;"	d
RANGES_V3_ALGORITHM_MOVE_BACKWARD_HPP	include/range/v3/algorithm/move_backward.hpp	/^#define RANGES_V3_ALGORITHM_MOVE_BACKWARD_HPP$/;"	d
RANGES_V3_ALGORITHM_MOVE_HPP	include/range/v3/algorithm/move.hpp	/^#define RANGES_V3_ALGORITHM_MOVE_HPP$/;"	d
RANGES_V3_ALGORITHM_NONE_OF_HPP	include/range/v3/algorithm/none_of.hpp	/^#define RANGES_V3_ALGORITHM_NONE_OF_HPP$/;"	d
RANGES_V3_ALGORITHM_NTH_ELEMENT_HPP	include/range/v3/algorithm/nth_element.hpp	/^#define RANGES_V3_ALGORITHM_NTH_ELEMENT_HPP$/;"	d
RANGES_V3_ALGORITHM_PARTIAL_SORT_COPY_HPP	include/range/v3/algorithm/partial_sort_copy.hpp	/^#define RANGES_V3_ALGORITHM_PARTIAL_SORT_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_PARTIAL_SORT_HPP	include/range/v3/algorithm/partial_sort.hpp	/^#define RANGES_V3_ALGORITHM_PARTIAL_SORT_HPP$/;"	d
RANGES_V3_ALGORITHM_PARTITION_COPY_HPP	include/range/v3/algorithm/partition_copy.hpp	/^#define RANGES_V3_ALGORITHM_PARTITION_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_PARTITION_HPP	include/range/v3/algorithm/partition.hpp	/^#define RANGES_V3_ALGORITHM_PARTITION_HPP$/;"	d
RANGES_V3_ALGORITHM_PARTITION_POINT_HPP	include/range/v3/algorithm/partition_point.hpp	/^#define RANGES_V3_ALGORITHM_PARTITION_POINT_HPP$/;"	d
RANGES_V3_ALGORITHM_PERMUTATION_HPP	include/range/v3/algorithm/permutation.hpp	/^#define RANGES_V3_ALGORITHM_PERMUTATION_HPP$/;"	d
RANGES_V3_ALGORITHM_REMOVE_COPY_HPP	include/range/v3/algorithm/remove_copy.hpp	/^#define RANGES_V3_ALGORITHM_REMOVE_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_REMOVE_COPY_IF_HPP	include/range/v3/algorithm/remove_copy_if.hpp	/^#define RANGES_V3_ALGORITHM_REMOVE_COPY_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_REMOVE_HPP	include/range/v3/algorithm/remove.hpp	/^#define RANGES_V3_ALGORITHM_REMOVE_HPP$/;"	d
RANGES_V3_ALGORITHM_REMOVE_IF_HPP	include/range/v3/algorithm/remove_if.hpp	/^#define RANGES_V3_ALGORITHM_REMOVE_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_REPLACE_COPY_HPP	include/range/v3/algorithm/replace_copy.hpp	/^#define RANGES_V3_ALGORITHM_REPLACE_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_REPLACE_COPY_IF_HPP	include/range/v3/algorithm/replace_copy_if.hpp	/^#define RANGES_V3_ALGORITHM_REPLACE_COPY_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_REPLACE_HPP	include/range/v3/algorithm/replace.hpp	/^#define RANGES_V3_ALGORITHM_REPLACE_HPP$/;"	d
RANGES_V3_ALGORITHM_REPLACE_IF_HPP	include/range/v3/algorithm/replace_if.hpp	/^#define RANGES_V3_ALGORITHM_REPLACE_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_RESULT_TYPES_HPP	include/range/v3/algorithm/result_types.hpp	/^#define RANGES_V3_ALGORITHM_RESULT_TYPES_HPP$/;"	d
RANGES_V3_ALGORITHM_REVERSE_COPY_HPP	include/range/v3/algorithm/reverse_copy.hpp	/^#define RANGES_V3_ALGORITHM_REVERSE_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_REVERSE_HPP	include/range/v3/algorithm/reverse.hpp	/^#define RANGES_V3_ALGORITHM_REVERSE_HPP$/;"	d
RANGES_V3_ALGORITHM_ROTATE_COPY_HPP	include/range/v3/algorithm/rotate_copy.hpp	/^#define RANGES_V3_ALGORITHM_ROTATE_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_ROTATE_HPP	include/range/v3/algorithm/rotate.hpp	/^#define RANGES_V3_ALGORITHM_ROTATE_HPP$/;"	d
RANGES_V3_ALGORITHM_SAMPLE_HPP	include/range/v3/algorithm/sample.hpp	/^#define RANGES_V3_ALGORITHM_SAMPLE_HPP$/;"	d
RANGES_V3_ALGORITHM_SEARCH_HPP	include/range/v3/algorithm/search.hpp	/^#define RANGES_V3_ALGORITHM_SEARCH_HPP$/;"	d
RANGES_V3_ALGORITHM_SEARCH_N_HPP	include/range/v3/algorithm/search_n.hpp	/^#define RANGES_V3_ALGORITHM_SEARCH_N_HPP$/;"	d
RANGES_V3_ALGORITHM_SET_ALGORITHM_HPP	include/range/v3/algorithm/set_algorithm.hpp	/^#define RANGES_V3_ALGORITHM_SET_ALGORITHM_HPP$/;"	d
RANGES_V3_ALGORITHM_SHUFFLE_HPP	include/range/v3/algorithm/shuffle.hpp	/^#define RANGES_V3_ALGORITHM_SHUFFLE_HPP$/;"	d
RANGES_V3_ALGORITHM_SORT_HPP	include/range/v3/algorithm/sort.hpp	/^#define RANGES_V3_ALGORITHM_SORT_HPP$/;"	d
RANGES_V3_ALGORITHM_STABLE_PARTITION_HPP	include/range/v3/algorithm/stable_partition.hpp	/^#define RANGES_V3_ALGORITHM_STABLE_PARTITION_HPP$/;"	d
RANGES_V3_ALGORITHM_STABLE_SORT_HPP	include/range/v3/algorithm/stable_sort.hpp	/^#define RANGES_V3_ALGORITHM_STABLE_SORT_HPP$/;"	d
RANGES_V3_ALGORITHM_STARTS_WITH_HPP	include/range/v3/algorithm/starts_with.hpp	/^#define RANGES_V3_ALGORITHM_STARTS_WITH_HPP$/;"	d
RANGES_V3_ALGORITHM_SWAP_RANGES_HPP	include/range/v3/algorithm/swap_ranges.hpp	/^#define RANGES_V3_ALGORITHM_SWAP_RANGES_HPP$/;"	d
RANGES_V3_ALGORITHM_TAGSPEC_HPP	include/range/v3/algorithm/tagspec.hpp	/^#define RANGES_V3_ALGORITHM_TAGSPEC_HPP$/;"	d
RANGES_V3_ALGORITHM_TRANSFORM_HPP	include/range/v3/algorithm/transform.hpp	/^#define RANGES_V3_ALGORITHM_TRANSFORM_HPP$/;"	d
RANGES_V3_ALGORITHM_UNIQUE_COPY_HPP	include/range/v3/algorithm/unique_copy.hpp	/^#define RANGES_V3_ALGORITHM_UNIQUE_COPY_HPP$/;"	d
RANGES_V3_ALGORITHM_UNIQUE_HPP	include/range/v3/algorithm/unique.hpp	/^#define RANGES_V3_ALGORITHM_UNIQUE_HPP$/;"	d
RANGES_V3_ALGORITHM_UNSTABLE_REMOVE_IF_HPP	include/range/v3/algorithm/unstable_remove_if.hpp	/^#define RANGES_V3_ALGORITHM_UNSTABLE_REMOVE_IF_HPP$/;"	d
RANGES_V3_ALGORITHM_UPPER_BOUND_HPP	include/range/v3/algorithm/upper_bound.hpp	/^#define RANGES_V3_ALGORITHM_UPPER_BOUND_HPP$/;"	d
RANGES_V3_ALL_HPP	include/range/v3/all.hpp	/^#define RANGES_V3_ALL_HPP$/;"	d
RANGES_V3_AT_HPP	include/range/v3/at.hpp	/^#define RANGES_V3_AT_HPP$/;"	d
RANGES_V3_BACK_HPP	include/range/v3/back.hpp	/^#define RANGES_V3_BACK_HPP$/;"	d
RANGES_V3_BEGIN_END_HPP	include/range/v3/begin_end.hpp	/^#define RANGES_V3_BEGIN_END_HPP$/;"	d
RANGES_V3_CONTAINER_ACTION_HPP	include/range/v3/action/action.hpp	/^#define RANGES_V3_CONTAINER_ACTION_HPP$/;"	d
RANGES_V3_CORE_HPP	include/range/v3/core.hpp	/^#define RANGES_V3_CORE_HPP$/;"	d
RANGES_V3_DATA_HPP	include/range/v3/data.hpp	/^#define RANGES_V3_DATA_HPP$/;"	d
RANGES_V3_DEPRECATED_RANGE_CONCEPTS_HPP	include/range/v3/range_concepts.hpp	/^#define RANGES_V3_DEPRECATED_RANGE_CONCEPTS_HPP$/;"	d
RANGES_V3_DETAIL_ADL_GET_HPP	include/range/v3/detail/adl_get.hpp	/^#define RANGES_V3_DETAIL_ADL_GET_HPP$/;"	d
RANGES_V3_DETAIL_CONFIG_HPP	include/range/v3/detail/config.hpp	/^#define RANGES_V3_DETAIL_CONFIG_HPP$/;"	d
RANGES_V3_DETAIL_RANGE_ACCESS_HPP	include/range/v3/detail/range_access.hpp	/^#define RANGES_V3_DETAIL_RANGE_ACCESS_HPP$/;"	d
RANGES_V3_DETAIL_SATISFY_BOOST_RANGE_HPP	include/range/v3/detail/satisfy_boost_range.hpp	/^#define RANGES_V3_DETAIL_SATISFY_BOOST_RANGE_HPP$/;"	d
RANGES_V3_DETAIL_VARIANT_HPP	include/range/v3/detail/variant.hpp	/^#define RANGES_V3_DETAIL_VARIANT_HPP$/;"	d
RANGES_V3_DETAIL_WITH_BRACED_INIT_ARGS_HPP	include/range/v3/detail/with_braced_init_args.hpp	/^#define RANGES_V3_DETAIL_WITH_BRACED_INIT_ARGS_HPP$/;"	d
RANGES_V3_DISTANCE_HPP	include/range/v3/distance.hpp	/^#define RANGES_V3_DISTANCE_HPP$/;"	d
RANGES_V3_EMPTY_HPP	include/range/v3/empty.hpp	/^#define RANGES_V3_EMPTY_HPP$/;"	d
RANGES_V3_EXPERIMENTAL_UTILITY_GENERATOR_HPP	include/range/v3/experimental/utility/generator.hpp	/^#define RANGES_V3_EXPERIMENTAL_UTILITY_GENERATOR_HPP$/;"	d
RANGES_V3_EXPERIMENTAL_VIEW_SHARED_HPP	include/range/v3/experimental/view/shared.hpp	/^#define RANGES_V3_EXPERIMENTAL_VIEW_SHARED_HPP$/;"	d
RANGES_V3_FRONT_HPP	include/range/v3/front.hpp	/^#define RANGES_V3_FRONT_HPP$/;"	d
RANGES_V3_FUNCTIONAL_ARITHMETIC_HPP	include/range/v3/functional/arithmetic.hpp	/^#define RANGES_V3_FUNCTIONAL_ARITHMETIC_HPP$/;"	d
RANGES_V3_FUNCTIONAL_BIND_HPP	include/range/v3/functional/bind.hpp	/^#define RANGES_V3_FUNCTIONAL_BIND_HPP$/;"	d
RANGES_V3_FUNCTIONAL_COMPARISONS_HPP	include/range/v3/functional/comparisons.hpp	/^#define RANGES_V3_FUNCTIONAL_COMPARISONS_HPP$/;"	d
RANGES_V3_FUNCTIONAL_COMPOSE_HPP	include/range/v3/functional/compose.hpp	/^#define RANGES_V3_FUNCTIONAL_COMPOSE_HPP$/;"	d
RANGES_V3_FUNCTIONAL_CONCEPTS_HPP	include/range/v3/functional/concepts.hpp	/^#define RANGES_V3_FUNCTIONAL_CONCEPTS_HPP$/;"	d
RANGES_V3_FUNCTIONAL_HPP	include/range/v3/functional.hpp	/^#define RANGES_V3_FUNCTIONAL_HPP$/;"	d
RANGES_V3_FUNCTIONAL_IDENTITY_HPP	include/range/v3/functional/identity.hpp	/^#define RANGES_V3_FUNCTIONAL_IDENTITY_HPP$/;"	d
RANGES_V3_FUNCTIONAL_INDIRECT_HPP	include/range/v3/functional/indirect.hpp	/^#define RANGES_V3_FUNCTIONAL_INDIRECT_HPP$/;"	d
RANGES_V3_FUNCTIONAL_INVOKE_HPP	include/range/v3/functional/invoke.hpp	/^#define RANGES_V3_FUNCTIONAL_INVOKE_HPP$/;"	d
RANGES_V3_FUNCTIONAL_NOT_FN_HPP	include/range/v3/functional/not_fn.hpp	/^#define RANGES_V3_FUNCTIONAL_NOT_FN_HPP$/;"	d
RANGES_V3_FUNCTIONAL_ON_HPP	include/range/v3/functional/on.hpp	/^#define RANGES_V3_FUNCTIONAL_ON_HPP$/;"	d
RANGES_V3_FUNCTIONAL_OVERLOAD_HPP	include/range/v3/functional/overload.hpp	/^#define RANGES_V3_FUNCTIONAL_OVERLOAD_HPP$/;"	d
RANGES_V3_FUNCTIONAL_PIPEABLE_HPP	include/range/v3/functional/pipeable.hpp	/^#define RANGES_V3_FUNCTIONAL_PIPEABLE_HPP$/;"	d
RANGES_V3_FUNCTIONAL_REFERENCE_WRAPPER_HPP	include/range/v3/functional/reference_wrapper.hpp	/^#define RANGES_V3_FUNCTIONAL_REFERENCE_WRAPPER_HPP$/;"	d
RANGES_V3_GETLINES_HPP	include/range/v3/getlines.hpp	/^#define RANGES_V3_GETLINES_HPP$/;"	d
RANGES_V3_INDEX_HPP	include/range/v3/index.hpp	/^#define RANGES_V3_INDEX_HPP$/;"	d
RANGES_V3_ISTREAM_RANGE_HPP	include/range/v3/istream_range.hpp	/^#define RANGES_V3_ISTREAM_RANGE_HPP$/;"	d
RANGES_V3_ITERATOR_ACCESS_HPP	include/range/v3/iterator/access.hpp	/^#define RANGES_V3_ITERATOR_ACCESS_HPP$/;"	d
RANGES_V3_ITERATOR_BASIC_ITERATOR_HPP	include/range/v3/iterator/basic_iterator.hpp	/^#define RANGES_V3_ITERATOR_BASIC_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_COMMON_ITERATOR_HPP	include/range/v3/iterator/common_iterator.hpp	/^#define RANGES_V3_ITERATOR_COMMON_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_CONCEPTS_HPP	include/range/v3/iterator/concepts.hpp	/^#define RANGES_V3_ITERATOR_CONCEPTS_HPP$/;"	d
RANGES_V3_ITERATOR_COUNTED_ITERATOR_HPP	include/range/v3/iterator/counted_iterator.hpp	/^#define RANGES_V3_ITERATOR_COUNTED_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_DEFAULT_SENTINEL_HPP	include/range/v3/iterator/default_sentinel.hpp	/^#define RANGES_V3_ITERATOR_DEFAULT_SENTINEL_HPP$/;"	d
RANGES_V3_ITERATOR_DIFFMAX_T_HPP	include/range/v3/iterator/diffmax_t.hpp	/^#define RANGES_V3_ITERATOR_DIFFMAX_T_HPP$/;"	d
RANGES_V3_ITERATOR_HPP	include/range/v3/iterator.hpp	/^#define RANGES_V3_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_HPP	include/range/v3/range.hpp	/^#define RANGES_V3_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_HPP	include/range/v3/utility.hpp	/^#define RANGES_V3_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_INSERT_ITERATORS_HPP	include/range/v3/iterator/insert_iterators.hpp	/^#define RANGES_V3_ITERATOR_INSERT_ITERATORS_HPP$/;"	d
RANGES_V3_ITERATOR_MOVE_ITERATORS_HPP	include/range/v3/iterator/move_iterators.hpp	/^#define RANGES_V3_ITERATOR_MOVE_ITERATORS_HPP$/;"	d
RANGES_V3_ITERATOR_OPERATIONS_HPP	include/range/v3/iterator/operations.hpp	/^#define RANGES_V3_ITERATOR_OPERATIONS_HPP$/;"	d
RANGES_V3_ITERATOR_RANGE_HPP	include/range/v3/iterator_range.hpp	/^#define RANGES_V3_ITERATOR_RANGE_HPP$/;"	d
RANGES_V3_ITERATOR_REVERSE_ITERATOR_HPP	include/range/v3/iterator/reverse_iterator.hpp	/^#define RANGES_V3_ITERATOR_REVERSE_ITERATOR_HPP$/;"	d
RANGES_V3_ITERATOR_STREAM_ITERATORS_HPP	include/range/v3/iterator/stream_iterators.hpp	/^#define RANGES_V3_ITERATOR_STREAM_ITERATORS_HPP$/;"	d
RANGES_V3_ITERATOR_TRAITS_HPP	include/range/v3/iterator/traits.hpp	/^#define RANGES_V3_ITERATOR_TRAITS_HPP$/;"	d
RANGES_V3_ITERATOR_UNREACHABLE_SENTINEL_HPP	include/range/v3/iterator/unreachable_sentinel.hpp	/^#define RANGES_V3_ITERATOR_UNREACHABLE_SENTINEL_HPP$/;"	d
RANGES_V3_NUMERIC_ACCUMULATE_HPP	include/range/v3/numeric/accumulate.hpp	/^#define RANGES_V3_NUMERIC_ACCUMULATE_HPP$/;"	d
RANGES_V3_NUMERIC_ADJACENT_DIFFERENCE_HPP	include/range/v3/numeric/adjacent_difference.hpp	/^#define RANGES_V3_NUMERIC_ADJACENT_DIFFERENCE_HPP$/;"	d
RANGES_V3_NUMERIC_HPP	include/range/v3/numeric.hpp	/^#define RANGES_V3_NUMERIC_HPP$/;"	d
RANGES_V3_NUMERIC_INNER_PRODUCT_HPP	include/range/v3/numeric/inner_product.hpp	/^#define RANGES_V3_NUMERIC_INNER_PRODUCT_HPP$/;"	d
RANGES_V3_NUMERIC_IOTA_HPP	include/range/v3/numeric/iota.hpp	/^#define RANGES_V3_NUMERIC_IOTA_HPP$/;"	d
RANGES_V3_NUMERIC_PARTIAL_SUM_HPP	include/range/v3/numeric/partial_sum.hpp	/^#define RANGES_V3_NUMERIC_PARTIAL_SUM_HPP$/;"	d
RANGES_V3_OLD_RANGE_ACCESS_HPP	include/range/v3/range_access.hpp	/^#define RANGES_V3_OLD_RANGE_ACCESS_HPP$/;"	d
RANGES_V3_OLD_RANGE_TRAITS_HPP	include/range/v3/range_traits.hpp	/^#define RANGES_V3_OLD_RANGE_TRAITS_HPP$/;"	d
RANGES_V3_OLD_VIEW_ADAPTOR_HPP	include/range/v3/view_adaptor.hpp	/^#define RANGES_V3_OLD_VIEW_ADAPTOR_HPP$/;"	d
RANGES_V3_OLD_VIEW_FACADE_HPP	include/range/v3/view_facade.hpp	/^#define RANGES_V3_OLD_VIEW_FACADE_HPP$/;"	d
RANGES_V3_OLD_VIEW_INTERFACE_HPP	include/range/v3/view_interface.hpp	/^#define RANGES_V3_OLD_VIEW_INTERFACE_HPP$/;"	d
RANGES_V3_RANGE_ACCESS_HPP	include/range/v3/range/access.hpp	/^#define RANGES_V3_RANGE_ACCESS_HPP$/;"	d
RANGES_V3_RANGE_CONCEPTS_HPP	include/range/v3/range/concepts.hpp	/^#define RANGES_V3_RANGE_CONCEPTS_HPP$/;"	d
RANGES_V3_RANGE_CONVERSION_HPP	include/range/v3/range/conversion.hpp	/^#define RANGES_V3_RANGE_CONVERSION_HPP$/;"	d
RANGES_V3_RANGE_DANGLING_HPP	include/range/v3/range/dangling.hpp	/^#define RANGES_V3_RANGE_DANGLING_HPP$/;"	d
RANGES_V3_RANGE_FOR_HPP	include/range/v3/range_for.hpp	/^#define RANGES_V3_RANGE_FOR_HPP$/;"	d
RANGES_V3_RANGE_FWD_HPP	include/range/v3/range_fwd.hpp	/^#define RANGES_V3_RANGE_FWD_HPP$/;"	d
RANGES_V3_RANGE_OPERATIONS_HPP	include/range/v3/range/operations.hpp	/^#define RANGES_V3_RANGE_OPERATIONS_HPP$/;"	d
RANGES_V3_RANGE_PRIMITIVES_HPP	include/range/v3/range/primitives.hpp	/^#define RANGES_V3_RANGE_PRIMITIVES_HPP$/;"	d
RANGES_V3_RANGE_TRAITS_HPP	include/range/v3/range/traits.hpp	/^#define RANGES_V3_RANGE_TRAITS_HPP$/;"	d
RANGES_V3_SIZE_HPP	include/range/v3/size.hpp	/^#define RANGES_V3_SIZE_HPP$/;"	d
RANGES_V3_SPAN_HPP	include/range/v3/span.hpp	/^#define RANGES_V3_SPAN_HPP$/;"	d
RANGES_V3_STD_DETAIL_ASSOCIATED_TYPES_HPP	include/std/detail/associated_types.hpp	/^#define RANGES_V3_STD_DETAIL_ASSOCIATED_TYPES_HPP$/;"	d
RANGES_V3_TO_CONTAINER_HPP	include/range/v3/to_container.hpp	/^#define RANGES_V3_TO_CONTAINER_HPP$/;"	d
RANGES_V3_UTILITY_ANY_HPP	include/range/v3/utility/any.hpp	/^#define RANGES_V3_UTILITY_ANY_HPP$/;"	d
RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP	include/range/v3/utility/associated_types.hpp	/^#define RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP$/;"	d
RANGES_V3_UTILITY_BASIC_ITERATOR_HPP	include/range/v3/utility/basic_iterator.hpp	/^#define RANGES_V3_UTILITY_BASIC_ITERATOR_HPP$/;"	d
RANGES_V3_UTILITY_BOX_HPP	include/range/v3/utility/box.hpp	/^#define RANGES_V3_UTILITY_BOX_HPP$/;"	d
RANGES_V3_UTILITY_COMMON_ITERATOR_HPP	include/range/v3/utility/common_iterator.hpp	/^#define RANGES_V3_UTILITY_COMMON_ITERATOR_HPP$/;"	d
RANGES_V3_UTILITY_COMMON_TUPLE_HPP	include/range/v3/utility/common_tuple.hpp	/^#define RANGES_V3_UTILITY_COMMON_TUPLE_HPP$/;"	d
RANGES_V3_UTILITY_COMMON_TYPE_HPP	include/range/v3/utility/common_type.hpp	/^#define RANGES_V3_UTILITY_COMMON_TYPE_HPP$/;"	d
RANGES_V3_UTILITY_COMPRESSED_PAIR_HPP	include/range/v3/utility/compressed_pair.hpp	/^#define RANGES_V3_UTILITY_COMPRESSED_PAIR_HPP$/;"	d
RANGES_V3_UTILITY_CONCEPTS_HPP	include/range/v3/utility/concepts.hpp	/^#define RANGES_V3_UTILITY_CONCEPTS_HPP$/;"	d
RANGES_V3_UTILITY_COPY_HPP	include/range/v3/utility/copy.hpp	/^#define RANGES_V3_UTILITY_COPY_HPP$/;"	d
RANGES_V3_UTILITY_COUNTED_ITERATOR_HPP	include/range/v3/utility/counted_iterator.hpp	/^#define RANGES_V3_UTILITY_COUNTED_ITERATOR_HPP$/;"	d
RANGES_V3_UTILITY_DANGLING_HPP	include/range/v3/utility/dangling.hpp	/^#define RANGES_V3_UTILITY_DANGLING_HPP$/;"	d
RANGES_V3_UTILITY_FUNCTIONAL_HPP	include/range/v3/utility/functional.hpp	/^#define RANGES_V3_UTILITY_FUNCTIONAL_HPP$/;"	d
RANGES_V3_UTILITY_GET_HPP	include/range/v3/utility/get.hpp	/^#define RANGES_V3_UTILITY_GET_HPP$/;"	d
RANGES_V3_UTILITY_INFINITY_HPP	include/range/v3/utility/infinity.hpp	/^#define RANGES_V3_UTILITY_INFINITY_HPP$/;"	d
RANGES_V3_UTILITY_INVOKE_HPP	include/range/v3/utility/invoke.hpp	/^#define RANGES_V3_UTILITY_INVOKE_HPP$/;"	d
RANGES_V3_UTILITY_IN_PLACE_HPP	include/range/v3/utility/in_place.hpp	/^#define RANGES_V3_UTILITY_IN_PLACE_HPP$/;"	d
RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP	include/range/v3/utility/iterator_concepts.hpp	/^#define RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP$/;"	d
RANGES_V3_UTILITY_ITERATOR_HPP	include/range/v3/utility/iterator.hpp	/^#define RANGES_V3_UTILITY_ITERATOR_HPP$/;"	d
RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP	include/range/v3/utility/iterator_traits.hpp	/^#define RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP$/;"	d
RANGES_V3_UTILITY_MEMORY_HPP	include/range/v3/utility/memory.hpp	/^#define RANGES_V3_UTILITY_MEMORY_HPP$/;"	d
RANGES_V3_UTILITY_MOVE_HPP	include/range/v3/utility/move.hpp	/^#define RANGES_V3_UTILITY_MOVE_HPP$/;"	d
RANGES_V3_UTILITY_NULLPTR_V_HPP	include/range/v3/utility/nullptr_v.hpp	/^#define RANGES_V3_UTILITY_NULLPTR_V_HPP$/;"	d
RANGES_V3_UTILITY_OPTIONAL_HPP	include/range/v3/utility/optional.hpp	/^#define RANGES_V3_UTILITY_OPTIONAL_HPP$/;"	d
RANGES_V3_UTILITY_POLYMORPHIC_CAST_HPP	include/range/v3/utility/polymorphic_cast.hpp	/^#define RANGES_V3_UTILITY_POLYMORPHIC_CAST_HPP$/;"	d
RANGES_V3_UTILITY_RANDOM_HPP	include/range/v3/utility/random.hpp	/^#define RANGES_V3_UTILITY_RANDOM_HPP$/;"	d
RANGES_V3_UTILITY_SCOPE_EXIT_HPP	include/range/v3/utility/scope_exit.hpp	/^#define RANGES_V3_UTILITY_SCOPE_EXIT_HPP$/;"	d
RANGES_V3_UTILITY_SEMIREGULAR_BOX_HPP	include/range/v3/utility/semiregular_box.hpp	/^#define RANGES_V3_UTILITY_SEMIREGULAR_BOX_HPP$/;"	d
RANGES_V3_UTILITY_SEMIREGULAR_HPP	include/range/v3/utility/semiregular.hpp	/^#define RANGES_V3_UTILITY_SEMIREGULAR_HPP$/;"	d
RANGES_V3_UTILITY_STATIC_CONST_HPP	include/range/v3/utility/static_const.hpp	/^#define RANGES_V3_UTILITY_STATIC_CONST_HPP$/;"	d
RANGES_V3_UTILITY_SWAP_HPP	include/range/v3/utility/swap.hpp	/^#define RANGES_V3_UTILITY_SWAP_HPP$/;"	d
RANGES_V3_UTILITY_TAGGED_PAIR_HPP	include/range/v3/utility/tagged_pair.hpp	/^#define RANGES_V3_UTILITY_TAGGED_PAIR_HPP$/;"	d
RANGES_V3_UTILITY_TAGGED_TUPLE_HPP	include/range/v3/utility/tagged_tuple.hpp	/^#define RANGES_V3_UTILITY_TAGGED_TUPLE_HPP$/;"	d
RANGES_V3_UTILITY_TUPLE_ALGORITHM_HPP	include/range/v3/utility/tuple_algorithm.hpp	/^#define RANGES_V3_UTILITY_TUPLE_ALGORITHM_HPP$/;"	d
RANGES_V3_UTILITY_UNREACHABLE_HPP	include/range/v3/utility/unreachable.hpp	/^#define RANGES_V3_UTILITY_UNREACHABLE_HPP$/;"	d
RANGES_V3_UTILITY_VARIANT_HPP	include/range/v3/utility/variant.hpp	/^#define RANGES_V3_UTILITY_VARIANT_HPP$/;"	d
RANGES_V3_UTLITY_ADDRESSOF_HPP	include/range/v3/utility/addressof.hpp	/^#define RANGES_V3_UTLITY_ADDRESSOF_HPP$/;"	d
RANGES_V3_VERSION_HPP	include/range/v3/version.hpp	/^#define RANGES_V3_VERSION_HPP$/;"	d
RANGES_V3_VIEW_ADAPTOR_HPP	include/range/v3/view/adaptor.hpp	/^#define RANGES_V3_VIEW_ADAPTOR_HPP$/;"	d
RANGES_V3_VIEW_ADDRESSOF_HPP	include/range/v3/view/addressof.hpp	/^#define RANGES_V3_VIEW_ADDRESSOF_HPP$/;"	d
RANGES_V3_VIEW_ADJACENT_FILTER_HPP	include/range/v3/view/adjacent_filter.hpp	/^#define RANGES_V3_VIEW_ADJACENT_FILTER_HPP$/;"	d
RANGES_V3_VIEW_ADJACENT_REMOVE_IF_HPP	include/range/v3/view/adjacent_remove_if.hpp	/^#define RANGES_V3_VIEW_ADJACENT_REMOVE_IF_HPP$/;"	d
RANGES_V3_VIEW_ALL_HPP	include/range/v3/view/all.hpp	/^#define RANGES_V3_VIEW_ALL_HPP$/;"	d
RANGES_V3_VIEW_ANY_VIEW_HPP	include/range/v3/view/any_view.hpp	/^#define RANGES_V3_VIEW_ANY_VIEW_HPP$/;"	d
RANGES_V3_VIEW_BOUNDED_HPP	include/range/v3/view/bounded.hpp	/^#define RANGES_V3_VIEW_BOUNDED_HPP$/;"	d
RANGES_V3_VIEW_CACHE1_HPP	include/range/v3/view/cache1.hpp	/^#define RANGES_V3_VIEW_CACHE1_HPP$/;"	d
RANGES_V3_VIEW_CARTESIAN_PRODUCT_HPP	include/range/v3/view/cartesian_product.hpp	/^#define RANGES_V3_VIEW_CARTESIAN_PRODUCT_HPP$/;"	d
RANGES_V3_VIEW_CHUNK_HPP	include/range/v3/view/chunk.hpp	/^#define RANGES_V3_VIEW_CHUNK_HPP$/;"	d
RANGES_V3_VIEW_COMMON_HPP	include/range/v3/view/common.hpp	/^#define RANGES_V3_VIEW_COMMON_HPP$/;"	d
RANGES_V3_VIEW_CONCAT_HPP	include/range/v3/view/concat.hpp	/^#define RANGES_V3_VIEW_CONCAT_HPP$/;"	d
RANGES_V3_VIEW_CONST_HPP	include/range/v3/view/const.hpp	/^#define RANGES_V3_VIEW_CONST_HPP$/;"	d
RANGES_V3_VIEW_COUNTED_HPP	include/range/v3/view/counted.hpp	/^#define RANGES_V3_VIEW_COUNTED_HPP$/;"	d
RANGES_V3_VIEW_CYCLE_HPP	include/range/v3/view/cycle.hpp	/^#define RANGES_V3_VIEW_CYCLE_HPP$/;"	d
RANGES_V3_VIEW_C_STR_HPP	include/range/v3/view/c_str.hpp	/^#define RANGES_V3_VIEW_C_STR_HPP$/;"	d
RANGES_V3_VIEW_DELIMIT_HPP	include/range/v3/view/delimit.hpp	/^#define RANGES_V3_VIEW_DELIMIT_HPP$/;"	d
RANGES_V3_VIEW_DROP_EXACTLY_HPP	include/range/v3/view/drop_exactly.hpp	/^#define RANGES_V3_VIEW_DROP_EXACTLY_HPP$/;"	d
RANGES_V3_VIEW_DROP_HPP	include/range/v3/view/drop.hpp	/^#define RANGES_V3_VIEW_DROP_HPP$/;"	d
RANGES_V3_VIEW_DROP_LAST_HPP	include/range/v3/view/drop_last.hpp	/^#define RANGES_V3_VIEW_DROP_LAST_HPP$/;"	d
RANGES_V3_VIEW_DROP_WHILE_HPP	include/range/v3/view/drop_while.hpp	/^#define RANGES_V3_VIEW_DROP_WHILE_HPP$/;"	d
RANGES_V3_VIEW_EMPTY_HPP	include/range/v3/view/empty.hpp	/^#define RANGES_V3_VIEW_EMPTY_HPP$/;"	d
RANGES_V3_VIEW_ENUMERATE_HPP	include/range/v3/view/enumerate.hpp	/^#define RANGES_V3_VIEW_ENUMERATE_HPP$/;"	d
RANGES_V3_VIEW_FACADE_HPP	include/range/v3/view/facade.hpp	/^#define RANGES_V3_VIEW_FACADE_HPP$/;"	d
RANGES_V3_VIEW_FILTER_HPP	include/range/v3/view/filter.hpp	/^#define RANGES_V3_VIEW_FILTER_HPP$/;"	d
RANGES_V3_VIEW_FOR_EACH_HPP	include/range/v3/view/for_each.hpp	/^#define RANGES_V3_VIEW_FOR_EACH_HPP$/;"	d
RANGES_V3_VIEW_GENERATE_HPP	include/range/v3/view/generate.hpp	/^#define RANGES_V3_VIEW_GENERATE_HPP$/;"	d
RANGES_V3_VIEW_GENERATE_N_HPP	include/range/v3/view/generate_n.hpp	/^#define RANGES_V3_VIEW_GENERATE_N_HPP$/;"	d
RANGES_V3_VIEW_GETLINES_HPP	include/range/v3/view/getlines.hpp	/^#define RANGES_V3_VIEW_GETLINES_HPP$/;"	d
RANGES_V3_VIEW_GROUP_BY_HPP	include/range/v3/view/group_by.hpp	/^#define RANGES_V3_VIEW_GROUP_BY_HPP$/;"	d
RANGES_V3_VIEW_HPP	include/range/v3/view.hpp	/^#define RANGES_V3_VIEW_HPP$/;"	d
RANGES_V3_VIEW_INDICES_HPP	include/range/v3/view/indices.hpp	/^#define RANGES_V3_VIEW_INDICES_HPP$/;"	d
RANGES_V3_VIEW_INDIRECT_HPP	include/range/v3/view/indirect.hpp	/^#define RANGES_V3_VIEW_INDIRECT_HPP$/;"	d
RANGES_V3_VIEW_INTERFACE_HPP	include/range/v3/view/interface.hpp	/^#define RANGES_V3_VIEW_INTERFACE_HPP$/;"	d
RANGES_V3_VIEW_INTERSPERSE_HPP	include/range/v3/view/intersperse.hpp	/^#define RANGES_V3_VIEW_INTERSPERSE_HPP$/;"	d
RANGES_V3_VIEW_IOTA_HPP	include/range/v3/view/iota.hpp	/^#define RANGES_V3_VIEW_IOTA_HPP$/;"	d
RANGES_V3_VIEW_ISTREAM_HPP	include/range/v3/view/istream.hpp	/^#define RANGES_V3_VIEW_ISTREAM_HPP$/;"	d
RANGES_V3_VIEW_JOIN_HPP	include/range/v3/view/join.hpp	/^#define RANGES_V3_VIEW_JOIN_HPP$/;"	d
RANGES_V3_VIEW_LINEAR_DISTRIBUTE_HPP	include/range/v3/view/linear_distribute.hpp	/^#define RANGES_V3_VIEW_LINEAR_DISTRIBUTE_HPP$/;"	d
RANGES_V3_VIEW_MAP_HPP	include/range/v3/view/map.hpp	/^#define RANGES_V3_VIEW_MAP_HPP$/;"	d
RANGES_V3_VIEW_MOVE_HPP	include/range/v3/view/move.hpp	/^#define RANGES_V3_VIEW_MOVE_HPP$/;"	d
RANGES_V3_VIEW_PARTIAL_SUM_HPP	include/range/v3/view/partial_sum.hpp	/^#define RANGES_V3_VIEW_PARTIAL_SUM_HPP$/;"	d
RANGES_V3_VIEW_REF_HPP	include/range/v3/view/ref.hpp	/^#define RANGES_V3_VIEW_REF_HPP$/;"	d
RANGES_V3_VIEW_REMOVE_HPP	include/range/v3/view/remove.hpp	/^#define RANGES_V3_VIEW_REMOVE_HPP$/;"	d
RANGES_V3_VIEW_REMOVE_IF_HPP	include/range/v3/view/remove_if.hpp	/^#define RANGES_V3_VIEW_REMOVE_IF_HPP$/;"	d
RANGES_V3_VIEW_REPEAT_HPP	include/range/v3/view/repeat.hpp	/^#define RANGES_V3_VIEW_REPEAT_HPP$/;"	d
RANGES_V3_VIEW_REPEAT_N_HPP	include/range/v3/view/repeat_n.hpp	/^#define RANGES_V3_VIEW_REPEAT_N_HPP$/;"	d
RANGES_V3_VIEW_REPLACE_HPP	include/range/v3/view/replace.hpp	/^#define RANGES_V3_VIEW_REPLACE_HPP$/;"	d
RANGES_V3_VIEW_REPLACE_IF_HPP	include/range/v3/view/replace_if.hpp	/^#define RANGES_V3_VIEW_REPLACE_IF_HPP$/;"	d
RANGES_V3_VIEW_REVERSE_HPP	include/range/v3/view/reverse.hpp	/^#define RANGES_V3_VIEW_REVERSE_HPP$/;"	d
RANGES_V3_VIEW_SAMPLE_HPP	include/range/v3/view/sample.hpp	/^#define RANGES_V3_VIEW_SAMPLE_HPP$/;"	d
RANGES_V3_VIEW_SET_ALGORITHM_HPP	include/range/v3/view/set_algorithm.hpp	/^#define RANGES_V3_VIEW_SET_ALGORITHM_HPP$/;"	d
RANGES_V3_VIEW_SINGLE_HPP	include/range/v3/view/single.hpp	/^#define RANGES_V3_VIEW_SINGLE_HPP$/;"	d
RANGES_V3_VIEW_SLICE_HPP	include/range/v3/view/slice.hpp	/^#define RANGES_V3_VIEW_SLICE_HPP$/;"	d
RANGES_V3_VIEW_SLIDING_HPP	include/range/v3/view/sliding.hpp	/^#define RANGES_V3_VIEW_SLIDING_HPP$/;"	d
RANGES_V3_VIEW_SPAN_HPP	include/range/v3/view/span.hpp	/^#define RANGES_V3_VIEW_SPAN_HPP$/;"	d
RANGES_V3_VIEW_SPLIT_HPP	include/range/v3/view/split.hpp	/^#define RANGES_V3_VIEW_SPLIT_HPP$/;"	d
RANGES_V3_VIEW_SPLIT_WHEN_HPP	include/range/v3/view/split_when.hpp	/^#define RANGES_V3_VIEW_SPLIT_WHEN_HPP$/;"	d
RANGES_V3_VIEW_STRIDE_HPP	include/range/v3/view/stride.hpp	/^#define RANGES_V3_VIEW_STRIDE_HPP$/;"	d
RANGES_V3_VIEW_SUBRANGE_HPP	include/range/v3/view/subrange.hpp	/^#define RANGES_V3_VIEW_SUBRANGE_HPP$/;"	d
RANGES_V3_VIEW_TAIL_HPP	include/range/v3/view/tail.hpp	/^#define RANGES_V3_VIEW_TAIL_HPP$/;"	d
RANGES_V3_VIEW_TAKE_EXACTLY_HPP	include/range/v3/view/take_exactly.hpp	/^#define RANGES_V3_VIEW_TAKE_EXACTLY_HPP$/;"	d
RANGES_V3_VIEW_TAKE_HPP	include/range/v3/view/take.hpp	/^#define RANGES_V3_VIEW_TAKE_HPP$/;"	d
RANGES_V3_VIEW_TAKE_LAST_HPP	include/range/v3/view/take_last.hpp	/^#define RANGES_V3_VIEW_TAKE_LAST_HPP$/;"	d
RANGES_V3_VIEW_TAKE_WHILE_HPP	include/range/v3/view/take_while.hpp	/^#define RANGES_V3_VIEW_TAKE_WHILE_HPP$/;"	d
RANGES_V3_VIEW_TOKENIZE_HPP	include/range/v3/view/tokenize.hpp	/^#define RANGES_V3_VIEW_TOKENIZE_HPP$/;"	d
RANGES_V3_VIEW_TRANSFORM_HPP	include/range/v3/view/transform.hpp	/^#define RANGES_V3_VIEW_TRANSFORM_HPP$/;"	d
RANGES_V3_VIEW_TRIM_HPP	include/range/v3/view/trim.hpp	/^#define RANGES_V3_VIEW_TRIM_HPP$/;"	d
RANGES_V3_VIEW_UNBOUNDED_HPP	include/range/v3/view/unbounded.hpp	/^#define RANGES_V3_VIEW_UNBOUNDED_HPP$/;"	d
RANGES_V3_VIEW_UNIQUE_HPP	include/range/v3/view/unique.hpp	/^#define RANGES_V3_VIEW_UNIQUE_HPP$/;"	d
RANGES_V3_VIEW_VIEW_HPP	include/range/v3/view/view.hpp	/^#define RANGES_V3_VIEW_VIEW_HPP$/;"	d
RANGES_V3_VIEW_ZIP_HPP	include/range/v3/view/zip.hpp	/^#define RANGES_V3_VIEW_ZIP_HPP$/;"	d
RANGES_V3_VIEW_ZIP_WITH_HPP	include/range/v3/view/zip_with.hpp	/^#define RANGES_V3_VIEW_ZIP_WITH_HPP$/;"	d
RANGES_WORKAROUND_CLANG_23135	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_CLANG_23135 /;"	d
RANGES_WORKAROUND_CLANG_43400	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_CLANG_43400 /;"	d
RANGES_WORKAROUND_CWG_1554	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_CWG_1554$/;"	d
RANGES_WORKAROUND_GCC_89953	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_GCC_89953 /;"	d
RANGES_WORKAROUND_GCC_91525	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_GCC_91525 /;"	d
RANGES_WORKAROUND_GCC_91923	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_GCC_91923 /;"	d
RANGES_WORKAROUND_GCC_UNFILED0	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_GCC_UNFILED0 /;"	d
RANGES_WORKAROUND_MSVC_249830	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_249830 /;"	d
RANGES_WORKAROUND_MSVC_573728	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_573728 /;"	d
RANGES_WORKAROUND_MSVC_677925	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_677925 /;"	d
RANGES_WORKAROUND_MSVC_683388	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_683388 /;"	d
RANGES_WORKAROUND_MSVC_688606	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_688606 /;"	d
RANGES_WORKAROUND_MSVC_701385	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_701385 /;"	d
RANGES_WORKAROUND_MSVC_756601	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_756601 /;"	d
RANGES_WORKAROUND_MSVC_779708	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_779708 /;"	d
RANGES_WORKAROUND_MSVC_785522	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_785522 /;"	d
RANGES_WORKAROUND_MSVC_786312	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_786312 /;"	d
RANGES_WORKAROUND_MSVC_786376	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_786376 /;"	d
RANGES_WORKAROUND_MSVC_787074	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_787074 /;"	d
RANGES_WORKAROUND_MSVC_790554	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_790554 /;"	d
RANGES_WORKAROUND_MSVC_792338	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_792338 /;"	d
RANGES_WORKAROUND_MSVC_793042	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_793042 /;"	d
RANGES_WORKAROUND_MSVC_835948	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_835948 /;"	d
RANGES_WORKAROUND_MSVC_895622	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_895622 /;"	d
RANGES_WORKAROUND_MSVC_934264	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_934264 /;"	d
RANGES_WORKAROUND_MSVC_934330	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_934330 /;"	d
RANGES_WORKAROUND_MSVC_OLD_LAMBDA	include/range/v3/detail/config.hpp	/^#define RANGES_WORKAROUND_MSVC_OLD_LAMBDA$/;"	d
RANGE_V3_DETAIL_BIND_BACK_HPP	include/range/v3/functional/bind_back.hpp	/^#define RANGE_V3_DETAIL_BIND_BACK_HPP$/;"	d
RANGE_V3_MAJOR	include/range/v3/version.hpp	/^#define RANGE_V3_MAJOR /;"	d
RANGE_V3_MINOR	include/range/v3/version.hpp	/^#define RANGE_V3_MINOR /;"	d
RANGE_V3_PATCHLEVEL	include/range/v3/version.hpp	/^#define RANGE_V3_PATCHLEVEL /;"	d
RANGE_V3_VERSION	include/range/v3/version.hpp	/^#define RANGE_V3_VERSION /;"	d
RANGE_V3_VIEW_EXCLUSIVE_SCAN_HPP	include/range/v3/view/exclusive_scan.hpp	/^#define RANGE_V3_VIEW_EXCLUSIVE_SCAN_HPP$/;"	d
RBi	include/range/v3/algorithm/inplace_merge.hpp	/^                    using RBi = ranges::reverse_iterator<I>;$/;"	t	function:ranges::detail::merge_adaptive_fn::impl	typeref:typename:ranges::reverse_iterator<I>
Ref	include/git.hpp	/^using Ref = nt::NamedType<int, struct RefTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<int,struct RefTag>
Rng	include/range/v3/view/join.hpp	/^                      store_inner_<range_reference_t<Rng>>, pass_thru_inner_>;$/;"	t	namespace:ranges::detail	typeref:typename:if_then_t<!std::is_reference<range_reference_t<Rng>> store_inner_<range_reference_t<>>
Rngs	example/calendar.cpp	/^        using Rngs = decltype(rngs);$/;"	t	function:interleave::__anona13a41ab0602	file:
Rngs	example/calendar.cpp	/^        using Rngs = decltype(rngs);$/;"	t	function:transpose::__anona13a41ab0702	file:
Rv	include/range/v3/algorithm/inplace_merge.hpp	/^                    using Rv = ranges::reverse_iterator<iter_value_t<I> *>;$/;"	t	function:ranges::detail::merge_adaptive_fn::impl	typeref:typename:ranges::reverse_iterator<iter_value_t<I> * >
S	include/range/v3/action/stride.hpp	/^                using S = sentinel_t<Rng>;$/;"	t	function:ranges::actions::stride_fn::operator ()	typeref:typename:sentinel_t<Rng>
S	include/range/v3/view/cartesian_product.hpp	/^                using S = common_type_t<Size, range_size_t<Rng>>;$/;"	t	function:ranges::detail::cartesian_size_fn::operator ()	typeref:typename:common_type_t<Size,range_size_t<Rng>>
S	include/range/v3/view/enumerate.hpp	/^                using S = detail::iter_size_t<iterator_t<Rng>>;$/;"	t	function:ranges::views::enumerate_fn::CPP_fun	typeref:typename:detail::iter_size_t<iterator_t<Rng>>
S	test/p.cpp	/^  S() noexcept { puts("S()"); }$/;"	f	struct:S	file:
S	test/p.cpp	/^  S(S &&) noexcept { puts("S(S &&)"); }$/;"	f	struct:S	file:
S	test/p.cpp	/^  S(S const &) noexcept { puts("S(const S &)"); }$/;"	f	struct:S	file:
S	test/p.cpp	/^struct S {$/;"	s	file:
SECOND	include/range/v3/view/set_algorithm.hpp	/^                SECOND$/;"	e	enum:ranges::detail::set_union_cursor::state_t
SECOND	include/range/v3/view/set_algorithm.hpp	/^                SECOND,$/;"	e	enum:ranges::detail::set_symmetric_difference_cursor::state_t
SInt	include/range/v3/range/access.hpp	/^                using SInt = iter_diff_t<Int>;$/;"	t	function:ranges::_end_::fn::operator -	typeref:typename:iter_diff_t<Int>
Seeder	include/range/v3/utility/random.hpp	/^            using Seeder = meta::if_c<(sizeof(default_URNG) > 16),$/;"	t	function:ranges::detail::get_random_engine
Subtractable	include/ntskills.hpp	/^template <typename T> struct Subtractable : crtp<T, Subtractable> {$/;"	s	namespace:nt
T	include/range/v3/algorithm/aux_/merge_n.hpp	/^                using T = merge_n_result<I0, I1, O>;$/;"	t	function:ranges::aux::merge_n_fn::operator ()	typeref:typename:merge_n_result<I0,I1,O>
T	include/range/v3/functional/bind_back.hpp	/^            using T = typename detail::bind_back_fn<Fn, Arg1, Args...>::tuple_t;$/;"	t	function:ranges::bind_back_fn::operator ()	typeref:typename:detail::bind_back_fn<Fn,Arg1,Args...>::tuple_t
TagId	include/git.hpp	/^using TagId = nt::NamedType<std::string, struct TagIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct TagIdTag>
To	include/range/v3/detail/variant.hpp	/^        using To = variant_unique_t<From>;$/;"	t	function:ranges::unique_variant	typeref:typename:variant_unique_t<From>
TreeBark	include/git.hpp	/^  TreeBark(const UPtr<git_repository> &rhs) : repo(rhs) {}$/;"	f	struct:git::TreeBark
TreeBark	include/git.hpp	/^struct TreeBark {$/;"	s	namespace:git
TreeId	include/git.hpp	/^using TreeId = nt::NamedType<std::string, struct TreeIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct TreeIdTag>
UNDERLYING_FUNCTIONALITIES_HPP	include/ntskills.hpp	/^#define UNDERLYING_FUNCTIONALITIES_HPP$/;"	d
UPtr	include/git.hpp	/^template <typename T> using UPtr = std::unique_ptr<T, void (*)(T *)>;$/;"	t	namespace:git
UPtr	test/oset.cpp	/^template <typename T> using UPtr = std::unique_ptr<T, void (*)(T *)>;$/;"	t	file:
UnderlyingType	include/nt.hpp	/^  using UnderlyingType = T;$/;"	t	class:nt::NamedType	typeref:typename:T
V	include/range/v3/algorithm/stable_sort.hpp	/^            using V = iter_value_t<I>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:iter_value_t<I>
V	include/range/v3/numeric/adjacent_difference.hpp	/^            using V = iter_value_t<I>;$/;"	t	function:ranges::adjacent_difference_fn::operator ()	typeref:typename:iter_value_t<I>
V	include/range/v3/view/adaptor.hpp	/^            using V = range_access::cursor_value_t<adaptor_cursor>;$/;"	t	function:ranges::adaptor_cursor::iter_move_	typeref:typename:range_access::cursor_value_t<adaptor_cursor>
V	include/range/v3/view/adaptor.hpp	/^            using V = range_access::cursor_value_t<adaptor_cursor>;$/;"	t	function:ranges::adaptor_cursor::read	typeref:typename:range_access::cursor_value_t<adaptor_cursor>
ValueType	include/range/v3/range/conversion.hpp	/^            using ValueType = range_value_t<Cont>;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:range_value_t<Cont>
View0	include/range/v3/view/cartesian_product.hpp	/^                using View0 = meta::at_c<meta::list<constify_if<Views>...>, 0>;$/;"	t	function:ranges::cartesian_product_view::cursor::cursor	typeref:typename:meta::at_c<meta::list<constify_if<Views>...>,0>
X	include/range/v3/numeric/adjacent_difference.hpp	/^            using X = invoke_result_t<P &, V>;$/;"	t	function:ranges::adjacent_difference_fn::operator ()	typeref:typename:invoke_result_t<P &,V>
X	include/range/v3/numeric/partial_sum.hpp	/^            using X = projected<projected<I, detail::as_value_type_t<I>>, P>;$/;"	t	function:ranges::partial_sum_fn::operator ()	typeref:typename:projected<projected<I,detail::as_value_type_t<I>>,P>
XSHIFT	include/range/v3/utility/random.hpp	/^                static constexpr std::uint32_t XSHIFT = sizeof(IntRep) * 8 \/ 2;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::uint32_t
__anon139f36490102	test/git.cpp	/^  auto f = lr::fmap{[](git_oid &&) { return 1; }};$/;"	f	function:git::commit	file:
__anon1cbd4b800102	example/for_each_assoc.cpp	/^auto print = [](int i) { cout << i << ' '; };$/;"	f	file:
__anon1cbd4b800202	example/for_each_assoc.cpp	/^auto printm = [](std::pair<string, int> p) {$/;"	f	file:
__anon2f64190e0102	include/range/v3/view/sample.hpp	/^                                                        URNG &> {$/;"	f	function:ranges::views::sample_fn::CPP_fun	typeref:typename:invoke_result_t<sample_base_fn,decltype (rng),range_difference_t<decltype (rng)>,URNG &>	file:
__anon320e76b20102	include/git.hpp	/^             | lr::fmap([](auto) { return LR<git_oid>(lr::L{"9"}); });$/;"	f	function:git::TreeBark::operator ()	file:
__anon34c545170102	include/union.hpp	/^    return pith([&o, &firstrun](auto &&... x) {$/;"	f	function:abo::union_fn::operator ()	file:
__anon387ca4c40102	include/range/v3/view/concat.hpp	/^                                [](auto && r) -> size_type { return ranges::size(r); }),$/;"	f	function:ranges::concat_view::CPP_fun	typeref:typename:size_type	file:
__anon387ca4c40202	include/range/v3/view/concat.hpp	/^                                [](auto && r) -> size_type { return ranges::size(r); }),$/;"	f	function:ranges::concat_view::CPP_fun	typeref:typename:size_type	file:
__anon43832ae80102	example/count_if.cpp	/^auto is_six = [](int i) -> bool { return i == 6; };$/;"	f	typeref:typename:bool	file:
__anon43c0a4320102	example/accumulate_ints.cpp	/^    int sum = accumulate(views::ints(1, unreachable) | views::transform([](int i) {$/;"	f	function:main	file:
__anon4bdf6c420110	include/range/v3/range/dangling.hpp	/^    {$/;"	n	namespace:ranges
__anon4da570f90110	include/range/v3/detail/variant.hpp	/^    {$/;"	n	namespace:ranges
__anon4da570f9020a	include/range/v3/detail/variant.hpp	/^                {$/;"	u	struct:ranges::detail::variant_data_::type
__anon4da570f9030a	include/range/v3/detail/variant.hpp	/^                {$/;"	u	struct:ranges::detail::variant_data_::type
__anon577c80ba010a	include/range/v3/utility/variant.hpp	/^            {$/;"	u	struct:ranges::detail::indexed_datum
__anon577c80ba0202	include/range/v3/utility/variant.hpp	/^            {$/;"	f	struct:ranges::detail::indexed_datum	file:
__anon577c80ba0302	include/range/v3/utility/variant.hpp	/^            {$/;"	f	struct:ranges::detail::indexed_datum	file:
__anon580d16000102	example/for_each_sequence.cpp	/^auto print = [](int i) { cout << i << ' '; };$/;"	f	file:
__anon5b3ef2ec0102	include/lr.hpp	/^          overloaded{[](L &&l) { return R(std::forward<L>(l)); },$/;"	f	struct:lr::fmap	file:
__anon5b3ef2ec0202	include/lr.hpp	/^                     [&](auto &&a) { return f(std::forward<decltype(a)>(a)); }},$/;"	f	struct:lr::fmap	file:
__anon5b3ef2ec0302	include/lr.hpp	/^              [](L &&l) { return LR<R>(std::forward<L>(l)); },$/;"	f	struct:lr::fmap	file:
__anon5b3ef2ec0402	include/lr.hpp	/^              [&](auto &&a) { return LR<R>(f(std::forward<decltype(a)>(a))); }},$/;"	f	struct:lr::fmap	file:
__anon6819ef1a0102	include/range/v3/view/zip_with.hpp	/^                                   [](bool a, bool b) { return a || b; });$/;"	f	function:ranges::iter_zip_with_view::cursor::equal	file:
__anon6819ef1a0202	include/range/v3/view/zip_with.hpp	/^                                   [](bool a, bool b) { return a || b; });$/;"	f	function:ranges::iter_zip_with_view::cursor::equal	file:
__anon6819ef1a0302	include/range/v3/view/zip_with.hpp	/^                                                     [](auto && r) -> size_type {$/;"	f	function:ranges::iter_zip_with_view::CPP_fun	typeref:typename:size_type	file:
__anon6e3cd5350110	include/range/v3/view/common.hpp	/^        {$/;"	n	namespace:ranges::views
__anon8151448d0110	include/range/v3/action/action.hpp	/^        {$/;"	n	namespace:ranges::actions
__anon8c726b6b0110	include/range/v3/utility/optional.hpp	/^    {$/;"	n	namespace:ranges
__anon8c726b6b020a	include/range/v3/utility/optional.hpp	/^                {$/;"	u	struct:ranges::detail::optional_adl::optional_storage
__anon8c726b6b030a	include/range/v3/utility/optional.hpp	/^                {$/;"	u	struct:ranges::detail::optional_adl::optional_storage
__anon8d9c7e340102	example/any_all_none_of.cpp	/^auto is_six = [](int i) { return i == 6; };$/;"	f	file:
__anon8f48c67e0102	example/comprehensions.cpp	/^  auto triples = views::iota(1) >>= [](int z) {$/;"	f	function:main	file:
__anon8f48c67e0202	example/comprehensions.cpp	/^    return views::iota(1, z + 1) >>= [=](int x) {$/;"	f	function:main::__anon8f48c67e0102	file:
__anon8f48c67e0302	example/comprehensions.cpp	/^      return views::iota(x, z + 1) >>= [=](int y) {$/;"	f	function:main::__anon8f48c67e0102::__anon8f48c67e0202	file:
__anon8f48c67e0402	example/comprehensions.cpp	/^  auto triples = views::for_each(views::iota(1), [](int z) {$/;"	f	function:benchmark	file:
__anon8f48c67e0502	example/comprehensions.cpp	/^    return views::for_each(views::iota(1, z + 1), [=](int x) {$/;"	f	function:benchmark::__anon8f48c67e0402	file:
__anon8f48c67e0602	example/comprehensions.cpp	/^      return views::for_each(views::iota(x, z + 1), [=](int y) {$/;"	f	function:benchmark::__anon8f48c67e0402::__anon8f48c67e0502	file:
__anon932a87a70110	include/range/v3/view/view.hpp	/^        {$/;"	n	namespace:ranges::views
__anon93ff310a0102	test/main.cpp	/^            lr::fmap([](const git::UPtr<git_repository> &repo) {$/;"	f	function:main	file:
__anon93ff310a0202	test/main.cpp	/^              return bark([&repo](const TreeBark::O &) {$/;"	f	function:main::__anon93ff310a0102	file:
__anon93ff310a0302	test/main.cpp	/^                       lr::fmap([&](const auto &id) {$/;"	f	function:main::__anon93ff310a0102::__anon93ff310a0202	file:
__anon93ff310a0402	test/main.cpp	/^                       lr::fmap([](const auto &pTree) {$/;"	f	function:main::__anon93ff310a0102::__anon93ff310a0202	file:
__anon93ff310a0502	test/main.cpp	/^            | lr::fmap([](auto &&a) { return a; });$/;"	f	function:main	file:
__anon93ff310a0602	test/main.cpp	/^                 [](lr::L &&l) { std::cout << "L: " << l.message; },$/;"	f	function:main	file:
__anon93ff310a0702	test/main.cpp	/^                 [](git_oid &&l) { std::cout << "R: " << git_oid_tostr_s(&l); },$/;"	f	function:main	file:
__anona13a41ab0102	example/calendar.cpp	/^        [](date a, date b) { return a.month() == b.month(); });$/;"	f	function:by_month	file:
__anona13a41ab0202	example/calendar.cpp	/^    return views::group_by([](date a, date b) {$/;"	f	function:by_week	file:
__anona13a41ab0302	example/calendar.cpp	/^    return views::transform([](\/*range<date>*\/ auto week) {$/;"	f	function:format_weeks	file:
__anona13a41ab0402	example/calendar.cpp	/^    return views::transform([](\/*range<date>*\/ auto month) {$/;"	f	function:layout_months	file:
__anona13a41ab0502	example/calendar.cpp	/^            for_each(its_, [](auto &it) { ++it; });$/;"	f	function:interleave_view::cursor::next	file:
__anona13a41ab0602	example/calendar.cpp	/^    return make_view_closure([](auto &&rngs) {$/;"	f	function:interleave	file:
__anona13a41ab0702	example/calendar.cpp	/^    return make_view_closure([](auto &&rngs) {$/;"	f	function:transpose	file:
__anona13a41ab0802	example/calendar.cpp	/^        [](\/*range<range<string>>*\/ auto rng) { return rng | transpose(); });$/;"	f	function:transpose_months	file:
__anona13a41ab0902	example/calendar.cpp	/^        [](\/*range<string>*\/ auto rng) { return actions::join(rng); });$/;"	f	function:join_months	file:
__anonb12134b20102	example/filter_transform.cpp	/^    auto rng = vi | views::filter([](int i) { return i % 2 == 0; }) |$/;"	f	function:main	file:
__anonb12134b20202	example/filter_transform.cpp	/^               views::transform([](int i) { return std::to_string(i); });$/;"	f	function:main	file:
__anonbc46ca120102	example/find.cpp	/^auto is_six = [](int i) -> bool { return i == 6; };$/;"	f	typeref:typename:bool	file:
__anoncd3310e00102	test/oset.cpp	/^      [c, d, args = std::tuple{std::forward<Args>(args)...}](auto o) {$/;"	f	function:makeuptr	file:
__anoncd3310e00202	test/oset.cpp	/^  return union_fn{[c, args = std::tuple{std::forward<Args>(args)...}](auto o) {$/;"	f	function:run	file:
__anoncd3310e00302	test/oset.cpp	/^  constexpr static auto left = []() {$/;"	f	function:main	file:
__anoncd3310e00402	test/oset.cpp	/^    return [](int, std::string s) { std::cout << s << '\\n'; };$/;"	f	function:main::__anoncd3310e00302	file:
__anoncd3310e00502	test/oset.cpp	/^  oid(overloaded{left(), [](auto x) { std::cout << pf(x) << '\\n'; }});$/;"	f	function:main	file:
__anoncd3310e00602	test/oset.cpp	/^  union_fn{[](auto o) {$/;"	f	function:main	file:
__anoncd3310e00702	test/oset.cpp	/^        left(), [&](UPtr<git_repository> &&repo) {$/;"	f	function:main::__anoncd3310e00602	file:
__anoncd3310e00802	test/oset.cpp	/^      [](float) {},$/;"	f	function:main	file:
__anoncd3310e00902	test/oset.cpp	/^      [](int i, std::string &&m) { std::cout << i << ' ' << m << '\\n'; },$/;"	f	function:main	file:
__anoncd3310e00a02	test/oset.cpp	/^      [](int) {}, [](const char *) {}});$/;"	f	function:main	file:
__anoncd3310e00b02	test/oset.cpp	/^      [](int) {}, [](const char *) {}});$/;"	f	function:main	file:
__anond12401700102	example/comprehension_conversion.cpp	/^                              [](int i) { return yield_from(views::repeat_n(i, i)); }) |$/;"	f	function:main	file:
__anone8c48cc60102	include/range/v3/utility/random.hpp	/^                ranges::generate(seeds, [&] { return dist(rd); });$/;"	f	function:ranges::detail::randutils::get_entropy	file:
__anone8c48cc60202	include/range/v3/utility/random.hpp	/^                    auto hash = [&](IntRep value) RANGES_INTENDED_MODULAR_ARITHMETIC {$/;"	f	function:ranges::detail::randutils::seed_seq_fe::mix_entropy	file:
__anone8c48cc60302	include/range/v3/utility/random.hpp	/^                    auto mix = [](IntRep x, IntRep y) RANGES_INTENDED_MODULAR_ARITHMETIC {$/;"	f	function:ranges::detail::randutils::seed_seq_fe::mix_entropy	file:
__anonf59fc86d010a	include/range/v3/utility/semiregular_box.hpp	/^        {$/;"	u	struct:ranges::semiregular_box
__anonfa4158250102	example/hello.cpp	/^    ranges::for_each(s, [](char c) { cout << c << ' '; });$/;"	f	function:main	file:
__gnu_debug	include/range/v3/iterator/concepts.hpp	/^namespace __gnu_debug$/;"	n
_adl_get_	include/range/v3/detail/adl_get.hpp	/^        namespace _adl_get_$/;"	n	namespace:ranges::detail
_advance_	include/range/v3/view/zip_with.hpp	/^        struct _advance_$/;"	s	namespace:ranges::detail
_any_	include/range/v3/utility/any.hpp	/^    namespace _any_$/;"	n	namespace:ranges
_basic_common_reference	include/concepts/type_traits.hpp	/^        using _basic_common_reference =$/;"	t	namespace:concepts::detail	typeref:typename:basic_common_reference<remove_cvref_t<T>,remove_cvref_t<U>,_xref<T>::template invoke,_xref<U>::template invoke>
_basic_iterator_	include/range/v3/iterator/basic_iterator.hpp	/^    namespace _basic_iterator_$/;"	n
_begin_	include/range/v3/range/access.hpp	/^    namespace _begin_$/;"	n	namespace:ranges
_builtin_common	include/concepts/type_traits.hpp	/^        struct _builtin_common$/;"	s	namespace:concepts::detail
_builtin_common	include/concepts/type_traits.hpp	/^        struct _builtin_common<T &&, U &&>$/;"	s	namespace:concepts::detail
_builtin_common	include/concepts/type_traits.hpp	/^        struct _builtin_common<T &&, U &>$/;"	s	namespace:concepts::detail
_builtin_common	include/concepts/type_traits.hpp	/^        struct _builtin_common<T &, U &&>$/;"	s	namespace:concepts::detail
_builtin_common	include/concepts/type_traits.hpp	/^        struct _builtin_common<T &, U &>$/;"	s	namespace:concepts::detail
_builtin_common_2	include/concepts/type_traits.hpp	/^        struct _builtin_common_2$/;"	s	namespace:concepts::detail
_builtin_common_3	include/concepts/type_traits.hpp	/^        struct _builtin_common_3$/;"	s	namespace:concepts::detail
_builtin_common_lr	include/concepts/type_traits.hpp	/^        struct _builtin_common_lr$/;"	s	namespace:concepts::detail
_builtin_common_rr	include/concepts/type_traits.hpp	/^        struct _builtin_common_rr$/;"	s	namespace:concepts::detail
_builtin_common_t	include/concepts/type_traits.hpp	/^        using _builtin_common_t = meta::_t<_builtin_common<T, U>>;$/;"	t	namespace:concepts::detail	typeref:typename:meta::_t<_builtin_common<T,U>>
_cbegin_	include/range/v3/range/access.hpp	/^    namespace _cbegin_$/;"	n	namespace:ranges
_cdata_	include/range/v3/range/primitives.hpp	/^    namespace _cdata_$/;"	n	namespace:ranges
_cend_	include/range/v3/range/access.hpp	/^    namespace _cend_$/;"	n	namespace:ranges
_check	include/range/v3/iterator/diffmax_t.hpp	/^            constexpr void _check()$/;"	f	struct:ranges::detail::diffmax_t	typeref:typename:void
_common_iterator_	include/range/v3/iterator/common_iterator.hpp	/^    namespace _common_iterator_$/;"	n	namespace:ranges
_common_reference2	include/concepts/type_traits.hpp	/^        struct _common_reference2$/;"	s	namespace:concepts::detail
_cond_res	include/concepts/type_traits.hpp	/^        using _cond_res = decltype(true ? std::declval<T>() : std::declval<U>());$/;"	t	namespace:concepts::detail
_copy_cv	include/concepts/type_traits.hpp	/^        using _copy_cv = meta::_t<_copy_cv_<From, To>>;$/;"	t	namespace:concepts::detail	typeref:typename:meta::_t<_copy_cv_<From,To>>
_copy_cv_	include/concepts/type_traits.hpp	/^        struct _copy_cv_$/;"	s	namespace:concepts::detail
_copy_cv_	include/concepts/type_traits.hpp	/^        struct _copy_cv_<From const volatile, To>$/;"	s	namespace:concepts::detail
_copy_cv_	include/concepts/type_traits.hpp	/^        struct _copy_cv_<From const, To>$/;"	s	namespace:concepts::detail
_copy_cv_	include/concepts/type_traits.hpp	/^        struct _copy_cv_<From volatile, To>$/;"	s	namespace:concepts::detail
_counted_iterator_	include/range/v3/iterator/counted_iterator.hpp	/^    namespace _counted_iterator_$/;"	n	namespace:ranges
_crbegin_	include/range/v3/range/access.hpp	/^    namespace _crbegin_$/;"	n	namespace:ranges
_crend_	include/range/v3/range/access.hpp	/^    namespace _crend_$/;"	n	namespace:ranges
_data_	include/range/v3/range/primitives.hpp	/^    namespace _data_$/;"	n	namespace:ranges
_emplaced_index_t_	include/range/v3/detail/variant.hpp	/^    using _emplaced_index_t_ = emplaced_index_t<I> (&)();$/;"	t	namespace:ranges
_empty_	include/range/v3/range/primitives.hpp	/^    namespace _empty_$/;"	n	namespace:ranges
_end_	include/range/v3/range/access.hpp	/^    namespace _end_$/;"	n	namespace:ranges
_get_	include/range/v3/utility/box.hpp	/^    namespace _get_$/;"	n	namespace:ranges
_get_	include/range/v3/utility/get.hpp	/^    namespace _get_$/;"	n	namespace:ranges
_invoke_result_	include/range/v3/functional/invoke.hpp	/^        struct _invoke_result_$/;"	s	namespace:ranges::detail
_invoke_result_	include/range/v3/functional/invoke.hpp	/^        struct _invoke_result_<$/;"	s	namespace:ranges::detail
_is_integer_like_	include/range/v3/iterator/concepts.hpp	/^        RANGES_INLINE_VAR constexpr bool _is_integer_like_ = std::is_integral<D>::value;$/;"	v	namespace:ranges::detail	typeref:typename:RANGES_INLINE_VAR bool
_istream_	include/range/v3/view/istream.hpp	/^    namespace _istream_$/;"	n	namespace:ranges
_iter_move_	include/range/v3/iterator/access.hpp	/^    namespace _iter_move_$/;"	n	namespace:ranges
_iter_swap_	include/range/v3/iterator/access.hpp	/^    namespace _iter_swap_$/;"	n	namespace:ranges
_iterator_range_	include/range/v3/iterator_range.hpp	/^    namespace _iterator_range_$/;"	n	namespace:ranges
_lref	include/concepts/type_traits.hpp	/^        using _lref =$/;"	t	namespace:concepts::detail	typeref:typename:meta::quote_trait<std::add_lvalue_reference>
_max_	include/range/v3/view/zip_with.hpp	/^        struct _max_$/;"	s	namespace:ranges::detail
_min_	include/range/v3/view/zip_with.hpp	/^        struct _min_$/;"	s	namespace:ranges::detail
_normalize	include/range/v3/iterator/diffmax_t.hpp	/^            static constexpr diffmax_t _normalize(bool neg, std::uintmax_t val)$/;"	f	struct:ranges::detail::diffmax_t	typeref:typename:diffmax_t
_nullptr_v	include/meta/meta.hpp	/^        constexpr T *_nullptr_v()$/;"	f	namespace:meta::detail	typeref:typename:T *
_nullptr_v	include/range/v3/utility/nullptr_v.hpp	/^    constexpr T * _nullptr_v()$/;"	f	namespace:ranges	typeref:typename:T *
_rbegin_	include/range/v3/range/access.hpp	/^    namespace _rbegin_$/;"	n	namespace:ranges
_ref_view_	include/range/v3/view/ref.hpp	/^    namespace _ref_view_$/;"	n	namespace:ranges
_rend_	include/range/v3/range/access.hpp	/^    namespace _rend_$/;"	n	namespace:ranges
_rref	include/concepts/type_traits.hpp	/^        using _rref =$/;"	t	namespace:concepts::detail	typeref:typename:meta::quote_trait<std::add_rvalue_reference>
_sanitize_fn	include/range/v3/range/dangling.hpp	/^    struct _sanitize_fn$/;"	s	namespace:ranges
_size_	include/range/v3/range/primitives.hpp	/^    namespace _size_$/;"	n	namespace:ranges
_subrange_	include/range/v3/view/subrange.hpp	/^    namespace _subrange_$/;"	n	namespace:ranges
_t	include/meta/meta.hpp	/^        using _t = defer<_t, T>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<_t,T>
_t	include/meta/meta.hpp	/^    using _t = typename T::type;$/;"	t	namespace:meta	typeref:typename:T::type
_t	include/range/v3/range/access.hpp	/^        using _t = decltype(fn{}(std::declval<R>()));$/;"	t	namespace:ranges::_begin_
_t	include/range/v3/range/access.hpp	/^        using _t = decltype(fn{}(std::declval<R>()));$/;"	t	namespace:ranges::_end_
_t	include/range/v3/range/access.hpp	/^        using _t = decltype(fn{}(std::declval<R>()));$/;"	t	namespace:ranges::_rbegin_
_t	include/range/v3/range/access.hpp	/^        using _t = decltype(fn{}(std::declval<R>()));$/;"	t	namespace:ranges::_rend_
_t	include/range/v3/range/primitives.hpp	/^        using _t = decltype(fn{}(std::declval<R>()));$/;"	t	namespace:ranges::_data_
_tagged_	include/range/v3/utility/tagged_pair.hpp	/^    namespace _tagged_$/;"	n	namespace:ranges
_to_	include/range/v3/range/conversion.hpp	/^    namespace _to_$/;"	n	namespace:ranges
_tuple_wrapper_	include/range/v3/detail/adl_get.hpp	/^    namespace _tuple_wrapper_$/;"	n	namespace:ranges
_v	include/meta/meta.hpp	/^    constexpr typename T::type::value_type _v = T::type::value;$/;"	v	namespace:meta	typeref:typename:T::type::value_type
_xref	include/concepts/type_traits.hpp	/^        struct _xref$/;"	s	namespace:concepts::detail
_xref	include/concepts/type_traits.hpp	/^        struct _xref<T &&>$/;"	s	namespace:concepts::detail
_xref	include/concepts/type_traits.hpp	/^        struct _xref<T &>$/;"	s	namespace:concepts::detail
_xref	include/concepts/type_traits.hpp	/^        struct _xref<T const volatile>$/;"	s	namespace:concepts::detail
_xref	include/concepts/type_traits.hpp	/^        struct _xref<T const>$/;"	s	namespace:concepts::detail
_xref	include/concepts/type_traits.hpp	/^        struct _xref<T volatile>$/;"	s	namespace:concepts::detail
abo	include/git_.hpp	/^namespace abo {$/;"	n
abo	include/newtype.hpp	/^namespace abo::nt {$/;"	n
abo	include/union.hpp	/^namespace abo {$/;"	n
access	include/range/v3/iterator/counted_iterator.hpp	/^        struct access$/;"	s	namespace:ranges::_counted_iterator_
accumulate_fn	include/range/v3/numeric/accumulate.hpp	/^    struct accumulate_fn$/;"	s	namespace:ranges
act_	include/range/v3/action/action.hpp	/^            Action act_;$/;"	m	struct:ranges::actions::old_action_	typeref:typename:Action
action	include/range/v3/action/action.hpp	/^        using action RANGES_DEPRECATED($/;"	t	namespace:ranges::actions	typeref:typename:old_action_<Action>
action_access	include/range/v3/action/action.hpp	/^        using action_access RANGES_DEPRECATED($/;"	t	namespace:ranges::actions	typeref:typename:action_access_
action_access_	include/range/v3/action/action.hpp	/^        struct action_access_$/;"	s	namespace:ranges::actions
action_closure	include/range/v3/action/action.hpp	/^            constexpr explicit action_closure(ActionFn fn)$/;"	f	struct:ranges::actions::action_closure
action_closure	include/range/v3/action/action.hpp	/^        struct RANGES_EMPTY_BASES action_closure$/;"	s	namespace:ranges::actions
action_closure_base	include/range/v3/action/action.hpp	/^        struct action_closure_base$/;"	s	namespace:ranges::actions
action_closure_base_detail	include/range/v3/action/action.hpp	/^        namespace action_closure_base_detail$/;"	n	namespace:ranges::actions
actions	include/range/v3/action/action.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/adjacent_remove_if.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/drop.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/drop_while.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/erase.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/insert.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/join.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/push_back.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/push_front.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/remove.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/remove_if.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/reverse.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/shuffle.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/slice.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/sort.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/split.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/split_when.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/stable_sort.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/stride.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/take.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/take_while.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/transform.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/unique.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/action/unstable_remove_if.hpp	/^    namespace actions$/;"	n	namespace:ranges
actions	include/range/v3/range_fwd.hpp	/^    namespace actions$/;"	n	namespace:ranges
adapted_iterator_t	include/range/v3/view/adaptor.hpp	/^        using adapted_iterator_t = detail::decay_t<decltype($/;"	t	namespace:ranges::detail
adapted_sentinel_t	include/range/v3/view/adaptor.hpp	/^        using adapted_sentinel_t = detail::decay_t<decltype($/;"	t	namespace:ranges::detail
adaptor	include/range/v3/view/adjacent_filter.hpp	/^            constexpr adaptor(Parent * rng) noexcept$/;"	f	struct:ranges::adjacent_filter_view::adaptor
adaptor	include/range/v3/view/adjacent_filter.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::adjacent_filter_view
adaptor	include/range/v3/view/adjacent_remove_if.hpp	/^            constexpr adaptor(adjacent_remove_if_view * rng) noexcept$/;"	f	struct:ranges::adjacent_remove_if_view::adaptor
adaptor	include/range/v3/view/adjacent_remove_if.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::adjacent_remove_if_view
adaptor	include/range/v3/view/chunk.hpp	/^            constexpr adaptor(meta::const_if_c<Const, chunk_view_> * cv)$/;"	f	struct:ranges::chunk_view_::adaptor
adaptor	include/range/v3/view/chunk.hpp	/^        struct RANGES_EMPTY_BASES adaptor$/;"	s	struct:ranges::chunk_view_
adaptor	include/range/v3/view/const.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::const_view
adaptor	include/range/v3/view/drop_last.hpp	/^            adaptor(iterator_t<Rng> probe_first)$/;"	f	struct:ranges::drop_last_view::adaptor
adaptor	include/range/v3/view/drop_last.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::drop_last_view
adaptor	include/range/v3/view/exclusive_scan.hpp	/^            adaptor(exclusive_scan_view_t * rng)$/;"	f	struct:ranges::exclusive_scan_view::adaptor
adaptor	include/range/v3/view/exclusive_scan.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::exclusive_scan_view
adaptor	include/range/v3/view/indirect.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::indirect_view
adaptor	include/range/v3/view/move.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::move_view
adaptor	include/range/v3/view/remove_if.hpp	/^            constexpr adaptor(remove_if_view * rng) noexcept$/;"	f	struct:ranges::remove_if_view::adaptor
adaptor	include/range/v3/view/remove_if.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::remove_if_view
adaptor	include/range/v3/view/sliding.hpp	/^            adaptor(range_difference_t<Rng> n)$/;"	f	struct:ranges::sliding_view::adaptor
adaptor	include/range/v3/view/sliding.hpp	/^            adaptor(sliding_view * v)$/;"	f	struct:ranges::sliding_view::adaptor
adaptor	include/range/v3/view/sliding.hpp	/^        struct RANGES_EMPTY_BASES adaptor$/;"	s	struct:ranges::sliding_view
adaptor	include/range/v3/view/sliding.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::sliding_view
adaptor	include/range/v3/view/stride.hpp	/^            constexpr adaptor(stride_view_t * rng) noexcept$/;"	f	struct:ranges::stride_view::adaptor
adaptor	include/range/v3/view/stride.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::stride_view
adaptor	include/range/v3/view/transform.hpp	/^            adaptor(fun_ref_ fun)$/;"	f	struct:ranges::iter_transform_view::adaptor
adaptor	include/range/v3/view/transform.hpp	/^        struct adaptor : adaptor_base$/;"	s	struct:ranges::iter_transform_view
adaptor_base	include/range/v3/view/adaptor.hpp	/^        adaptor_base(detail::ignore_t, detail::ignore_t = {}, detail::ignore_t = {})$/;"	f	struct:ranges::adaptor_base
adaptor_base	include/range/v3/view/adaptor.hpp	/^    struct adaptor_base$/;"	s	namespace:ranges
adaptor_base_current_mem_fn	include/range/v3/view/adaptor.hpp	/^        struct adaptor_base_current_mem_fn$/;"	s	namespace:ranges::detail
adaptor_cursor	include/range/v3/view/adaptor.hpp	/^        adaptor_cursor(BaseIter iter, Adapt adapt)$/;"	f	struct:ranges::adaptor_cursor
adaptor_cursor	include/range/v3/view/adaptor.hpp	/^    struct adaptor_cursor : private detail::adaptor_value_type_<BaseIter, Adapt>$/;"	s	namespace:ranges
adaptor_cursor_t	include/range/v3/view/adaptor.hpp	/^    using adaptor_cursor_t =$/;"	t	namespace:ranges	typeref:typename:adaptor_cursor<detail::adapted_iterator_t<D>,detail::begin_adaptor_t<D>>
adaptor_sentinel	include/range/v3/view/adaptor.hpp	/^    struct adaptor_sentinel : detail::adaptor_sentinel_<BaseSent, Adapt>$/;"	s	namespace:ranges
adaptor_sentinel_	include/range/v3/view/adaptor.hpp	/^        using adaptor_sentinel_ = meta::_t<base_adaptor_sentinel_<BaseSent, Adapt>>;$/;"	t	namespace:ranges::detail	typeref:typename:meta::_t<base_adaptor_sentinel_<BaseSent,Adapt>>
adaptor_sentinel_t	include/range/v3/view/adaptor.hpp	/^    using adaptor_sentinel_t = meta::if_c<$/;"	t	namespace:ranges
adaptor_value_type_	include/range/v3/view/adaptor.hpp	/^        struct adaptor_value_type_$/;"	s	namespace:ranges::detail
adaptor_value_type_	include/range/v3/view/adaptor.hpp	/^        struct adaptor_value_type_<BaseIter, Adapt, 1>$/;"	s	namespace:ranges::detail
adaptor_value_type_	include/range/v3/view/adaptor.hpp	/^        struct adaptor_value_type_<BaseIter, Adapt, 2>$/;"	s	namespace:ranges::detail
add_const_t	include/range/v3/detail/variant.hpp	/^        using add_const_t = meta::if_<std::is_void<T>, void, T const>;$/;"	t	struct:ranges::variant	typeref:typename:meta::if_<std::is_void<T>,void,T const>
addressof_fn	include/range/v3/view/addressof.hpp	/^        struct addressof_fn$/;"	s	namespace:ranges::views
adjacent_difference_fn	include/range/v3/numeric/adjacent_difference.hpp	/^    struct adjacent_difference_fn$/;"	s	namespace:ranges
adjacent_difference_result	include/range/v3/numeric/adjacent_difference.hpp	/^    using adjacent_difference_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
adjacent_filter_base_fn	include/range/v3/view/adjacent_filter.hpp	/^        struct adjacent_filter_base_fn$/;"	s	namespace:ranges::views
adjacent_filter_fn	include/range/v3/view/adjacent_filter.hpp	/^        struct adjacent_filter_fn : adjacent_filter_base_fn$/;"	s	namespace:ranges::views
adjacent_filter_view	include/range/v3/view/adjacent_filter.hpp	/^        constexpr adjacent_filter_view(Rng rng, Pred pred)$/;"	f	struct:ranges::adjacent_filter_view
adjacent_filter_view	include/range/v3/view/adjacent_filter.hpp	/^    struct RANGES_EMPTY_BASES adjacent_filter_view$/;"	s	namespace:ranges
adjacent_remove_if_base_fn	include/range/v3/view/adjacent_remove_if.hpp	/^        struct adjacent_remove_if_base_fn$/;"	s	namespace:ranges::views
adjacent_remove_if_fn	include/range/v3/action/adjacent_remove_if.hpp	/^        struct adjacent_remove_if_fn$/;"	s	namespace:ranges::actions
adjacent_remove_if_fn	include/range/v3/view/adjacent_remove_if.hpp	/^        struct adjacent_remove_if_fn : adjacent_remove_if_base_fn$/;"	s	namespace:ranges::views
adjacent_remove_if_view	include/range/v3/view/adjacent_remove_if.hpp	/^        constexpr adjacent_remove_if_view(Rng rng, Pred pred)$/;"	f	struct:ranges::adjacent_remove_if_view
adjacent_remove_if_view	include/range/v3/view/adjacent_remove_if.hpp	/^    struct RANGES_EMPTY_BASES adjacent_remove_if_view$/;"	s	namespace:ranges
adl_erase_detail	include/range/v3/action/erase.hpp	/^    namespace adl_erase_detail$/;"	n	namespace:ranges
adl_get	include/range/v3/detail/adl_get.hpp	/^            constexpr auto adl_get(TupleLike && t) noexcept$/;"	f	namespace:ranges::detail::_adl_get_	typeref:typename:auto
adl_hook	include/range/v3/experimental/utility/generator.hpp	/^            struct adl_hook$/;"	s	namespace:ranges::detail::coroutine_owner_
adl_hook	include/range/v3/iterator/basic_iterator.hpp	/^        struct adl_hook$/;"	s	namespace:_basic_iterator_
adl_hook	include/range/v3/iterator/common_iterator.hpp	/^        struct adl_hook$/;"	s	namespace:ranges::_common_iterator_
adl_hook	include/range/v3/view/iota.hpp	/^        struct adl_hook$/;"	s	namespace:ranges::iota_view_detail
adl_hook	include/range/v3/view/ref.hpp	/^        struct adl_hook$/;"	s	namespace:ranges::_ref_view_
adl_hook	include/range/v3/view/subrange.hpp	/^        struct adl_hook$/;"	s	namespace:ranges::_subrange_
adl_hook_	include/range/v3/iterator_range.hpp	/^        struct adl_hook_$/;"	s	namespace:ranges::_iterator_range_
adl_hook_	include/range/v3/utility/tagged_pair.hpp	/^        struct adl_hook_$/;"	s	namespace:ranges::_tagged_
adl_insert_detail	include/range/v3/action/insert.hpp	/^    namespace adl_insert_detail$/;"	n	namespace:ranges
adl_push_back_detail	include/range/v3/action/push_back.hpp	/^    namespace adl_push_back_detail$/;"	n	namespace:ranges
adl_push_front_detail	include/range/v3/action/push_front.hpp	/^    namespace adl_push_front_detail$/;"	n	namespace:ranges
adl_swap_detail	include/concepts/swap.hpp	/^    namespace adl_swap_detail$/;"	n	namespace:concepts
adl_uncounted_recounted_detail	include/range/v3/iterator/operations.hpp	/^    namespace adl_uncounted_recounted_detail$/;"	n	namespace:ranges
advance	include/range/v3/iterator/common_iterator.hpp	/^            auto advance(std::ptrdiff_t n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
advance	include/range/v3/iterator/move_iterators.hpp	/^            auto advance(iter_difference_t<I> n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
advance	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr auto advance(iter_difference_t<I> n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
advance	include/range/v3/view/adaptor.hpp	/^        static auto advance(I & it, iter_difference_t<I> n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::adaptor_base	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
advance	include/range/v3/view/adaptor.hpp	/^        void advance(iter_difference_t<BaseIter> n)$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:void
advance	include/range/v3/view/cartesian_product.hpp	/^            auto advance(difference_type n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:CPP_ret (void)(requires cartesian_produce_view_can_random<IsConst,Views...>)
advance	include/range/v3/view/chunk.hpp	/^            constexpr auto advance(iterator_t<CRng> & it,$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:CPP_ret (void)(requires random_access_range<CRng>)
advance	include/range/v3/view/concat.hpp	/^            auto advance(difference_type n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:CPP_ret (void)(requires and_v<random_access_range<Rngs>...>)
advance	include/range/v3/view/enumerate.hpp	/^                void advance(Diff n)$/;"	f	struct:ranges::detail::index_view::cursor	typeref:typename:void
advance	include/range/v3/view/intersperse.hpp	/^            constexpr auto advance(iterator_t<CRng> & it,$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:CPP_ret (void)(requires random_access_range<CRng>)
advance	include/range/v3/view/iota.hpp	/^            auto advance(difference_type n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:CPP_ret (void)(requires detail::advanceable_<From>)
advance	include/range/v3/view/iota.hpp	/^            auto advance(difference_type n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:CPP_ret (void)(requires detail::advanceable_<From>)
advance	include/range/v3/view/repeat.hpp	/^            void advance(std::ptrdiff_t d)$/;"	f	struct:ranges::repeat_view::cursor	typeref:typename:void
advance	include/range/v3/view/repeat_n.hpp	/^            void advance(std::ptrdiff_t n)$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:void
advance	include/range/v3/view/sample.hpp	/^            void advance()$/;"	f	class:ranges::sample_view::cursor	typeref:typename:void
advance	include/range/v3/view/sliding.hpp	/^            auto advance(iterator_t<Rng> & it, range_difference_t<Rng> n)$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:CPP_ret (void)(requires random_access_range<Rng>)
advance	include/range/v3/view/stride.hpp	/^            constexpr auto advance(iterator_t<CRng> & it,$/;"	f	struct:ranges::stride_view::adaptor	typeref:typename:CPP_ret (void)(requires random_access_range<CRng>)
advance	include/range/v3/view/subrange.hpp	/^        constexpr subrange & advance(iter_difference_t<I> n)$/;"	f	struct:ranges::subrange	typeref:typename:subrange &
advance	include/range/v3/view/transform.hpp	/^            auto advance(difference_type n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::iter_transform2_view::cursor	typeref:typename:CPP_ret (void)(requires random_access_range<R1> && random_access_range<R2>)
advance	include/range/v3/view/zip_with.hpp	/^            auto advance(difference_type n) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:CPP_ret (void)(requires and_v<random_access_range<meta::const_if_c<Const,Rngs>>...>)
advance_	include/range/v3/view/cartesian_product.hpp	/^            void advance_(meta::size_t<0>, difference_type)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
advance_	include/range/v3/view/cartesian_product.hpp	/^            void advance_(meta::size_t<N>, difference_type n)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:RANGES_DIAGNOSTIC_PUSH RANGES_DIAGNOSTIC_IGNORE_DIVIDE_BY_ZERO void
advance_fn	include/range/v3/iterator/operations.hpp	/^    struct advance_fn$/;"	s	namespace:ranges
advance_fwd_fun	include/range/v3/view/concat.hpp	/^            struct advance_fwd_fun$/;"	s	struct:ranges::concat_view::cursor
advance_rev_fun	include/range/v3/view/concat.hpp	/^            struct advance_rev_fun$/;"	s	struct:ranges::concat_view::cursor
aiterator	test/p.cpp	/^struct aiterator {$/;"	s	file:
all_convertible_to	include/range/v3/detail/variant.hpp	/^        static constexpr auto all_convertible_to(int) noexcept -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::variant	typeref:typename:auto
all_convertible_to	include/range/v3/detail/variant.hpp	/^        static constexpr bool all_convertible_to(long) noexcept$/;"	f	struct:ranges::variant	typeref:typename:bool
all_fn	include/range/v3/view/all.hpp	/^        struct all_fn$/;"	s	namespace:ranges::views
all_t	include/range/v3/view/all.hpp	/^        using all_t = decltype(all(std::declval<Rng>()));$/;"	t	namespace:ranges::views
all_view	include/range/v3/view/all.hpp	/^            using all_view = ranges::views::all_t<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::views::all_t<Rng>
always_	include/std/detail/associated_types.hpp	/^        using always_ = T;$/;"	t	namespace:ranges::detail	typeref:typename:T
and_	include/concepts/concepts.hpp	/^        struct and_ : boolean$/;"	s	namespace:concepts::detail
and_v	include/concepts/concepts.hpp	/^    CPP_INLINE_VAR constexpr bool and_v = (Bs &&...);$/;"	v	namespace:concepts	typeref:typename:CPP_INLINE_VAR bool
and_v	include/concepts/concepts.hpp	/^    CPP_INLINE_VAR constexpr bool and_v =$/;"	v	namespace:concepts	typeref:typename:CPP_INLINE_VAR bool
any	include/range/v3/utility/any.hpp	/^        any(any const & that)$/;"	f	struct:ranges::any
any	include/range/v3/utility/any.hpp	/^    struct any$/;"	s	namespace:ranges
any_cast	include/range/v3/utility/any.hpp	/^    T * any_cast(any * p) noexcept$/;"	f	namespace:ranges	typeref:typename:T *
any_cast	include/range/v3/utility/any.hpp	/^    T const * any_cast(any const * p) noexcept$/;"	f	namespace:ranges	typeref:typename:T const *
any_cast	include/range/v3/utility/any.hpp	/^    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any & x)$/;"	f	namespace:ranges	typeref:typename:meta::if_c<std::is_reference<T> ()||copyable<T>,T>
any_cast	include/range/v3/utility/any.hpp	/^    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any && x)$/;"	f	namespace:ranges	typeref:typename:meta::if_c<std::is_reference<T> ()||copyable<T>,T>
any_cast	include/range/v3/utility/any.hpp	/^    meta::if_c<std::is_reference<T>() || copyable<T>, T> any_cast(any const & x)$/;"	f	namespace:ranges	typeref:typename:meta::if_c<std::is_reference<T> ()||copyable<T>,T>
any_input_cursor	include/range/v3/view/any_view.hpp	/^            constexpr any_input_cursor(any_input_view_interface<Ref> & view) noexcept$/;"	f	struct:ranges::detail::any_input_cursor
any_input_cursor	include/range/v3/view/any_view.hpp	/^        struct any_input_cursor$/;"	s	namespace:ranges::detail
any_input_view_impl	include/range/v3/view/any_view.hpp	/^            explicit any_input_view_impl(Rng rng)$/;"	f	struct:ranges::detail::any_input_view_impl
any_input_view_impl	include/range/v3/view/any_view.hpp	/^        struct RANGES_EMPTY_BASES any_input_view_impl$/;"	s	namespace:ranges::detail
any_input_view_interface	include/range/v3/view/any_view.hpp	/^        struct any_input_view_interface$/;"	s	namespace:ranges::detail
any_input_view_interface	include/range/v3/view/any_view.hpp	/^        struct any_input_view_interface<Ref, true> : any_input_view_interface<Ref, false>$/;"	s	namespace:ranges::detail
any_ref	include/range/v3/view/any_view.hpp	/^            constexpr any_ref(T & obj) noexcept$/;"	f	struct:ranges::detail::any_ref
any_ref	include/range/v3/view/any_view.hpp	/^        struct any_ref$/;"	s	namespace:ranges::detail
any_view_sentinel_impl	include/range/v3/view/any_view.hpp	/^            any_view_sentinel_impl(Rng & rng)$/;"	f	struct:ranges::detail::any_view_sentinel_impl
any_view_sentinel_impl	include/range/v3/view/any_view.hpp	/^        struct any_view_sentinel_impl$/;"	s	namespace:ranges::detail
apply	include/range/v3/functional/invoke.hpp	/^            static constexpr bool apply() noexcept$/;"	f	struct:ranges::detail::is_nothrow_invocable_impl_	typeref:typename:bool
apply	include/range/v3/iterator/concepts.hpp	/^            using apply = detail::enable_if_t<(bool)readable<I>, I>;$/;"	t	struct:ranges::detail::select_projected_
apply	include/range/v3/iterator/concepts.hpp	/^            using apply =$/;"	t	struct:ranges::detail::select_projected_
apply	include/std/detail/associated_types.hpp	/^            using apply = T;$/;"	t	struct:ranges::detail::enable_if	typeref:typename:T
apply	include/std/detail/associated_types.hpp	/^            using apply = T;$/;"	t	struct:ranges::detail::if_then	typeref:typename:T
apply	include/std/detail/associated_types.hpp	/^            using apply = U;$/;"	t	struct:ranges::detail::if_then	typeref:typename:U
arg0_	include/range/v3/functional/bind_back.hpp	/^                Arg0 arg0_;$/;"	m	struct:ranges::detail::bind_back_fn_::tuple_t	typeref:typename:Arg0
arg1_	include/range/v3/functional/bind_back.hpp	/^                Arg1 arg1_;$/;"	m	struct:ranges::detail::bind_back_fn_::tuple_t	typeref:typename:Arg1
arg_	include/range/v3/functional/bind_back.hpp	/^                Arg arg_;$/;"	m	struct:ranges::detail::bind_back_fn_::tuple_t	typeref:typename:Arg
args	include/range/v3/utility/common_tuple.hpp	/^        using args = args_<sizeof...(Ts), Ts...>;$/;"	t	namespace:ranges::detail
args_	include/range/v3/detail/variant.hpp	/^            std::tuple<Ts...> args_;$/;"	m	struct:ranges::detail::construct_fn	typeref:typename:std::tuple<Ts...>
args_	include/range/v3/utility/common_tuple.hpp	/^            args_(args_<N, Us...>, meta::if_c<$/;"	f	struct:ranges::detail::args_
args_	include/range/v3/utility/common_tuple.hpp	/^        struct args_$/;"	s	namespace:ranges::detail
argsignable	include/range/v3/utility/common_tuple.hpp	/^        inline constexpr bool argsignable = false;$/;"	v	namespace:ranges::detail	typeref:typename:bool
argstructible	include/range/v3/utility/common_tuple.hpp	/^        inline constexpr bool argstructible = false;$/;"	v	namespace:ranges::detail	typeref:typename:bool
argument	include/nt.hpp	/^  struct argument {$/;"	s	class:nt::NamedType
arrow	include/range/v3/iterator/common_iterator.hpp	/^            I arrow() const$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:I
arrow	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr I arrow() const$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:I
arrow	include/range/v3/view/join.hpp	/^            constexpr auto arrow() -> CPP_ret(iterator_t<CInner>)( \/\/$/;"	f	struct:ranges::join_view::cursor	typeref:typename:CPP_ret (iterator_t<CInner>)(requires detail::has_arrow_<iterator_t<CInner>>)
arrow_proxy_	include/range/v3/iterator/common_iterator.hpp	/^            arrow_proxy_(iter_reference_t<I> && x)$/;"	f	struct:ranges::common_iterator::arrow_proxy_
arrow_proxy_	include/range/v3/iterator/common_iterator.hpp	/^        struct arrow_proxy_$/;"	s	struct:ranges::common_iterator
as_bytes	include/range/v3/view/span.hpp	/^    span<unsigned char const, detail::byte_size<T>(N)> as_bytes(span<T, N> s) noexcept$/;"	f	namespace:ranges	typeref:typename:span<unsigned char const,detail::byte_size<T> (N)>
as_cref_	include/concepts/type_traits.hpp	/^        struct as_cref_<T &&>$/;"	s	namespace:concepts::detail
as_cref_	include/concepts/type_traits.hpp	/^        struct as_cref_<T &>$/;"	s	namespace:concepts::detail
as_cref_	include/concepts/type_traits.hpp	/^        struct as_cref_<void const>$/;"	s	namespace:concepts::detail
as_cref_	include/concepts/type_traits.hpp	/^        struct as_cref_<void>$/;"	s	namespace:concepts::detail
as_cref_t	include/concepts/type_traits.hpp	/^        using as_cref_t = typename as_cref_<T>::type;$/;"	t	namespace:concepts::detail	typeref:typename:as_cref_<T>::type
as_lvalue_fn	include/range/v3/numeric/partial_sum.hpp	/^        struct as_lvalue_fn$/;"	s	namespace:ranges::detail
as_value_type_t	include/range/v3/numeric/partial_sum.hpp	/^        using as_value_type_t = composed<as_lvalue_fn, coerce<iter_value_t<I>>>;$/;"	t	namespace:ranges::detail	typeref:typename:composed<as_lvalue_fn,coerce<iter_value_t<I>>>
as_writeable_bytes	include/range/v3/view/span.hpp	/^    span<unsigned char, detail::byte_size<T>(N)> as_writeable_bytes(span<T, N> s) noexcept$/;"	f	namespace:ranges	typeref:typename:span<unsigned char,detail::byte_size<T> (N)>
assert_failure	include/range/v3/detail/config.hpp	/^        [[noreturn]] void assert_failure(char const * file, int line, char const * msg)$/;"	f	namespace:ranges::detail	typeref:typename:[[noreturn]]void
assign_	include/range/v3/detail/variant.hpp	/^        void assign_(That && that)$/;"	f	struct:ranges::variant	typeref:typename:void
assign_from	include/range/v3/utility/optional.hpp	/^                constexpr void assign_from(U && that) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:void
assign_from	include/range/v3/utility/optional.hpp	/^                constexpr void assign_from(U && that)$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:void
assoc_types_	include/range/v3/iterator/basic_iterator.hpp	/^        using assoc_types_ = detail::iterator_associated_types_base<Cur>;$/;"	t	struct:basic_iterator	typeref:typename:detail::iterator_associated_types_base<Cur>
at	include/range/v3/view/interface.hpp	/^        constexpr auto at(range_difference_t<D<True>> n) const$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True> const>)(requires True && random_access_range<D<True> const> && sized_range<D<True> const>)
at	include/range/v3/view/interface.hpp	/^        constexpr auto at(range_difference_t<D<True>> n)$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True>>)(requires True && random_access_range<D<True>> && sized_range<D<True>>)
at_fn	include/range/v3/range/operations.hpp	/^    struct at_fn$/;"	s	namespace:ranges
auto_seed_128	include/range/v3/utility/random.hpp	/^            using auto_seed_128 = auto_seeded<seed_seq_fe128>;$/;"	t	namespace:ranges::detail::randutils	typeref:typename:auto_seeded<seed_seq_fe128>
auto_seed_256	include/range/v3/utility/random.hpp	/^            using auto_seed_256 = auto_seeded<seed_seq_fe256>;$/;"	t	namespace:ranges::detail::randutils	typeref:typename:auto_seeded<seed_seq_fe256>
auto_seeded	include/range/v3/utility/random.hpp	/^                auto_seeded()$/;"	f	struct:ranges::detail::randutils::auto_seeded
auto_seeded	include/range/v3/utility/random.hpp	/^                auto_seeded(std::array<std::uint32_t, N> const & seeds)$/;"	f	struct:ranges::detail::randutils::auto_seeded
auto_seeded	include/range/v3/utility/random.hpp	/^            struct auto_seeded : public SeedSeq$/;"	s	namespace:ranges::detail::randutils
aux	include/range/v3/algorithm/aux_/equal_range_n.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/algorithm/aux_/merge_n.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/algorithm/aux_/partition_point_n.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/utility/copy.hpp	/^    namespace aux$/;"	n	namespace:ranges
aux	include/range/v3/utility/move.hpp	/^    namespace aux$/;"	n	namespace:ranges
await_transform	include/range/v3/experimental/utility/generator.hpp	/^            std::experimental::suspend_always await_transform($/;"	f	struct:ranges::detail::sized_generator_promise	typeref:typename:std::experimental::suspend_always
await_transform	include/range/v3/experimental/utility/generator.hpp	/^            std::experimental::suspend_never await_transform($/;"	f	struct:ranges::detail::generator_promise	typeref:typename:std::experimental::suspend_never
back	include/range/v3/view/interface.hpp	/^        constexpr auto back() -> CPP_ret(range_reference_t<D<True>>)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True>>)(requires True && common_range<D<True>> && bidirectional_range<D<True>>)
back	include/range/v3/view/interface.hpp	/^        constexpr auto back() const -> CPP_ret(range_reference_t<D<True> const>)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True> const>)(requires True && common_range<D<True> const> && bidirectional_range<D<True> const>)
back_fn	include/range/v3/range/operations.hpp	/^    struct back_fn$/;"	s	namespace:ranges
back_insert_iterator	include/range/v3/iterator/insert_iterators.hpp	/^        explicit constexpr back_insert_iterator(Container & x)$/;"	f	struct:ranges::back_insert_iterator
back_insert_iterator	include/range/v3/iterator/insert_iterators.hpp	/^    struct back_insert_iterator$/;"	s	namespace:ranges
back_inserter_fn	include/range/v3/iterator/insert_iterators.hpp	/^    struct back_inserter_fn$/;"	s	namespace:ranges
bad_any_cast	include/range/v3/utility/any.hpp	/^    struct bad_any_cast : std::bad_cast$/;"	s	namespace:ranges
bad_optional_access	include/range/v3/utility/optional.hpp	/^    struct bad_optional_access : std::exception$/;"	s	namespace:ranges
bad_variant_access	include/range/v3/detail/variant.hpp	/^        explicit bad_variant_access(char const * what_arg)$/;"	f	struct:ranges::bad_variant_access
bad_variant_access	include/range/v3/detail/variant.hpp	/^        explicit bad_variant_access(std::string const & what_arg)$/;"	f	struct:ranges::bad_variant_access
bad_variant_access	include/range/v3/detail/variant.hpp	/^    struct bad_variant_access : std::logic_error$/;"	s	namespace:ranges
barrier	include/meta/meta_fwd.hpp	/^        META_INLINE_VAR constexpr bool barrier = B;$/;"	v	namespace:meta::detail	typeref:typename:META_INLINE_VAR bool
base	include/range/v3/detail/with_braced_init_args.hpp	/^            constexpr ImplFn const & base() const$/;"	f	struct:ranges::detail::with_braced_init_args	typeref:typename:ImplFn const &
base	include/range/v3/experimental/utility/generator.hpp	/^            base_t & base() noexcept$/;"	f	struct:ranges::experimental::coroutine_owner	typeref:typename:base_t &
base	include/range/v3/iterator/common_iterator.hpp	/^                I base() const$/;"	f	struct:ranges::detail::cpp17_iterator_cursor::mixin	typeref:typename:I
base	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr I base() const$/;"	f	struct:ranges::counted_iterator	typeref:typename:I
base	include/range/v3/iterator/move_iterators.hpp	/^                I base() const$/;"	f	struct:ranges::detail::move_into_cursor::mixin	typeref:typename:I
base	include/range/v3/iterator/move_iterators.hpp	/^        I base() const$/;"	f	struct:ranges::move_iterator	typeref:typename:I
base	include/range/v3/iterator/move_iterators.hpp	/^        S base() const$/;"	f	struct:ranges::move_sentinel	typeref:typename:S
base	include/range/v3/iterator/reverse_iterator.hpp	/^                constexpr I base() const$/;"	f	struct:ranges::detail::reverse_cursor::mixin	typeref:typename:I
base	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr I base() const$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:I
base	include/range/v3/iterator_range.hpp	/^        compressed_pair<I, S> & base() noexcept$/;"	f	struct:ranges::iterator_range	typeref:typename:compressed_pair<I,S> &
base	include/range/v3/iterator_range.hpp	/^        compressed_pair<I, S> const & base() const noexcept$/;"	f	struct:ranges::iterator_range	typeref:typename:compressed_pair<I,S> const &
base	include/range/v3/utility/common_tuple.hpp	/^        std::pair<F, S> const & base() const noexcept$/;"	f	struct:ranges::common_pair	typeref:typename:std::pair<F,S> const &
base	include/range/v3/utility/common_tuple.hpp	/^        std::tuple<Ts...> & base() noexcept$/;"	f	struct:ranges::common_tuple	typeref:typename:std::tuple<Ts...> &
base	include/range/v3/utility/common_tuple.hpp	/^        std::tuple<Ts...> const & base() const noexcept$/;"	f	struct:ranges::common_tuple	typeref:typename:std::tuple<Ts...> const &
base	include/range/v3/utility/memory.hpp	/^        I base() const$/;"	f	struct:ranges::iterator_wrapper	typeref:typename:I
base	include/range/v3/utility/memory.hpp	/^        O base() const$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:O
base	include/range/v3/utility/random.hpp	/^                SeedSeq & base()$/;"	f	struct:ranges::detail::randutils::auto_seeded	typeref:typename:SeedSeq &
base	include/range/v3/utility/random.hpp	/^                const SeedSeq & base() const$/;"	f	struct:ranges::detail::randutils::auto_seeded	typeref:typename:const SeedSeq &
base	include/range/v3/view/adaptor.hpp	/^            BaseIter base() const$/;"	f	struct:ranges::adaptor_cursor::basic_adaptor_mixin	typeref:typename:BaseIter
base	include/range/v3/view/adaptor.hpp	/^        BaseSent base() const$/;"	f	struct:ranges::base_adaptor_sentinel	typeref:typename:BaseSent
base	include/range/v3/view/adaptor.hpp	/^        constexpr base_range_t & base() noexcept$/;"	f	struct:ranges::view_adaptor	typeref:typename:base_range_t &
base	include/range/v3/view/adaptor.hpp	/^        constexpr base_range_t const & base() const noexcept$/;"	f	struct:ranges::view_adaptor	typeref:typename:base_range_t const &
base	include/range/v3/view/chunk.hpp	/^        Rng base() const$/;"	f	struct:ranges::chunk_view_	typeref:typename:Rng
base	include/range/v3/view/common.hpp	/^        Rng base() const$/;"	f	struct:ranges::common_view	typeref:typename:Rng
base	include/range/v3/view/drop.hpp	/^        Rng base() const$/;"	f	struct:ranges::drop_view	typeref:typename:Rng
base	include/range/v3/view/drop_exactly.hpp	/^        Rng base() const$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:Rng
base	include/range/v3/view/drop_last.hpp	/^        Rng & base()$/;"	f	struct:ranges::drop_last_view	typeref:typename:Rng &
base	include/range/v3/view/drop_last.hpp	/^        Rng const & base() const$/;"	f	struct:ranges::drop_last_view	typeref:typename:Rng const &
base	include/range/v3/view/drop_while.hpp	/^        Rng base() const$/;"	f	struct:ranges::drop_while_view	typeref:typename:Rng
base	include/range/v3/view/join.hpp	/^        constexpr Rng base() const$/;"	f	struct:ranges::join_view	typeref:typename:Rng
base	include/range/v3/view/ref.hpp	/^        constexpr Rng & base() const noexcept$/;"	f	struct:ranges::ref_view	typeref:typename:Rng &
base	include/range/v3/view/reverse.hpp	/^        Rng base() const$/;"	f	struct:ranges::reverse_view	typeref:typename:Rng
base	include/range/v3/view/sample.hpp	/^        Rng base() const$/;"	f	class:ranges::sample_view	typeref:typename:Rng
base	include/range/v3/view/slice.hpp	/^            Rng base() const$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:Rng
base	include/range/v3/view/split.hpp	/^        constexpr V base() const$/;"	f	struct:ranges::split_view	typeref:typename:V
base	include/range/v3/view/tail.hpp	/^        Rng base() const$/;"	f	struct:ranges::tail_view	typeref:typename:Rng
base	include/range/v3/view/take.hpp	/^            constexpr sentinel_t<Base> base() const$/;"	f	struct:ranges::take_view::sentinel	typeref:typename:sentinel_t<Base>
base	include/range/v3/view/take.hpp	/^        constexpr Rng base() const$/;"	f	struct:ranges::take_view	typeref:typename:Rng
base	include/range/v3/view/take_exactly.hpp	/^            Rng base() const$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:Rng
base	include/range/v3/view/tokenize.hpp	/^        Rng base() const$/;"	f	struct:ranges::tokenize_view	typeref:typename:Rng
base	include/range/v3/view/trim.hpp	/^        Rng base() const$/;"	f	struct:ranges::trim_view	typeref:typename:Rng
base_	include/range/v3/functional/reference_wrapper.hpp	/^        using base_ = detail::reference_wrapper_<T>;$/;"	t	struct:ranges::reference_wrapper	typeref:typename:detail::reference_wrapper_<T>
base_	include/range/v3/view/chunk.hpp	/^        Rng base_;$/;"	m	struct:ranges::chunk_view_	typeref:typename:Rng
base_	include/range/v3/view/partial_sum.hpp	/^        RANGES_NO_UNIQUE_ADDRESS Rng base_{};$/;"	m	struct:ranges::partial_sum_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS Rng
base_	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) base_() const noexcept$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:decltype (auto)
base_	include/range/v3/view/split.hpp	/^        V base_ = V();$/;"	m	struct:ranges::split_view	typeref:typename:V
base_	include/range/v3/view/take.hpp	/^        Rng base_ = Rng();$/;"	m	struct:ranges::take_view	typeref:typename:Rng
base_adaptor_sentinel	include/range/v3/view/adaptor.hpp	/^        base_adaptor_sentinel(BaseSent sent, Adapt adapt)$/;"	f	struct:ranges::base_adaptor_sentinel
base_adaptor_sentinel	include/range/v3/view/adaptor.hpp	/^    struct base_adaptor_sentinel$/;"	s	namespace:ranges
base_adaptor_sentinel_	include/range/v3/view/adaptor.hpp	/^        struct base_adaptor_sentinel_$/;"	s	namespace:ranges::detail
base_range_t	include/range/v3/view/adaptor.hpp	/^        using base_range_t = views::all_t<BaseRng>;$/;"	t	struct:ranges::view_adaptor	typeref:typename:views::all_t<BaseRng>
base_t	include/range/v3/experimental/utility/generator.hpp	/^            using base_t = std::experimental::coroutine_handle<Promise>;$/;"	t	struct:ranges::experimental::coroutine_owner	typeref:typename:std::experimental::coroutine_handle<Promise>
base_t	include/range/v3/iterator/basic_iterator.hpp	/^        using base_t = detail::iterator_associated_types_base<Cur>;$/;"	t	struct:basic_iterator	typeref:typename:detail::iterator_associated_types_base<Cur>
base_t	include/range/v3/utility/optional.hpp	/^        using base_t = detail::optional_adl::move_assign_layer<T>;$/;"	t	struct:ranges::optional	typeref:typename:detail::optional_adl::move_assign_layer<T>
base_t	include/range/v3/utility/tagged_pair.hpp	/^        using base_t = meta::_t<detail::tagged_chain<Base, 0, Tags...>>;$/;"	t	class:ranges::tagged	typeref:typename:meta::_t<detail::tagged_chain<Base,0,Tags...>>
base_t	include/range/v3/view/adaptor.hpp	/^        using base_t = detail::adaptor_value_type_<BaseIter, Adapt>;$/;"	t	struct:ranges::adaptor_cursor	typeref:typename:detail::adaptor_value_type_<BaseIter,Adapt>
base_t	include/range/v3/view/replace_if.hpp	/^            using base_t = compressed_pair<semiregular_box_t<Pred>, Val>;$/;"	t	struct:ranges::detail::replacer_if_fn	typeref:typename:compressed_pair<semiregular_box_t<Pred>,Val>
base_t	include/range/v3/view/sliding.hpp	/^            using base_t = sliding_view_detail::trailing<Rng>;$/;"	t	struct:ranges::sliding_view::adaptor	typeref:typename:sliding_view_detail::trailing<Rng>
basic_adaptor_mixin	include/range/v3/view/adaptor.hpp	/^        struct basic_adaptor_mixin : basic_mixin<adaptor_cursor>$/;"	s	struct:ranges::adaptor_cursor
basic_common_reference	include/concepts/type_traits.hpp	/^    struct basic_common_reference$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_tuple.hpp	/^    struct basic_common_reference<ranges::common_pair<F1, S1>, std::pair<F2, S2>, Qual1,$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_tuple.hpp	/^    struct basic_common_reference<ranges::common_pair<F1, S1>,$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_tuple.hpp	/^    struct basic_common_reference<ranges::common_tuple<Ts...>, std::tuple<Us...>, Qual1,$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_tuple.hpp	/^    struct basic_common_reference<ranges::common_tuple<Ts...>,$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_tuple.hpp	/^    struct basic_common_reference<std::pair<F1, S1>, ranges::common_pair<F2, S2>, Qual1,$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_tuple.hpp	/^    struct basic_common_reference<std::tuple<Ts...>, ranges::common_tuple<Us...>, Qual1,$/;"	s	namespace:concepts
basic_common_reference	include/range/v3/utility/common_type.hpp	/^    struct basic_common_reference<common_pair<F1, S1>, std::pair<F2, S2>, Qual1, Qual2>;$/;"	v	namespace:concepts	typeref:struct:common_type template struct common_type template struct common_type template struct common_type template struct common_type template struct common_type template struct
basic_istream_view	include/range/v3/view/istream.hpp	/^        using basic_istream_view = ::ranges::istream_view<Val>;$/;"	t	namespace:ranges::cpp20	typeref:typename:::ranges::istream_view<Val>
basic_iterator	include/range/v3/iterator/basic_iterator.hpp	/^    struct RANGES_EMPTY_BASES basic_iterator$/;"	s
basic_mixin	include/range/v3/iterator/basic_iterator.hpp	/^    struct basic_mixin : private box<T>$/;"	s	namespace:ranges
basic_proxy_reference	include/range/v3/iterator/basic_iterator.hpp	/^        using basic_proxy_reference =$/;"	t	namespace:ranges::detail
basic_proxy_reference_	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr explicit basic_proxy_reference_(Cur & cur) noexcept$/;"	f	struct:ranges::detail::basic_proxy_reference_
basic_proxy_reference_	include/range/v3/iterator/basic_iterator.hpp	/^        struct RANGES_EMPTY_BASES basic_proxy_reference_$/;"	s	namespace:ranges::detail
begin	include/range/v3/experimental/view/shared.hpp	/^            iterator_t<Rng> begin() const$/;"	f	struct:ranges::experimental::shared_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/iterator_range.hpp	/^        I begin() const$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:I
begin	include/range/v3/iterator_range.hpp	/^        constexpr I & begin() &$/;"	f	struct:ranges::iterator_range	typeref:typename:I &
begin	include/range/v3/iterator_range.hpp	/^        constexpr I begin(iterator_range<I, S> && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:I
begin	include/range/v3/iterator_range.hpp	/^        constexpr I begin(iterator_range<I, S> const && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:I
begin	include/range/v3/iterator_range.hpp	/^        constexpr I begin(sized_iterator_range<I, S> && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:I
begin	include/range/v3/iterator_range.hpp	/^        constexpr I begin(sized_iterator_range<I, S> const && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:I
begin	include/range/v3/iterator_range.hpp	/^        constexpr I const & begin() const &$/;"	f	struct:ranges::iterator_range	typeref:typename:I const &
begin	include/range/v3/utility/memory.hpp	/^        iterator_wrapper<raw_storage_iterator<Val *, Val>> begin()$/;"	f	struct:ranges::raw_buffer	typeref:typename:iterator_wrapper<raw_storage_iterator<Val *,Val>>
begin	include/range/v3/view/adjacent_remove_if.hpp	/^            static constexpr iterator_t<Rng> begin(adjacent_remove_if_view & rng)$/;"	f	struct:ranges::adjacent_remove_if_view::adaptor	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/common.hpp	/^        auto begin() const$/;"	f	struct:ranges::common_view	typeref:typename:CPP_ret (detail::common_view_iterator_t<meta::const_if_c<Const,Rng>>)(requires range<meta::const_if_c<Const,Rng>>)
begin	include/range/v3/view/common.hpp	/^        detail::common_view_iterator_t<Rng> begin()$/;"	f	struct:ranges::common_view	typeref:typename:detail::common_view_iterator_t<Rng>
begin	include/range/v3/view/counted.hpp	/^        counted_iterator<I> begin() const$/;"	f	struct:ranges::counted_view	typeref:typename:counted_iterator<I>
begin	include/range/v3/view/drop.hpp	/^        auto begin() const -> CPP_ret(iterator_t<meta::const_if_c<Const, Rng>>)( \/\/$/;"	f	struct:ranges::drop_view	typeref:typename:CPP_ret (iterator_t<meta::const_if_c<Const,Rng>>)(requires Const && random_access_range<meta::const_if_c<Const,Rng>>)
begin	include/range/v3/view/drop.hpp	/^        iterator_t<Rng> begin()$/;"	f	struct:ranges::drop_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/drop_exactly.hpp	/^        auto begin() const -> CPP_ret(iterator_t<meta::const_if_c<Const, Rng>>)( \/\/$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:CPP_ret (iterator_t<meta::const_if_c<Const,Rng>>)(requires Const && random_access_range<meta::const_if_c<Const,Rng>>)
begin	include/range/v3/view/drop_exactly.hpp	/^        iterator_t<Rng> begin()$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/drop_last.hpp	/^        auto begin() const -> CPP_ret(counted_iterator<iterator_t<CRng>>)( \/\/$/;"	f	struct:ranges::drop_last_view	typeref:typename:CPP_ret (counted_iterator<iterator_t<CRng>>)(requires sized_range<CRng>)
begin	include/range/v3/view/drop_last.hpp	/^        auto begin() const -> CPP_ret(iterator_t<CRng>)( \/\/$/;"	f	struct:ranges::drop_last_view	typeref:typename:CPP_ret (iterator_t<CRng>)(requires random_access_range<CRng> && sized_range<CRng>)
begin	include/range/v3/view/drop_last.hpp	/^        counted_iterator<iterator_t<Rng>> begin()$/;"	f	struct:ranges::drop_last_view	typeref:typename:counted_iterator<iterator_t<Rng>>
begin	include/range/v3/view/drop_last.hpp	/^        iterator_t<Rng> begin()$/;"	f	struct:ranges::drop_last_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/drop_while.hpp	/^        iterator_t<Rng> begin()$/;"	f	struct:ranges::drop_while_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/empty.hpp	/^            friend constexpr T * begin(empty_view<T>) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:T *
begin	include/range/v3/view/empty.hpp	/^        static constexpr T * begin() noexcept$/;"	f	struct:ranges::empty_view	typeref:typename:T *
begin	include/range/v3/view/exclusive_scan.hpp	/^            iterator_t<CRng> begin(exclusive_scan_view_t &)$/;"	f	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:iterator_t<CRng>
begin	include/range/v3/view/facade.hpp	/^        constexpr auto begin() -> CPP_ret(detail::facade_iterator_t<D>)( \/\/$/;"	f	struct:ranges::view_facade	typeref:typename:CPP_ret (detail::facade_iterator_t<D>)(requires same_as<D,Derived>)
begin	include/range/v3/view/facade.hpp	/^        constexpr auto begin() const -> CPP_ret(detail::facade_iterator_t<D const>)( \/\/$/;"	f	struct:ranges::view_facade	typeref:typename:CPP_ret (detail::facade_iterator_t<D const>)(requires same_as<D,Derived>)
begin	include/range/v3/view/intersperse.hpp	/^            constexpr iterator_t<CRng> begin(View & view)$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:iterator_t<CRng>
begin	include/range/v3/view/iota.hpp	/^        constexpr auto begin(closed_iota_view<From, To> r)$/;"	f	namespace:ranges::iota_view_detail	typeref:typename:auto
begin	include/range/v3/view/iota.hpp	/^        constexpr auto begin(iota_view<From, To> r)$/;"	f	namespace:ranges::iota_view_detail	typeref:typename:auto
begin	include/range/v3/view/ref.hpp	/^        constexpr iterator_t<Rng> begin() const noexcept(noexcept(ranges::begin(*rng_)))$/;"	f	struct:ranges::ref_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/ref.hpp	/^        constexpr iterator_t<Rng> begin(ref_view<Rng> && rng) noexcept($/;"	f	namespace:ranges::_ref_view_	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/ref.hpp	/^        constexpr iterator_t<Rng> begin(ref_view<Rng> const && rng) noexcept($/;"	f	namespace:ranges::_ref_view_	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/remove_if.hpp	/^            static constexpr iterator_t<Rng> begin(remove_if_view & rng)$/;"	f	struct:ranges::remove_if_view::adaptor	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/reverse.hpp	/^        constexpr auto begin() const$/;"	f	struct:ranges::reverse_view	typeref:typename:CPP_ret (reverse_iterator<iterator_t<meta::const_if_c<Const,Rng>>>)(requires Const && common_range<meta::const_if_c<Const,Rng>>)
begin	include/range/v3/view/reverse.hpp	/^        constexpr reverse_iterator<iterator_t<Rng>> begin()$/;"	f	struct:ranges::reverse_view	typeref:typename:reverse_iterator<iterator_t<Rng>>
begin	include/range/v3/view/single.hpp	/^        constexpr T * begin() noexcept$/;"	f	struct:ranges::single_view	typeref:typename:T *
begin	include/range/v3/view/single.hpp	/^        constexpr T const * begin() const noexcept$/;"	f	struct:ranges::single_view	typeref:typename:T const *
begin	include/range/v3/view/slice.hpp	/^            auto begin() const -> CPP_ret(iterator_t<BaseRng const>)( \/\/$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:CPP_ret (iterator_t<BaseRng const>)(requires range<BaseRng const>)
begin	include/range/v3/view/slice.hpp	/^            counted_iterator<iterator_t<Rng>> begin()$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:counted_iterator<iterator_t<Rng>>
begin	include/range/v3/view/slice.hpp	/^            iterator_t<Rng> begin()$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/sliding.hpp	/^            iterator_t<Rng> begin(sliding_view & v)$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/span.hpp	/^        constexpr iterator begin() const noexcept$/;"	f	struct:ranges::span	typeref:typename:iterator
begin	include/range/v3/view/split.hpp	/^                constexpr split_inner_iterator<split_view<V, Pattern>, Const> begin()$/;"	f	struct:ranges::detail::split_outer_iterator::value_type	typeref:typename:split_inner_iterator<split_view<V,Pattern>,Const>
begin	include/range/v3/view/split.hpp	/^        constexpr auto begin() -> outer_iterator<forward_range<V> && simple_view<V>()>$/;"	f	struct:ranges::split_view	typeref:typename:outer_iterator<forward_range<V> && simple_view<V> ()>
begin	include/range/v3/view/split.hpp	/^        constexpr auto begin() const -> CPP_ret(outer_iterator<true>)( \/\/$/;"	f	struct:ranges::split_view	typeref:typename:CPP_ret (outer_iterator<true>)(requires forward_range<V> && forward_range<const V>)
begin	include/range/v3/view/subrange.hpp	/^        constexpr I begin() const noexcept(std::is_nothrow_copy_constructible<I>::value)$/;"	f	struct:ranges::subrange	typeref:typename:I
begin	include/range/v3/view/subrange.hpp	/^        constexpr I begin(subrange<I, S, K> && r) noexcept($/;"	f	namespace:ranges::_subrange_	typeref:typename:I
begin	include/range/v3/view/subrange.hpp	/^        constexpr I begin(subrange<I, S, K> const && r) noexcept($/;"	f	namespace:ranges::_subrange_	typeref:typename:I
begin	include/range/v3/view/tail.hpp	/^        auto begin() const -> CPP_ret(iterator_t<meta::const_if_c<Const, Rng>>)( \/\/$/;"	f	struct:ranges::tail_view	typeref:typename:CPP_ret (iterator_t<meta::const_if_c<Const,Rng>>)(requires Const && range<meta::const_if_c<Const,Rng>>)
begin	include/range/v3/view/tail.hpp	/^        iterator_t<Rng> begin()$/;"	f	struct:ranges::tail_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/take_exactly.hpp	/^            auto begin() const -> CPP_ret(counted_iterator<iterator_t<BaseRng const>>)( \/\/$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:CPP_ret (counted_iterator<iterator_t<BaseRng const>>)(requires range<BaseRng const>)
begin	include/range/v3/view/take_exactly.hpp	/^            counted_iterator<iterator_t<Rng>> begin()$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:counted_iterator<iterator_t<Rng>>
begin	include/range/v3/view/take_exactly.hpp	/^            iterator_t<Rng> begin()$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/tokenize.hpp	/^        auto begin() const -> CPP_ret(iterator_t<Const>)( \/\/$/;"	f	struct:ranges::tokenize_view	typeref:typename:CPP_ret (iterator_t<Const>)(requires range<Rng const>)
begin	include/range/v3/view/tokenize.hpp	/^        iterator_t<simple_view<Rng>()> begin()$/;"	f	struct:ranges::tokenize_view	typeref:typename:iterator_t<simple_view<Rng> ()>
begin	include/range/v3/view/trim.hpp	/^        iterator_t<Rng> begin()$/;"	f	struct:ranges::trim_view	typeref:typename:iterator_t<Rng>
begin	include/range/v3/view/unbounded.hpp	/^        constexpr I begin() const$/;"	f	struct:ranges::unbounded_view	typeref:typename:I
begin	test/p.cpp	/^  aiterator begin() { return aiterator{}; }$/;"	f	struct:tree_iterator	typeref:typename:aiterator	file:
begin_	include/range/v3/utility/memory.hpp	/^        Val * begin_;$/;"	m	struct:ranges::raw_buffer	typeref:typename:Val *
begin_	include/range/v3/view/adjacent_remove_if.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> begin_;$/;"	m	struct:ranges::adjacent_remove_if_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
begin_	include/range/v3/view/drop_while.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> begin_;$/;"	m	struct:ranges::drop_while_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
begin_	include/range/v3/view/remove_if.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> begin_;$/;"	m	struct:ranges::remove_if_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
begin_	include/range/v3/view/reverse.hpp	/^        constexpr reverse_iterator<iterator_t<Rng>> begin_(std::false_type)$/;"	f	struct:ranges::reverse_view	typeref:typename:reverse_iterator<iterator_t<Rng>>
begin_	include/range/v3/view/reverse.hpp	/^        constexpr reverse_iterator<iterator_t<Rng>> begin_(std::true_type)$/;"	f	struct:ranges::reverse_view	typeref:typename:reverse_iterator<iterator_t<Rng>>
begin_	include/range/v3/view/slice.hpp	/^            detail::non_propagating_cache<iterator_t<Rng>> begin_;$/;"	m	struct:ranges::detail::slice_view_	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
begin_	include/range/v3/view/split.hpp	/^        outer_iterator<false> begin_(std::false_type)$/;"	f	struct:ranges::split_view	typeref:typename:outer_iterator<false>
begin_	include/range/v3/view/split.hpp	/^        outer_iterator<simple_view<V>()> begin_(std::true_type)$/;"	f	struct:ranges::split_view	typeref:typename:outer_iterator<simple_view<V> ()>
begin_	include/range/v3/view/trim.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> begin_;$/;"	m	struct:ranges::trim_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
begin_adaptor	include/range/v3/view/adaptor.hpp	/^        constexpr adaptor_base begin_adaptor() const noexcept$/;"	f	struct:ranges::view_adaptor	typeref:typename:adaptor_base
begin_adaptor	include/range/v3/view/adjacent_filter.hpp	/^        constexpr auto begin_adaptor() const noexcept -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::adjacent_filter_view	typeref:typename:CPP_member auto
begin_adaptor	include/range/v3/view/adjacent_filter.hpp	/^        constexpr auto begin_adaptor() noexcept -> adaptor<false>$/;"	f	struct:ranges::adjacent_filter_view	typeref:typename:auto
begin_adaptor	include/range/v3/view/adjacent_remove_if.hpp	/^        constexpr adaptor begin_adaptor()$/;"	f	struct:ranges::adjacent_remove_if_view	typeref:typename:adaptor
begin_adaptor	include/range/v3/view/chunk.hpp	/^        constexpr adaptor<simple_view<Rng>()> begin_adaptor()$/;"	f	struct:ranges::chunk_view_	typeref:typename:adaptor<simple_view<Rng> ()>
begin_adaptor	include/range/v3/view/chunk.hpp	/^        constexpr auto begin_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::chunk_view_	typeref:typename:CPP_ret (adaptor<true>)(requires forward_range<Rng const>)
begin_adaptor	include/range/v3/view/const.hpp	/^        adaptor<simple_view<Rng>()> begin_adaptor()$/;"	f	struct:ranges::const_view	typeref:typename:adaptor<simple_view<Rng> ()>
begin_adaptor	include/range/v3/view/const.hpp	/^        auto begin_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::const_view	typeref:typename:CPP_ret (adaptor<true>)(requires range<Rng const>)
begin_adaptor	include/range/v3/view/drop_last.hpp	/^        adaptor begin_adaptor()$/;"	f	struct:ranges::drop_last_view	typeref:typename:adaptor
begin_adaptor	include/range/v3/view/exclusive_scan.hpp	/^        adaptor<false> begin_adaptor()$/;"	f	struct:ranges::exclusive_scan_view	typeref:typename:adaptor<false>
begin_adaptor	include/range/v3/view/exclusive_scan.hpp	/^        auto begin_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::exclusive_scan_view	typeref:typename:CPP_ret (adaptor<true>)(requires exclusive_scan_constraints<Rng const,T,Fun const>)
begin_adaptor	include/range/v3/view/indirect.hpp	/^        constexpr auto begin_adaptor() const noexcept -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::indirect_view	typeref:typename:CPP_member auto
begin_adaptor	include/range/v3/view/indirect.hpp	/^        constexpr auto begin_adaptor() noexcept -> CPP_ret(adaptor<false>)( \/\/$/;"	f	struct:ranges::indirect_view	typeref:typename:CPP_member auto
begin_adaptor	include/range/v3/view/intersperse.hpp	/^        constexpr auto begin_adaptor() -> cursor_adaptor<false>$/;"	f	struct:ranges::intersperse_view	typeref:typename:cursor_adaptor<false>
begin_adaptor	include/range/v3/view/intersperse.hpp	/^        constexpr auto begin_adaptor() const -> CPP_ret(cursor_adaptor<true>)( \/\/$/;"	f	struct:ranges::intersperse_view	typeref:typename:CPP_ret (cursor_adaptor<true>)(requires range<Rng const>)
begin_adaptor	include/range/v3/view/move.hpp	/^        adaptor<simple_view<Rng>()> begin_adaptor()$/;"	f	struct:ranges::move_view	typeref:typename:adaptor<simple_view<Rng> ()>
begin_adaptor	include/range/v3/view/move.hpp	/^        auto begin_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::move_view	typeref:typename:CPP_ret (adaptor<true>)(requires input_range<Rng const>)
begin_adaptor	include/range/v3/view/remove_if.hpp	/^        constexpr adaptor begin_adaptor()$/;"	f	struct:ranges::remove_if_view	typeref:typename:adaptor
begin_adaptor	include/range/v3/view/sliding.hpp	/^        adaptor begin_adaptor()$/;"	f	struct:ranges::sliding_view	typeref:typename:adaptor
begin_adaptor	include/range/v3/view/sliding.hpp	/^        adaptor<simple_view<Rng>()> begin_adaptor()$/;"	f	struct:ranges::sliding_view	typeref:typename:adaptor<simple_view<Rng> ()>
begin_adaptor	include/range/v3/view/sliding.hpp	/^        auto begin_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::sliding_view	typeref:typename:CPP_ret (adaptor<true>)(requires range<Rng const>)
begin_adaptor	include/range/v3/view/stride.hpp	/^        constexpr auto begin_adaptor() const noexcept$/;"	f	struct:ranges::stride_view	typeref:typename:CPP_member auto
begin_adaptor	include/range/v3/view/stride.hpp	/^        constexpr auto begin_adaptor() noexcept -> adaptor<false>$/;"	f	struct:ranges::stride_view	typeref:typename:auto
begin_adaptor	include/range/v3/view/transform.hpp	/^        adaptor<false> begin_adaptor()$/;"	f	struct:ranges::iter_transform_view	typeref:typename:adaptor<false>
begin_adaptor	include/range/v3/view/transform.hpp	/^        auto begin_adaptor() const -> CPP_ret(adaptor<Const>)( \/\/$/;"	f	struct:ranges::iter_transform_view	typeref:typename:CPP_ret (adaptor<Const>)(requires Const && range<meta::const_if_c<Const,Rng>> && detail::iter_transform_1_readable<Fun const,meta::const_if_c<Const,Rng>>)
begin_adaptor_t	include/range/v3/view/adaptor.hpp	/^        using begin_adaptor_t = detail::decay_t<decltype($/;"	t	namespace:ranges::detail
begin_cursor	example/calendar.cpp	/^    cursor begin_cursor()$/;"	f	class:interleave_view	typeref:typename:cursor	file:
begin_cursor	include/range/v3/experimental/utility/generator.hpp	/^            cursor begin_cursor()$/;"	f	struct:ranges::experimental::generator	typeref:typename:cursor
begin_cursor	include/range/v3/view/adaptor.hpp	/^        constexpr auto begin_cursor() const$/;"	f	struct:ranges::view_adaptor	typeref:typename:auto
begin_cursor	include/range/v3/view/adaptor.hpp	/^        constexpr auto begin_cursor() noexcept($/;"	f	struct:ranges::view_adaptor	typeref:typename:auto
begin_cursor	include/range/v3/view/cache1.hpp	/^        cursor begin_cursor()$/;"	f	struct:ranges::cache1_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/cartesian_product.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:CPP_ret (cursor<true>)(requires cartesian_produce_view_can_const<Views...>)
begin_cursor	include/range/v3/view/cartesian_product.hpp	/^        cursor<false> begin_cursor()$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:cursor<false>
begin_cursor	include/range/v3/view/chunk.hpp	/^        constexpr outer_cursor begin_cursor() noexcept$/;"	f	struct:ranges::chunk_view_	typeref:typename:outer_cursor
begin_cursor	include/range/v3/view/concat.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::concat_view	typeref:typename:CPP_ret (cursor<true>)(requires and_v<range<Rngs const>...>)
begin_cursor	include/range/v3/view/concat.hpp	/^        cursor<meta::and_c<simple_view<Rngs>()...>::value> begin_cursor()$/;"	f	struct:ranges::concat_view	typeref:typename:cursor<meta::and_c<simple_view<Rngs> ()...>::value>
begin_cursor	include/range/v3/view/cycle.hpp	/^        auto begin_cursor() -> CPP_ret(cursor<false>)( \/\/$/;"	f	struct:ranges::cycled_view	typeref:typename:CPP_ret (cursor<false>)(requires (!simple_view<Rng> ()||!common_range<Rng const>))
begin_cursor	include/range/v3/view/cycle.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::cycled_view	typeref:typename:CPP_ret (cursor<true>)(requires common_range<Rng const>)
begin_cursor	include/range/v3/view/enumerate.hpp	/^            cursor begin_cursor() const$/;"	f	struct:ranges::detail::index_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/facade.hpp	/^        constexpr view_as_cursor begin_cursor() const$/;"	f	struct:ranges::view_facade	typeref:typename:view_as_cursor
begin_cursor	include/range/v3/view/generate.hpp	/^        cursor begin_cursor()$/;"	f	struct:ranges::generate_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/generate_n.hpp	/^        cursor begin_cursor()$/;"	f	struct:ranges::generate_n_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/getlines.hpp	/^        cursor begin_cursor()$/;"	f	struct:ranges::getlines_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/group_by.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<Const>)( \/\/$/;"	f	struct:ranges::group_by_view	typeref:typename:CPP_ret (cursor<Const>)(requires Const && range<meta::const_if_c<Const,Rng>> && invocable<Fun const &,range_common_reference_t<meta::const_if_c<Const,Rng>>,range_common_reference_t<meta::const_if_c<Const,Rng>>>)
begin_cursor	include/range/v3/view/group_by.hpp	/^        cursor<false> begin_cursor()$/;"	f	struct:ranges::group_by_view	typeref:typename:cursor<false>
begin_cursor	include/range/v3/view/iota.hpp	/^        cursor begin_cursor() const$/;"	f	struct:ranges::closed_iota_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/iota.hpp	/^        cursor begin_cursor() const$/;"	f	struct:ranges::iota_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/istream.hpp	/^        cursor begin_cursor()$/;"	f	struct:ranges::istream_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/join.hpp	/^        constexpr auto begin_cursor() const -> CPP_ret(cursor<Const>)( \/\/$/;"	f	struct:ranges::join_view	typeref:typename:CPP_ret (cursor<Const>)(requires Const && input_range<meta::const_if_c<Const,Rng>> && std::is_reference<range_reference_t<meta::const_if_c<Const,Rng>>>::value)
begin_cursor	include/range/v3/view/join.hpp	/^        constexpr cursor<use_const_always()> begin_cursor()$/;"	f	struct:ranges::join_view	typeref:typename:cursor<use_const_always ()>
begin_cursor	include/range/v3/view/join.hpp	/^        cursor begin_cursor()$/;"	f	struct:ranges::join_with_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/partial_sum.hpp	/^        constexpr auto begin_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::partial_sum_view	typeref:typename:CPP_ret (cursor<true>)(requires detail::partial_sum_view_constraints<CRng,Fun const>)
begin_cursor	include/range/v3/view/partial_sum.hpp	/^        constexpr cursor<false> begin_cursor()$/;"	f	struct:ranges::partial_sum_view	typeref:typename:cursor<false>
begin_cursor	include/range/v3/view/repeat.hpp	/^        cursor begin_cursor() const$/;"	f	struct:ranges::repeat_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/repeat_n.hpp	/^        cursor begin_cursor() const$/;"	f	struct:ranges::repeat_n_view	typeref:typename:cursor
begin_cursor	include/range/v3/view/sample.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<Const>)( \/\/$/;"	f	class:ranges::sample_view	typeref:typename:CPP_ret (cursor<Const>)(requires Const && (sized_range<meta::const_if_c<Const,Rng>>||sized_sentinel_for<sentinel_t<meta::const_if_c<Const,Rng>>,iterator_t<meta::const_if_c<Const,Rng>>>||forward_range<meta::const_if_c<Const,Rng>>))
begin_cursor	include/range/v3/view/sample.hpp	/^        cursor<false> begin_cursor()$/;"	f	class:ranges::sample_view	typeref:typename:cursor<false>
begin_cursor	include/range/v3/view/set_algorithm.hpp	/^            auto begin_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::detail::set_algorithm_view	typeref:typename:CPP_ret (cursor<true>)(requires range<Rng1 const> && range<Rng2 const>)
begin_cursor	include/range/v3/view/set_algorithm.hpp	/^            cursor<simple_view<Rng1>() && simple_view<Rng2>()> begin_cursor()$/;"	f	struct:ranges::detail::set_algorithm_view	typeref:typename:cursor<simple_view<Rng1> ()&& simple_view<Rng2> ()>
begin_cursor	include/range/v3/view/split_when.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<Const>)( \/\/$/;"	f	struct:ranges::split_when_view	typeref:typename:CPP_ret (cursor<Const>)(requires Const && range<meta::const_if_c<Const,Rng>> && invocable<Fun const &,iterator_t<meta::const_if_c<Const,Rng>>,sentinel_t<meta::const_if_c<Const,Rng>>>)
begin_cursor	include/range/v3/view/split_when.hpp	/^        cursor<false> begin_cursor()$/;"	f	struct:ranges::split_when_view	typeref:typename:cursor<false>
begin_cursor	include/range/v3/view/transform.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::iter_transform2_view	typeref:typename:CPP_ret (cursor<true>)(requires Const && range<meta::const_if_c<Const,Rng1>> && range<meta::const_if_c<Const,Rng2>> && detail::iter_transform_2_readable<Fun const,meta::const_if_c<Const,Rng1>,meta::const_if_c<Const,Rng2>>)
begin_cursor	include/range/v3/view/transform.hpp	/^        cursor<simple_view<Rng1>() && simple_view<Rng2>()> begin_cursor()$/;"	f	struct:ranges::iter_transform2_view	typeref:typename:cursor<simple_view<Rng1> ()&& simple_view<Rng2> ()>
begin_cursor	include/range/v3/view/zip_with.hpp	/^        auto begin_cursor() const -> CPP_ret(cursor<Const>)( \/\/$/;"	f	struct:ranges::iter_zip_with_view	typeref:typename:CPP_ret (cursor<Const>)(requires Const && and_v<range<Rngs const>...> && views::zippable_with<Fun,meta::if_c<Const,Rngs const>...>)
begin_cursor	include/range/v3/view/zip_with.hpp	/^        cursor<false> begin_cursor()$/;"	f	struct:ranges::iter_zip_with_view	typeref:typename:cursor<false>
begin_cursor_	include/range/v3/view/adaptor.hpp	/^        static constexpr adaptor_cursor_t<D> begin_cursor_(D & d) noexcept(noexcept($/;"	f	struct:ranges::view_adaptor	typeref:typename:adaptor_cursor_t<D>
begin_cursor_t	include/range/v3/view/facade.hpp	/^        using begin_cursor_t = detail::decay_t<decltype($/;"	t	namespace:ranges::detail
begin_random_access_	include/range/v3/view/take.hpp	/^        static auto begin_random_access_(Take & take, std::false_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
begin_random_access_	include/range/v3/view/take.hpp	/^        static auto begin_random_access_(Take & take, std::true_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
begin_sized_	include/range/v3/view/take.hpp	/^        static auto begin_sized_(Take & take, std::false_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
begin_sized_	include/range/v3/view/take.hpp	/^        static auto begin_sized_(Take & take, std::true_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
benchmark	example/comprehensions.cpp	/^void benchmark() {$/;"	f	typeref:typename:void
bidi	include/range/v3/view/drop_last.hpp	/^                bidi,$/;"	e	enum:ranges::detail::drop_last_view::mode_enum
bidirectional	include/range/v3/view/any_view.hpp	/^        bidirectional = 7,    \/\/\/<\\brief satisfies ranges::concepts::bidirectional_range$/;"	e	enum:ranges::category
bidirectional_cursor_tag	include/range/v3/detail/range_access.hpp	/^        using bidirectional_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<bidirectional_cursor_concept,forward_cursor_tag>
bidirectional_iterator_tag	include/range/v3/iterator/traits.hpp	/^    using bidirectional_iterator_tag RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:std::bidirectional_iterator_tag
bidirectional_iterator_tag_	include/range/v3/iterator/traits.hpp	/^        using bidirectional_iterator_tag_ =$/;"	t	namespace:ranges::detail	typeref:typename:::concepts::tag<bidirectional_iterator_concept,forward_iterator_tag_>
bidirectional_range_tag	include/range/v3/range/concepts.hpp	/^    using bidirectional_range_tag =$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<bidirectional_range_concept,forward_range_tag>
binary_transform_result	include/range/v3/algorithm/transform.hpp	/^    using binary_transform_result = detail::in1_in2_out_result<I1, I2, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_in2_out_result<I1,I2,O>
bind_	include/range/v3/functional/bind.hpp	/^        Bind bind_;$/;"	m	struct:ranges::protector	typeref:typename:Bind
bind_back_fn	include/range/v3/functional/bind_back.hpp	/^        using bind_back_fn = bind_back_fn_<decay_t<Fn>, decay_t<Args>...>;$/;"	t	namespace:ranges::detail	typeref:typename:bind_back_fn_<decay_t<Fn>,decay_t<Args>...>
bind_back_fn	include/range/v3/functional/bind_back.hpp	/^    struct bind_back_fn$/;"	s	namespace:ranges
bind_back_fn_	include/range/v3/functional/bind_back.hpp	/^        struct bind_back_fn_$/;"	s	namespace:ranges::detail
bind_back_fn_	include/range/v3/functional/bind_back.hpp	/^        struct bind_back_fn_<Fn, Arg0, Arg1>$/;"	s	namespace:ranges::detail
bind_back_fn_	include/range/v3/functional/bind_back.hpp	/^        struct bind_back_fn_<Fn, Arg>$/;"	s	namespace:ranges::detail
bind_element	include/range/v3/functional/bind.hpp	/^    struct bind_element$/;"	s	namespace:ranges
bind_element_t	include/range/v3/functional/bind.hpp	/^    using bind_element_t = meta::_t<bind_element<T>>;$/;"	t	namespace:ranges	typeref:typename:meta::_t<bind_element<T>>
bind_forward	include/range/v3/functional/bind.hpp	/^    T && bind_forward(meta::_t<std::remove_reference<T>> && t) noexcept$/;"	f	namespace:ranges	typeref:typename:T &&
bit_and	include/meta/meta.hpp	/^        using bit_and = defer<bit_and, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<bit_and,T,U>
bit_and	include/meta/meta.hpp	/^    using bit_and = std::integral_constant<decltype(T::type::value & U::type::value),$/;"	t	namespace:meta
bit_not	include/meta/meta.hpp	/^        using bit_not = defer<bit_not, T>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<bit_not,T>
bit_not	include/meta/meta.hpp	/^    using bit_not = std::integral_constant<decltype(~T::type::value), ~T::type::value>;$/;"	t	namespace:meta
bit_or	include/meta/meta.hpp	/^        using bit_or = defer<bit_or, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<bit_or,T,U>
bit_or	include/meta/meta.hpp	/^    using bit_or = std::integral_constant<decltype(T::type::value | U::type::value),$/;"	t	namespace:meta
bit_xor	include/meta/meta.hpp	/^        using bit_xor = defer<bit_xor, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<bit_xor,T,U>
bit_xor	include/meta/meta.hpp	/^    using bit_xor = std::integral_constant<decltype(T::type::value ^ U::type::value),$/;"	t	namespace:meta
bitwise_or	include/range/v3/functional/arithmetic.hpp	/^    struct bitwise_or$/;"	s	namespace:ranges
bool_	include/concepts/concepts.hpp	/^    using bool_ = std::integral_constant<bool, B>;$/;"	t	namespace:concepts	typeref:typename:std::integral_constant<bool,B>
bool_	include/meta/meta.hpp	/^    using bool_ = std::integral_constant<bool, B>;$/;"	t	namespace:meta	typeref:typename:std::integral_constant<bool,B>
boolean	include/concepts/concepts.hpp	/^        struct boolean$/;"	s	namespace:concepts::detail
boost	example/calendar.cpp	/^namespace boost$/;"	n	file:
boost	include/range/v3/detail/satisfy_boost_range.hpp	/^namespace boost$/;"	n
bounded_	include/range/v3/iterator/operations.hpp	/^    constexpr iter_difference_t<I> advance_fn::bounded_($/;"	f	class:ranges::advance_fn	typeref:typename:iter_difference_t<I>
bounded_	include/range/v3/iterator/operations.hpp	/^    constexpr iter_difference_t<I> advance_fn::bounded_(I & it, iter_difference_t<I> n,$/;"	f	class:ranges::advance_fn	typeref:typename:iter_difference_t<I>
bounded_t	include/range/v3/view/common.hpp	/^        using bounded_t RANGES_DEPRECATED("The name views::bounded_t is deprecated.") =$/;"	t	namespace:ranges::views
bounded_view	include/range/v3/view/common.hpp	/^    using bounded_view RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:common_view<Rng>
box	include/range/v3/utility/box.hpp	/^    class box$/;"	c	namespace:ranges
box	include/range/v3/utility/box.hpp	/^    class box<Element, Tag, detail::box_compress::coalesce>$/;"	c	namespace:ranges
box	include/range/v3/utility/box.hpp	/^    class box<Element, Tag, detail::box_compress::ebo> : Element$/;"	c	namespace:ranges
box_compress	include/range/v3/utility/box.hpp	/^        enum class box_compress$/;"	g	namespace:ranges::detail
box_compression	include/range/v3/utility/box.hpp	/^        constexpr box_compress box_compression()$/;"	f	namespace:ranges::detail	typeref:typename:box_compress
box_compression_	include/range/v3/utility/box.hpp	/^        constexpr box_compress box_compression_(...)$/;"	f	namespace:ranges::detail	typeref:typename:box_compress
box_compression_	include/range/v3/utility/box.hpp	/^        constexpr box_compress box_compression_(int)$/;"	f	namespace:ranges::detail	typeref:typename:box_compress
box_compression_	include/range/v3/utility/box.hpp	/^        constexpr box_compress box_compression_(long)$/;"	f	namespace:ranges::detail	typeref:typename:box_compress
box_t	include/range/v3/view/any_view.hpp	/^            using box_t = typename any_view_sentinel_impl::box;$/;"	t	struct:ranges::detail::any_view_sentinel_impl	typeref:typename:any_view_sentinel_impl::box
by_month	example/calendar.cpp	/^by_month()$/;"	f	typeref:typename:auto
by_week	example/calendar.cpp	/^by_week()$/;"	f	typeref:typename:auto
byte_size	include/range/v3/view/span.hpp	/^        constexpr span_index_t byte_size(span_index_t n) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:span_index_t
c	include/git.hpp	/^  C c;$/;"	m	struct:git::make	typeref:typename:C
c	include/git.hpp	/^  C c;$/;"	m	struct:git::make2	typeref:typename:C
c	include/range/v3/utility/variant.hpp	/^                char c;$/;"	m	union:ranges::detail::indexed_datum::__anon577c80ba010a	typeref:typename:char
c_str_fn	include/range/v3/view/c_str.hpp	/^        struct c_str_fn$/;"	s	namespace:ranges::views
cache	include/range/v3/view/sliding.hpp	/^            optional<iterator_t<Rng>> & cache() &$/;"	f	struct:ranges::sliding_view_detail::sv_base	typeref:typename:optional<iterator_t<Rng>> &
cache	include/range/v3/view/sliding.hpp	/^            optional<iterator_t<Rng>> const & cache() const &$/;"	f	struct:ranges::sliding_view_detail::sv_base	typeref:typename:optional<iterator_t<Rng>> const &
cache	include/range/v3/view/sliding.hpp	/^        enum class cache$/;"	g	namespace:ranges::sliding_view_detail
cache1_fn	include/range/v3/view/cache1.hpp	/^        struct cache1_fn$/;"	s	namespace:ranges::views
cache1_view	include/range/v3/view/cache1.hpp	/^        constexpr explicit cache1_view(Rng rng)$/;"	f	struct:ranges::cache1_view
cache1_view	include/range/v3/view/cache1.hpp	/^    struct cache1_view : view_facade<cache1_view<Rng>, range_cardinality<Rng>::value>$/;"	s	namespace:ranges
cache_	include/range/v3/iterator/basic_iterator.hpp	/^            Value cache_;$/;"	m	struct:ranges::postfix_increment_proxy	typeref:typename:Value
cache_	include/range/v3/view/cache1.hpp	/^        detail::non_propagating_cache<range_value_t<Rng>> cache_;$/;"	m	struct:ranges::cache1_view	typeref:typename:detail::non_propagating_cache<range_value_t<Rng>>
cache_begin	include/range/v3/view/adjacent_remove_if.hpp	/^        void cache_begin()$/;"	f	struct:ranges::adjacent_remove_if_view	typeref:typename:void
cache_begin	include/range/v3/view/remove_if.hpp	/^        constexpr void cache_begin()$/;"	f	struct:ranges::remove_if_view	typeref:typename:void
cache_t	include/range/v3/view/cycle.hpp	/^        using cache_t = detail::non_propagating_cache<iterator_t<Rng>, cycled_view<Rng>,$/;"	t	struct:ranges::cycled_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>,cycled_view<Rng>,!common_range<Rng>>
cache_t	include/range/v3/view/drop.hpp	/^            using cache_t =$/;"	t	function:ranges::drop_view::get_begin_	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>,drop_view<Rng>>
cache_t	include/range/v3/view/drop_exactly.hpp	/^            using cache_t =$/;"	t	function:ranges::drop_exactly_view::get_begin_	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>,drop_exactly_view<Rng>>
cache_t	include/range/v3/view/reverse.hpp	/^            using cache_t =$/;"	t	function:ranges::reverse_view::begin_	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>,reverse_view<Rng>>
cache_t	include/range/v3/view/sliding.hpp	/^            using cache_t = detail::non_propagating_cache<iterator_t<Rng>, sv_base<Rng>>;$/;"	t	struct:ranges::sliding_view_detail::sv_base	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>,sv_base<Rng>>
cached	include/range/v3/view/generate.hpp	/^        result_t & cached()$/;"	f	struct:ranges::generate_view	typeref:typename:result_t &
cached	include/range/v3/view/generate_n.hpp	/^        result_t & cached()$/;"	f	struct:ranges::generate_n_view	typeref:typename:result_t &
cached	include/range/v3/view/getlines.hpp	/^        std::string & cached() noexcept$/;"	f	struct:ranges::getlines_view	typeref:typename:std::string &
cached	include/range/v3/view/istream.hpp	/^        Val & cached() noexcept$/;"	f	struct:ranges::istream_view	typeref:typename:Val &
caching	include/range/v3/view/sliding.hpp	/^        using caching = std::integral_constant<$/;"	t	namespace:ranges::sliding_view_detail
calc_offset	include/range/v3/view/stride.hpp	/^            constexpr range_difference_t<Rng> calc_offset(std::false_type) const noexcept$/;"	f	struct:ranges::detail::stride_view_base_	typeref:typename:range_difference_t<Rng>
calc_offset	include/range/v3/view/stride.hpp	/^            constexpr range_difference_t<Rng> calc_offset(std::true_type)$/;"	f	struct:ranges::detail::stride_view_base_	typeref:typename:range_difference_t<Rng>
calendar	example/CMakeLists.txt	/^        add_executable(calendar calendar.cpp)$/;"	t
can_bound	include/range/v3/view/stride.hpp	/^        static constexpr bool can_bound() noexcept$/;"	f	struct:ranges::stride_view	typeref:typename:bool
can_convert	include/range/v3/utility/tagged_pair.hpp	/^        struct can_convert$/;"	s	class:ranges::tagged
can_sized_sentinel_	include/range/v3/view/chunk.hpp	/^        constexpr bool can_sized_sentinel_() noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
cartesian_product_cardinality	include/range/v3/view/cartesian_product.hpp	/^        using cartesian_product_cardinality =$/;"	t	namespace:ranges::detail
cartesian_product_fn	include/range/v3/view/cartesian_product.hpp	/^        struct cartesian_product_fn$/;"	s	namespace:ranges::views
cartesian_product_view	include/range/v3/view/cartesian_product.hpp	/^        explicit constexpr cartesian_product_view(Views... views)$/;"	f	struct:ranges::cartesian_product_view
cartesian_product_view	include/range/v3/view/cartesian_product.hpp	/^    struct cartesian_product_view$/;"	s	namespace:ranges
cartesian_size_fn	include/range/v3/view/cartesian_product.hpp	/^        struct cartesian_size_fn$/;"	s	namespace:ranges::detail
category	include/range/v3/view/any_view.hpp	/^    enum class category$/;"	g	namespace:ranges
cend_cursor_fn	include/range/v3/view/join.hpp	/^        struct cend_cursor_fn$/;"	s	struct:ranges::join_view
ch_	include/range/v3/utility/semiregular_box.hpp	/^            char ch_{};$/;"	m	union:ranges::semiregular_box::__anonf59fc86d010a	typeref:typename:char
ch_t	include/range/v3/view/c_str.hpp	/^                using ch_t = meta::_t<std::remove_cv<Char>>;$/;"	t	function:ranges::views::c_str_fn::operator ()	typeref:typename:meta::_t<std::remove_cv<Char>>
char_	include/meta/meta.hpp	/^    using char_ = std::integral_constant<char, Ch>;$/;"	t	namespace:meta	typeref:typename:std::integral_constant<char,Ch>
char_type	include/range/v3/iterator/stream_iterators.hpp	/^        typedef Char char_type;$/;"	t	struct:ranges::ostreambuf_iterator	typeref:typename:Char
char_type	include/range/v3/iterator/stream_iterators.hpp	/^        using char_type = Char;$/;"	t	struct:ranges::ostream_iterator	typeref:typename:Char
char_type	include/range/v3/iterator/stream_iterators.hpp	/^        using char_type = Char;$/;"	t	struct:ranges::ostream_joiner	typeref:typename:Char
check_at_end_	include/range/v3/view/cartesian_product.hpp	/^            void check_at_end_(meta::size_t<1>, bool at_end = false)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:RANGES_DIAGNOSTIC_POP void
check_at_end_	include/range/v3/view/cartesian_product.hpp	/^            void check_at_end_(meta::size_t<N>, bool at_end = false)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
check_bounds_	include/range/v3/view/iota.hpp	/^        constexpr void check_bounds_(std::false_type)$/;"	f	struct:ranges::closed_iota_view	typeref:typename:void
check_bounds_	include/range/v3/view/iota.hpp	/^        constexpr void check_bounds_(std::false_type)$/;"	f	struct:ranges::iota_view	typeref:typename:void
check_bounds_	include/range/v3/view/iota.hpp	/^        constexpr void check_bounds_(std::true_type)$/;"	f	struct:ranges::closed_iota_view	typeref:typename:void
check_bounds_	include/range/v3/view/iota.hpp	/^        constexpr void check_bounds_(std::true_type)$/;"	f	struct:ranges::iota_view	typeref:typename:void
check_throw	include/range/v3/range/operations.hpp	/^        static constexpr void check_throw(Rng && rng, range_difference_t<Rng> n)$/;"	f	struct:ranges::at_fn	typeref:typename:void
chunk_base_fn	include/range/v3/view/chunk.hpp	/^        struct chunk_base_fn$/;"	s	namespace:ranges::views
chunk_fn	include/range/v3/view/chunk.hpp	/^        struct chunk_fn : chunk_base_fn$/;"	s	namespace:ranges::views
chunk_insertion_sort	include/range/v3/algorithm/stable_sort.hpp	/^        void chunk_insertion_sort(I first, I last, D chunk_size, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
chunk_view	include/range/v3/view/chunk.hpp	/^    struct chunk_view : chunk_view_<Rng, (bool)forward_range<Rng>>$/;"	s	namespace:ranges
chunk_view_	include/range/v3/view/chunk.hpp	/^        constexpr chunk_view_(Rng rng, range_difference_t<Rng> n)$/;"	f	struct:ranges::chunk_view_
chunk_view_	include/range/v3/view/chunk.hpp	/^    struct chunk_view_$/;"	s	namespace:ranges
chunk_view_	include/range/v3/view/chunk.hpp	/^    struct chunk_view_<Rng, false>$/;"	s	namespace:ranges
cidata	include/range/v3/iterator/common_iterator.hpp	/^        variant<I, S> & cidata(common_iterator<I, S> & that)$/;"	f	namespace:ranges::detail	typeref:typename:variant<I,S> &
cidata	include/range/v3/iterator/common_iterator.hpp	/^        variant<I, S> const & cidata(common_iterator<I, S> const & that)$/;"	f	namespace:ranges::detail	typeref:typename:variant<I,S> const &
clear	include/range/v3/utility/any.hpp	/^        void clear() noexcept$/;"	f	struct:ranges::any	typeref:typename:void
clear_	include/range/v3/detail/variant.hpp	/^        void clear_() noexcept$/;"	f	struct:ranges::variant	typeref:typename:void
clone	include/range/v3/utility/any.hpp	/^            impl * clone() const override$/;"	f	struct:ranges::any::impl	typeref:typename:impl *
cloneable	include/range/v3/view/any_view.hpp	/^        struct cloneable : Base$/;"	s	namespace:ranges::detail
closed_indices_fn	include/range/v3/view/indices.hpp	/^        struct closed_indices_fn$/;"	s	namespace:ranges::views
closed_iota_fn	include/range/v3/view/iota.hpp	/^        struct closed_iota_fn$/;"	s	namespace:ranges::views
closed_iota_view	include/range/v3/view/iota.hpp	/^        constexpr closed_iota_view(meta::id_t<From> from, meta::id_t<To> to)$/;"	f	struct:ranges::closed_iota_view
closed_iota_view	include/range/v3/view/iota.hpp	/^    struct RANGES_EMPTY_BASES closed_iota_view$/;"	s	namespace:ranges
cnt_	include/range/v3/iterator/counted_iterator.hpp	/^        iter_difference_t<I> cnt_{0};$/;"	m	struct:ranges::counted_iterator	typeref:typename:iter_difference_t<I>
coalesce	include/range/v3/utility/box.hpp	/^            coalesce \/\/ Coalesce all Ts into one T: get() returns a reference to a static$/;"	e	enum:ranges::detail::box_compress
coerce	include/range/v3/functional/arithmetic.hpp	/^    struct coerce$/;"	s	namespace:ranges
coerce	include/range/v3/functional/arithmetic.hpp	/^    struct coerce<T &&> : coerce<T>$/;"	s	namespace:ranges
coerce	include/range/v3/functional/arithmetic.hpp	/^    struct coerce<T &> : coerce<T>$/;"	s	namespace:ranges
coerce	include/range/v3/functional/arithmetic.hpp	/^    struct coerce<T const> : coerce<T>$/;"	s	namespace:ranges
coerce	include/range/v3/functional/invoke.hpp	/^        static constexpr auto coerce(T1 && t1, int) noexcept -> CPP_ret(T1 &&)( \/\/$/;"	f	struct:ranges::invoke_fn	typeref:typename:auto
coerce_indices_	include/meta/meta.hpp	/^        struct coerce_indices_$/;"	s	namespace:meta::detail
commit	test/git.cpp	/^lr::LR<git_oid> commit(const char *, lr::LR<git_oid> &&tree,$/;"	f	namespace:git	typeref:typename:lr::LR<git_oid>
common_fn	include/range/v3/view/common.hpp	/^        struct common_fn$/;"	s	namespace:ranges::views
common_iterator	include/range/v3/iterator/common_iterator.hpp	/^        common_iterator(I i)$/;"	f	struct:ranges::common_iterator
common_iterator	include/range/v3/iterator/common_iterator.hpp	/^        common_iterator(S s)$/;"	f	struct:ranges::common_iterator
common_iterator	include/range/v3/iterator/common_iterator.hpp	/^    struct common_iterator$/;"	s	namespace:ranges
common_iterator_impl_t	include/range/v3/range/traits.hpp	/^        using common_iterator_impl_t =$/;"	t	namespace:ranges::detail
common_iterator_std_traits	include/range/v3/iterator/common_iterator.hpp	/^        struct common_iterator_std_traits : decltype(detail::demote_common_iter_cat<I>(0))$/;"	s	struct:ranges::detail
common_iterator_std_traits	include/range/v3/iterator/common_iterator.hpp	/^        struct common_iterator_std_traits<I, false>$/;"	s	struct:ranges::detail
common_iterator_t	include/range/v3/range/traits.hpp	/^    using common_iterator_t = detail::if_then_t<std::is_same<I, S>::value, I,$/;"	t	namespace:ranges	typeref:typename:detail::if_then_t<std::is_same<I,S>::value,I,detail::common_iterator_impl_t<I,S>>
common_pair	include/range/v3/utility/common_tuple.hpp	/^    struct common_pair : std::pair<F, S>$/;"	s	namespace:ranges
common_range_tag	include/range/v3/range/concepts.hpp	/^    using common_range_tag = ::concepts::tag<common_range_concept, range_tag>;$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<common_range_concept,range_tag>
common_range_tag_of	include/range/v3/range/concepts.hpp	/^    using common_range_tag_of =$/;"	t	namespace:ranges	typeref:typename:::concepts::tag_of<meta::list<common_range_concept,range_concept>,T>
common_ref_tuple_like	include/range/v3/utility/common_tuple.hpp	/^        struct common_ref_tuple_like$/;"	s	namespace:ranges::detail
common_reference	include/range/v3/iterator/basic_iterator.hpp	/^            using common_reference = common_reference_t<reference, value_type &>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:common_reference_t<reference,value_type &>
common_reference	include/range/v3/utility/common_type.hpp	/^    using common_reference = concepts::common_reference<Ts...>;$/;"	t	namespace:ranges	typeref:typename:concepts::common_reference<Ts...>
common_reference_t	include/range/v3/utility/common_type.hpp	/^    using common_reference_t = concepts::common_reference_t<Ts...>;$/;"	t	namespace:ranges	typeref:typename:concepts::common_reference_t<Ts...>
common_refs	include/range/v3/iterator/basic_iterator.hpp	/^            using common_refs = meta::list<>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:meta::list<>
common_refs	include/range/v3/iterator/basic_iterator.hpp	/^            using common_refs = meta::unique<meta::pop_front<tmp3>>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:meta::unique<meta::pop_front<tmp3>>
common_tuple	include/range/v3/utility/common_tuple.hpp	/^        common_tuple(That && that, meta::index_sequence<Is...>)$/;"	f	struct:ranges::common_tuple
common_tuple	include/range/v3/utility/common_tuple.hpp	/^    struct common_tuple : _tuple_wrapper_::forward_tuple_interface<std::tuple<Ts...>>$/;"	s	namespace:ranges
common_type	include/concepts/type_traits.hpp	/^    struct common_type$/;"	s	namespace:concepts
common_type	include/concepts/type_traits.hpp	/^    struct common_type<T, U, Vs...>$/;"	s	namespace:concepts
common_type	include/concepts/type_traits.hpp	/^    struct common_type<T, U>$/;"	s	namespace:concepts
common_type	include/concepts/type_traits.hpp	/^    struct common_type<T>$/;"	s	namespace:concepts
common_type	include/range/v3/utility/common_type.hpp	/^    using common_type = concepts::common_type<Ts...>;$/;"	t	namespace:ranges	typeref:typename:concepts::common_type<Ts...>
common_type_t	include/concepts/type_traits.hpp	/^    using common_type_t = typename common_type<Ts...>::type;$/;"	t	namespace:concepts	typeref:typename:common_type<Ts...>::type
common_type_t	include/range/v3/utility/common_type.hpp	/^    using common_type_t = concepts::common_type_t<Ts...>;$/;"	t	namespace:ranges	typeref:typename:concepts::common_type_t<Ts...>
common_type_tuple_like	include/range/v3/utility/common_tuple.hpp	/^        struct common_type_tuple_like$/;"	s	namespace:ranges::detail
common_view	include/range/v3/view/common.hpp	/^            using common_view = ranges::common_view<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::common_view<Rng>
common_view	include/range/v3/view/common.hpp	/^        explicit common_view(Rng rng)$/;"	f	struct:ranges::common_view
common_view	include/range/v3/view/common.hpp	/^    struct common_view : view_interface<common_view<Rng>, range_cardinality<Rng>::value>$/;"	s	namespace:ranges
common_view	include/range/v3/view/common.hpp	/^    struct common_view<Rng, true> : identity_adaptor<Rng>$/;"	s	namespace:ranges
common_view_iterator_t	include/range/v3/view/common.hpp	/^        using common_view_iterator_t =$/;"	t	namespace:ranges::detail	typeref:typename:meta::if_c<random_access_and_sized_range<R>,iterator_t<R>,common_iterator_t<iterator_t<R>,sentinel_t<R>>>
compl_if	include/range/v3/iterator/diffmax_t.hpp	/^            static constexpr std::uintmax_t compl_if(bool neg,$/;"	f	struct:ranges::detail::diffmax_t	typeref:typename:std::uintmax_t
compose_fn	include/range/v3/functional/compose.hpp	/^    struct compose_fn$/;"	s	namespace:ranges
composed	include/range/v3/functional/compose.hpp	/^        constexpr composed(Second second, First first)$/;"	f	struct:ranges::composed
composed	include/range/v3/functional/compose.hpp	/^    struct composed$/;"	s	namespace:ranges
compressed_pair	include/range/v3/utility/compressed_pair.hpp	/^    struct RANGES_EMPTY_BASES compressed_pair$/;"	s	namespace:ranges
compressed_tuple	include/range/v3/utility/compressed_pair.hpp	/^        using compressed_tuple RANGES_DEPRECATED($/;"	t	namespace:ranges::compressed_tuple_detail
compressed_tuple_	include/range/v3/utility/compressed_pair.hpp	/^            compressed_tuple_<meta::list<Ts...>, meta::index_sequence<Is...>>$/;"	v	namespace:ranges::compressed_tuple_detail	typeref:struct:RANGES_EMPTY_BASES
compressed_tuple_detail	include/range/v3/utility/compressed_pair.hpp	/^    namespace compressed_tuple_detail$/;"	n	namespace:ranges
concat_cardinality	include/range/v3/view/concat.hpp	/^        using concat_cardinality =$/;"	t	namespace:ranges::detail
concat_cardinality_	include/range/v3/view/concat.hpp	/^        using concat_cardinality_ = std::integral_constant<$/;"	t	namespace:ranges::detail
concat_fn	include/range/v3/view/concat.hpp	/^        struct concat_fn$/;"	s	namespace:ranges::views
concat_indices_	include/meta/meta.hpp	/^        struct concat_indices_$/;"	s	namespace:meta::detail
concat_view	include/range/v3/view/concat.hpp	/^        explicit concat_view(Rngs... rngs)$/;"	f	struct:ranges::concat_view
concat_view	include/range/v3/view/concat.hpp	/^    struct concat_view$/;"	s	namespace:ranges
concat_view_t	include/range/v3/view/concat.hpp	/^            using concat_view_t = constify_if<concat_view>;$/;"	t	struct:ranges::concat_view::cursor	typeref:typename:constify_if<concat_view>
concat_view_t	include/range/v3/view/concat.hpp	/^            using concat_view_t = constify_if<concat_view>;$/;"	t	struct:ranges::concat_view::sentinel	typeref:typename:constify_if<concat_view>
concepts	include/concepts/concepts.hpp	/^namespace concepts$/;"	n
concepts	include/concepts/swap.hpp	/^namespace concepts$/;"	n
concepts	include/concepts/type_traits.hpp	/^namespace concepts$/;"	n
concepts	include/range/v3/utility/common_tuple.hpp	/^namespace concepts$/;"	n
concepts	include/range/v3/utility/common_type.hpp	/^namespace concepts$/;"	n
cond	include/range/v3/view/join.hpp	/^            using cond =$/;"	t	function:ranges::join_view::CPP_fun
cond	include/range/v3/view/join.hpp	/^            using cond =$/;"	t	function:ranges::join_view::end_cursor
const_fn	include/range/v3/view/const.hpp	/^        struct const_fn$/;"	s	namespace:ranges::views
const_iterable	include/range/v3/view/stride.hpp	/^        static constexpr bool const_iterable() noexcept$/;"	f	struct:ranges::stride_view	typeref:typename:bool
const_iterator	include/range/v3/iterator_range.hpp	/^        using const_iterator = I; \/\/ Mostly to avoid spurious errors in Boost.Range$/;"	t	struct:ranges::iterator_range	typeref:typename:I
const_iterator	include/range/v3/iterator_range.hpp	/^        using const_iterator = I; \/\/ Mostly to avoid spurious errors in Boost.Range$/;"	t	struct:ranges::sized_iterator_range	typeref:typename:I
const_reference_t	include/range/v3/iterator/basic_iterator.hpp	/^            using const_reference_t = basic_proxy_reference<Cur const>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:basic_proxy_reference<Cur const>
const_reference_t	include/range/v3/iterator/basic_iterator.hpp	/^            using const_reference_t =$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:if_then_t<is_writable_cursor<Cur const>::value,basic_proxy_reference<Cur const>,cursor_reference_t<Cur>>
const_view	include/range/v3/view/const.hpp	/^        explicit const_view(Rng rng)$/;"	f	struct:ranges::const_view
const_view	include/range/v3/view/const.hpp	/^    struct const_view : view_adaptor<const_view<Rng>, Rng>$/;"	s	namespace:ranges
constant	include/range/v3/utility/box.hpp	/^        constexpr explicit constant(T const &)$/;"	f	struct:ranges::constant
constant	include/range/v3/utility/box.hpp	/^    struct RANGES_DEPRECATED("The ranges::constant class template is deprecated") constant$/;"	s	namespace:ranges
constify_if	include/range/v3/view/cartesian_product.hpp	/^            using constify_if = meta::const_if_c<IsConst_, T>;$/;"	t	struct:ranges::cartesian_product_view::cursor	typeref:typename:meta::const_if_c<IsConst_,T>
constify_if	include/range/v3/view/concat.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::concat_view::cursor	typeref:typename:meta::const_if_c<IsConst,T>
constify_if	include/range/v3/view/concat.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::concat_view::sentinel	typeref:typename:meta::const_if_c<IsConst,T>
constify_if	include/range/v3/view/cycle.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::cycled_view::cursor	typeref:typename:meta::const_if_c<IsConst,T>
constify_if	include/range/v3/view/set_algorithm.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:meta::const_if_c<IsConst,T>
constify_if	include/range/v3/view/set_algorithm.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:meta::const_if_c<IsConst,T>
constify_if	include/range/v3/view/set_algorithm.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:meta::const_if_c<IsConst,T>
constify_if	include/range/v3/view/set_algorithm.hpp	/^            using constify_if = meta::const_if_c<IsConst, T>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:meta::const_if_c<IsConst,T>
construct_	include/range/v3/detail/variant.hpp	/^            void construct_(U & u, meta::index_sequence<Is...>) noexcept($/;"	f	struct:ranges::detail::construct_fn	typeref:typename:void
construct_fn	include/range/v3/detail/variant.hpp	/^            construct_fn(Ts &&... ts) noexcept($/;"	f	struct:ranges::detail::construct_fn
construct_fn	include/range/v3/detail/variant.hpp	/^        struct construct_fn$/;"	s	namespace:ranges::detail
construct_from	include/range/v3/utility/optional.hpp	/^                auto construct_from(Args &&... args) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:auto
construct_from	include/range/v3/utility/optional.hpp	/^                constexpr auto construct_from(U && ref) noexcept -> CPP_ret(T &)( \/\/$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:auto
construct_from	include/range/v3/utility/semiregular_box.hpp	/^        void construct_from(Args &&... args)$/;"	f	struct:ranges::semiregular_box	typeref:typename:void
cont_t	include/range/v3/range/conversion.hpp	/^                using cont_t = container_t<Rng>;$/;"	t	function:ranges::detail::to_container::fn::operator ()	typeref:typename:container_t<Rng>
container_	include/range/v3/iterator/insert_iterators.hpp	/^        Container * container_ = nullptr;$/;"	m	struct:ranges::back_insert_iterator	typeref:typename:Container *
container_	include/range/v3/iterator/insert_iterators.hpp	/^        Container * container_ = nullptr;$/;"	m	struct:ranges::front_insert_iterator	typeref:typename:Container *
container_	include/range/v3/iterator/insert_iterators.hpp	/^        Container * container_ = nullptr;$/;"	m	struct:ranges::insert_iterator	typeref:typename:Container *
container_t	include/range/v3/range/conversion.hpp	/^            using container_t = meta::invoke<ToContainer, Rng>;$/;"	t	struct:ranges::detail::to_container	typeref:typename:meta::invoke<ToContainer,Rng>
container_t	include/range/v3/range/conversion.hpp	/^            using container_t = meta::invoke<ToContainer, Rng>;$/;"	t	struct:ranges::detail::to_container::fn	typeref:typename:meta::invoke<ToContainer,Rng>
container_type	include/range/v3/iterator/insert_iterators.hpp	/^        using container_type = Container;$/;"	t	struct:ranges::back_insert_iterator	typeref:typename:Container
container_type	include/range/v3/iterator/insert_iterators.hpp	/^        using container_type = Container;$/;"	t	struct:ranges::front_insert_iterator	typeref:typename:Container
container_type	include/range/v3/iterator/insert_iterators.hpp	/^        using container_type = Container;$/;"	t	struct:ranges::insert_iterator	typeref:typename:Container
contiguous_	include/range/v3/detail/range_access.hpp	/^        struct contiguous_$/;"	s	struct:ranges::range_access
contiguous_cursor_tag	include/range/v3/detail/range_access.hpp	/^        using contiguous_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<contiguous_cursor_concept,random_access_cursor_tag>
contiguous_iterator_concept_base	include/range/v3/iterator/counted_iterator.hpp	/^        struct contiguous_iterator_concept_base$/;"	s	namespace:ranges::_counted_iterator_
contiguous_iterator_concept_base	include/range/v3/iterator/counted_iterator.hpp	/^        struct contiguous_iterator_concept_base<true>$/;"	s	namespace:ranges::_counted_iterator_
contiguous_iterator_tag	include/range/v3/iterator/traits.hpp	/^    struct contiguous_iterator_tag : std::random_access_iterator_tag$/;"	s	namespace:ranges
contiguous_iterator_tag_	include/range/v3/iterator/traits.hpp	/^        using contiguous_iterator_tag_ =$/;"	t	namespace:ranges::detail	typeref:typename:::concepts::tag<contiguous_iterator_concept,random_access_iterator_tag_>
contiguous_range_tag	include/range/v3/range/concepts.hpp	/^    using contiguous_range_tag =$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<contiguous_range_concept,random_access_range_tag>
contiguous_t	include/range/v3/detail/range_access.hpp	/^        using contiguous_t = meta::_t<contiguous_<Cur>>;$/;"	t	struct:ranges::range_access	typeref:typename:meta::_t<contiguous_<Cur>>
convert_bool	include/range/v3/utility/optional.hpp	/^            constexpr bool convert_bool(bool b) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
convert_to	include/range/v3/functional/arithmetic.hpp	/^    struct convert_to$/;"	s	namespace:ranges
copied_	include/range/v3/experimental/utility/generator.hpp	/^            std::atomic<bool> copied_{false};$/;"	m	struct:ranges::experimental::coroutine_owner	typeref:typename:std::atomic<bool>
copy_assign	include/range/v3/utility/semiregular_box.hpp	/^        void copy_assign(T && t, std::false_type)$/;"	f	struct:ranges::semiregular_box	typeref:typename:void
copy_assign	include/range/v3/utility/semiregular_box.hpp	/^        void copy_assign(T const & t, std::true_type)$/;"	f	struct:ranges::semiregular_box	typeref:typename:void
copy_assign_layer	include/range/v3/utility/optional.hpp	/^            using copy_assign_layer = meta::if_c<$/;"	t	namespace:ranges::detail::optional_adl
copy_backward_result	include/range/v3/algorithm/copy_backward.hpp	/^    using copy_backward_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
copy_construct_layer	include/range/v3/utility/optional.hpp	/^            using copy_construct_layer =$/;"	t	namespace:ranges::detail::optional_adl
copy_fn	include/range/v3/algorithm/copy.hpp	/^    struct copy_fn$/;"	s	namespace:ranges
copy_fn	include/range/v3/utility/copy.hpp	/^        struct copy_fn : copy_tag$/;"	s	namespace:ranges::aux
copy_if_result	include/range/v3/algorithm/copy_if.hpp	/^    using copy_if_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
copy_n_result	include/range/v3/algorithm/copy_n.hpp	/^    using copy_n_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
copy_result	include/range/v3/algorithm/copy.hpp	/^    using copy_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
coro_	include/range/v3/experimental/utility/generator.hpp	/^                handle coro_ = nullptr;$/;"	m	struct:ranges::experimental::generator::cursor	typeref:typename:handle
coro_	include/range/v3/experimental/utility/generator.hpp	/^            coroutine_owner<promise_type> coro_;$/;"	m	struct:ranges::experimental::generator	typeref:typename:coroutine_owner<promise_type>
coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^            coroutine_owner(coroutine_owner && that) noexcept$/;"	f	struct:ranges::experimental::coroutine_owner
coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^            coroutine_owner(coroutine_owner const & that) noexcept$/;"	f	struct:ranges::experimental::coroutine_owner
coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^            explicit constexpr coroutine_owner(base_t coro) noexcept$/;"	f	struct:ranges::experimental::coroutine_owner
coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^        struct RANGES_EMPTY_BASES coroutine_owner$/;"	s	namespace:ranges::experimental
coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^        struct RANGES_EMPTY_BASES coroutine_owner;$/;"	v	namespace:ranges::experimental	typeref:struct:RANGES_EMPTY_BASES
coroutine_owner_	include/range/v3/experimental/utility/generator.hpp	/^        namespace coroutine_owner_$/;"	n	namespace:ranges::detail
could_be_lambda	include/range/v3/utility/box.hpp	/^        using could_be_lambda = meta::bool_<!std::is_default_constructible<Fn>::value &&$/;"	t	namespace:ranges::detail	typeref:typename:meta::bool_<!std::is_default_constructible<Fn>::value &&!std::is_copy_assignable<Fn>::value>
count	include/range/v3/iterator/counted_iterator.hpp	/^            static constexpr iter_difference_t<counted_iterator<I>> & count($/;"	f	struct:ranges::_counted_iterator_::access	typeref:typename:iter_difference_t<counted_iterator<I>> &
count	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr iter_difference_t<I> count() const$/;"	f	struct:ranges::counted_iterator	typeref:typename:iter_difference_t<I>
count_	include/range/v3/view/slice.hpp	/^            range_difference_t<Rng> from_, count_;$/;"	m	struct:ranges::detail::slice_view_	typeref:typename:range_difference_t<Rng>
count_	include/range/v3/view/take.hpp	/^        range_difference_t<Rng> count_ = 0;$/;"	m	struct:ranges::take_view	typeref:typename:range_difference_t<Rng>
counted_fn	include/range/v3/view/counted.hpp	/^        struct counted_fn$/;"	s	namespace:ranges::views
counted_iterator	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr counted_iterator(I x, iter_difference_t<I> n)$/;"	f	struct:ranges::counted_iterator
counted_iterator	include/range/v3/iterator/counted_iterator.hpp	/^        struct counted_iterator$/;"	s	namespace:ranges
counted_view	include/range/v3/view/counted.hpp	/^        counted_view(I it, iter_difference_t<I> n)$/;"	f	struct:ranges::counted_view
counted_view	include/range/v3/view/counted.hpp	/^    struct counted_view : view_interface<counted_view<I>, finite>$/;"	s	namespace:ranges
cpp17_bidirectional_cursor_tag	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp17_bidirectional_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<bidirectional_cursor_concept,cpp17_forward_cursor_tag>
cpp17_cursor_tag_of	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp17_cursor_tag_of = concepts::tag_of<$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag_of<meta::list<random_access_cursor_concept,bidirectional_cursor_concept,cpp17_forward_cursor_concept,cpp17_input_cursor_concept,cursor_concept>,Cur>
cpp17_forward_cursor_tag	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp17_forward_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<cpp17_forward_cursor_concept,cpp17_input_cursor_tag>
cpp17_input_cursor_tag	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp17_input_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<cpp17_input_cursor_concept,cursor_tag>
cpp17_iter_cat_of_t	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp17_iter_cat_of_t =$/;"	t	namespace:ranges::detail
cpp17_iterator_cursor	include/range/v3/iterator/common_iterator.hpp	/^            constexpr explicit cpp17_iterator_cursor(I i)$/;"	f	struct:ranges::detail::cpp17_iterator_cursor
cpp17_iterator_cursor	include/range/v3/iterator/common_iterator.hpp	/^        struct cpp17_iterator_cursor$/;"	s	struct:ranges::detail
cpp17_iterator_t	include/range/v3/range/traits.hpp	/^        using cpp17_iterator_t =$/;"	t	namespace:ranges::detail
cpp17_random_access_cursor_tag	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp17_random_access_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<random_access_cursor_concept,cpp17_bidirectional_cursor_tag>
cpp20	include/range/v3/algorithm/adjacent_find.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/adjacent_remove_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/all_of.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/any_of.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/binary_search.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/copy_backward.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/copy_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/copy_n.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/count.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/count_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/equal.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/equal_range.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/fill.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/fill_n.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/find.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/find_end.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/find_first_of.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/find_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/find_if_not.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/for_each.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/generate.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/generate_n.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/heap_algorithm.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/inplace_merge.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/is_partitioned.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/is_sorted.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/is_sorted_until.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/lexicographical_compare.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/lower_bound.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/max.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/max_element.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/merge.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/min.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/min_element.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/minmax.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/minmax_element.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/mismatch.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/move.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/move_backward.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/none_of.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/nth_element.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/partial_sort.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/partial_sort_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/partition.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/partition_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/partition_point.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/permutation.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/remove.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/remove_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/remove_copy_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/remove_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/replace.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/replace_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/replace_copy_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/replace_if.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/reverse.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/reverse_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/rotate.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/rotate_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/search.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/search_n.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/set_algorithm.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/shuffle.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/sort.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/stable_partition.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/stable_sort.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/swap_ranges.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/transform.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/unique.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/unique_copy.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/algorithm/upper_bound.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/functional/comparisons.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/functional/concepts.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/functional/identity.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/functional/invoke.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/functional/not_fn.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/access.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/concepts.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/counted_iterator.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/default_sentinel.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/insert_iterators.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/move_iterators.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/operations.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/reverse_iterator.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/stream_iterators.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/traits.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/iterator/unreachable_sentinel.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/range/access.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/range/concepts.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/range/dangling.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/range/primitives.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/range/traits.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/utility/swap.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/all.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/common.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/counted.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/drop.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/drop_while.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/empty.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/filter.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/interface.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/iota.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/istream.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/join.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/map.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/ref.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/reverse.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/single.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/split.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/subrange.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/take.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/take_while.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20	include/range/v3/view/transform.hpp	/^    namespace cpp20$/;"	n	namespace:ranges
cpp20_common_fn	include/range/v3/view/common.hpp	/^        struct cpp20_common_fn$/;"	s	namespace:ranges::views
cpp20_counted_fn	include/range/v3/view/counted.hpp	/^        struct cpp20_counted_fn$/;"	s	namespace:ranges::views
cpp20_filter_base_fn	include/range/v3/view/filter.hpp	/^        struct cpp20_filter_base_fn$/;"	s	namespace:ranges::views
cpp20_filter_fn	include/range/v3/view/filter.hpp	/^        struct cpp20_filter_fn : cpp20_filter_base_fn$/;"	s	namespace:ranges::views
cpp20_iter_cat_of_t	include/range/v3/iterator/basic_iterator.hpp	/^        using cpp20_iter_cat_of_t = decltype(detail::iter_cat(cursor_tag_of<Cur>{}));$/;"	t	namespace:ranges::detail
cpp20_join_fn	include/range/v3/view/join.hpp	/^        struct cpp20_join_fn$/;"	s	namespace:ranges::views
cranges	include/range/v3/view/concat.hpp	/^        static constexpr std::size_t cranges{sizeof...(Rngs)};$/;"	m	struct:ranges::concat_view	typeref:typename:std::size_t
create	include/lr.hpp	/^template <typename T> inline constexpr std::variant<L, T> create(T &&t) {$/;"	f	namespace:lr	typeref:typename:std::variant<L,T>
crtp	include/newtype.hpp	/^template <typename T, template <typename> class crtpType> struct crtp {$/;"	s	namespace:abo::nt
crtp	include/ntskills.hpp	/^template <typename T, template <typename> class crtpType> struct crtp {$/;"	s	namespace:nt
cur_	include/range/v3/iterator/basic_iterator.hpp	/^            Cur * cur_;$/;"	m	struct:ranges::detail::basic_proxy_reference_	typeref:typename:Cur *
cur_	include/range/v3/view/group_by.hpp	/^            iterator_t<CRng> cur_;$/;"	m	struct:ranges::group_by_view::cursor	typeref:typename:iterator_t<CRng>
cur_	include/range/v3/view/join.hpp	/^            variant<iterator_t<ValRng>, iterator_t<Inner>> cur_{};$/;"	m	class:ranges::join_with_view::cursor	typeref:typename:variant<iterator_t<ValRng>,iterator_t<Inner>>
cur_	include/range/v3/view/split_when.hpp	/^            iterator_t<CRng> cur_;$/;"	m	struct:ranges::split_when_view::cursor	typeref:typename:iterator_t<CRng>
curr_	include/range/v3/view/split.hpp	/^            It curr_ = It();$/;"	m	struct:ranges::detail::here	typeref:typename:It
current	include/range/v3/iterator/counted_iterator.hpp	/^            static constexpr I & current(counted_iterator<I> & ci) noexcept$/;"	f	struct:ranges::_counted_iterator_::access	typeref:typename:I &
current	include/range/v3/iterator/counted_iterator.hpp	/^            static constexpr I const & current(counted_iterator<I> const & ci) noexcept$/;"	f	struct:ranges::_counted_iterator_::access	typeref:typename:I const &
current_	include/range/v3/iterator/counted_iterator.hpp	/^        I current_{};$/;"	m	struct:ranges::counted_iterator	typeref:typename:I
current_	include/range/v3/view/any_view.hpp	/^            RANGES_NO_UNIQUE_ADDRESS iterator_t<Rng> current_{};$/;"	m	struct:ranges::detail::any_input_view_impl	typeref:typename:RANGES_NO_UNIQUE_ADDRESS iterator_t<Rng>
current_	include/range/v3/view/cache1.hpp	/^            iterator_t<Rng> current_;$/;"	m	struct:ranges::cache1_view::cursor	typeref:typename:iterator_t<Rng>
current_	include/range/v3/view/partial_sum.hpp	/^            RANGES_NO_UNIQUE_ADDRESS iterator_t<Base> current_{};$/;"	m	struct:ranges::partial_sum_view::cursor	typeref:typename:RANGES_NO_UNIQUE_ADDRESS iterator_t<Base>
current_	include/range/v3/view/sample.hpp	/^            iterator_t<Base> current_;$/;"	m	class:ranges::sample_view::cursor	typeref:typename:iterator_t<Base>
current_	include/range/v3/view/split.hpp	/^            It & current_(ignore_t) noexcept$/;"	f	struct:ranges::detail::here	typeref:typename:It &
current_	include/range/v3/view/split.hpp	/^            It const & current_(ignore_t) const noexcept$/;"	f	struct:ranges::detail::here	typeref:typename:It const &
current_	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) current_() const noexcept$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:decltype (auto)
current_	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) current_() const noexcept$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:decltype (auto)
current_	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) current_() noexcept$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:decltype (auto)
current_	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) current_() noexcept$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:decltype (auto)
current_	include/range/v3/view/split.hpp	/^            static decltype(auto) current_(T & t) noexcept$/;"	f	struct:ranges::detail::there	typeref:typename:decltype (auto)
cursor	example/calendar.cpp	/^struct interleave_view<Rngs>::cursor$/;"	s	class:interleave_view	file:
cursor	include/range/v3/detail/range_access.hpp	/^        static constexpr Cur cursor(basic_iterator<Cur> it)$/;"	f	struct:ranges::range_access	typeref:typename:Cur
cursor	include/range/v3/experimental/utility/generator.hpp	/^                constexpr explicit cursor(handle coro) noexcept$/;"	f	struct:ranges::experimental::generator::cursor
cursor	include/range/v3/experimental/utility/generator.hpp	/^            struct cursor$/;"	s	struct:ranges::experimental::generator
cursor	include/range/v3/view/cache1.hpp	/^            constexpr explicit cursor(cache1_view * parent, iterator_t<Rng> current)$/;"	f	struct:ranges::cache1_view::cursor
cursor	include/range/v3/view/cache1.hpp	/^        struct cursor$/;"	s	struct:ranges::cache1_view
cursor	include/range/v3/view/cartesian_product.hpp	/^            cursor(end_tag, constify_if<cartesian_product_view> * view,$/;"	f	struct:ranges::cartesian_product_view::cursor
cursor	include/range/v3/view/cartesian_product.hpp	/^            explicit cursor(begin_tag, constify_if<cartesian_product_view> * view)$/;"	f	struct:ranges::cartesian_product_view::cursor
cursor	include/range/v3/view/cartesian_product.hpp	/^            explicit cursor(end_tag, constify_if<cartesian_product_view> * view)$/;"	f	struct:ranges::cartesian_product_view::cursor
cursor	include/range/v3/view/cartesian_product.hpp	/^        struct cursor$/;"	s	struct:ranges::cartesian_product_view
cursor	include/range/v3/view/concat.hpp	/^            cursor(concat_view_t * rng, begin_tag)$/;"	f	struct:ranges::concat_view::cursor
cursor	include/range/v3/view/concat.hpp	/^            cursor(concat_view_t * rng, end_tag)$/;"	f	struct:ranges::concat_view::cursor
cursor	include/range/v3/view/concat.hpp	/^        struct cursor$/;"	s	struct:ranges::concat_view
cursor	include/range/v3/view/cycle.hpp	/^            cursor(cycled_view_t * rng)$/;"	f	struct:ranges::cycled_view::cursor
cursor	include/range/v3/view/cycle.hpp	/^        struct cursor$/;"	s	struct:ranges::cycled_view
cursor	include/range/v3/view/enumerate.hpp	/^            struct cursor$/;"	s	struct:ranges::detail::index_view
cursor	include/range/v3/view/generate.hpp	/^            explicit cursor(generate_view * view)$/;"	f	struct:ranges::generate_view::cursor
cursor	include/range/v3/view/generate.hpp	/^        struct cursor$/;"	s	struct:ranges::generate_view
cursor	include/range/v3/view/generate_n.hpp	/^            explicit cursor(generate_n_view * rng)$/;"	f	struct:ranges::generate_n_view::cursor
cursor	include/range/v3/view/generate_n.hpp	/^        struct cursor$/;"	s	struct:ranges::generate_n_view
cursor	include/range/v3/view/getlines.hpp	/^            explicit cursor(getlines_view * rng)$/;"	f	struct:ranges::getlines_view::cursor
cursor	include/range/v3/view/getlines.hpp	/^        struct cursor$/;"	s	struct:ranges::getlines_view
cursor	include/range/v3/view/group_by.hpp	/^            cursor(semiregular_box_ref_or_val_t<Fun, IsConst> fun, iterator_t<CRng> first,$/;"	f	struct:ranges::group_by_view::cursor
cursor	include/range/v3/view/group_by.hpp	/^        struct cursor$/;"	s	struct:ranges::group_by_view
cursor	include/range/v3/view/iota.hpp	/^            constexpr cursor(From from, To to, bool done = false)$/;"	f	struct:ranges::closed_iota_view::cursor
cursor	include/range/v3/view/iota.hpp	/^            constexpr explicit cursor(From from)$/;"	f	struct:ranges::iota_view::cursor
cursor	include/range/v3/view/iota.hpp	/^        struct cursor$/;"	s	struct:ranges::closed_iota_view
cursor	include/range/v3/view/iota.hpp	/^        struct cursor$/;"	s	struct:ranges::iota_view
cursor	include/range/v3/view/istream.hpp	/^            explicit cursor(istream_view * rng)$/;"	f	struct:ranges::istream_view::cursor
cursor	include/range/v3/view/istream.hpp	/^        struct cursor$/;"	s	struct:ranges::istream_view
cursor	include/range/v3/view/join.hpp	/^            constexpr cursor(Parent * rng, BeginOrEnd begin_or_end)$/;"	f	struct:ranges::join_view::cursor
cursor	include/range/v3/view/join.hpp	/^            cursor(join_with_view * rng)$/;"	f	class:ranges::join_with_view::cursor
cursor	include/range/v3/view/join.hpp	/^        class cursor$/;"	c	struct:ranges::join_with_view
cursor	include/range/v3/view/join.hpp	/^        struct cursor$/;"	s	struct:ranges::join_view
cursor	include/range/v3/view/partial_sum.hpp	/^            constexpr explicit cursor(Parent * rng)$/;"	f	struct:ranges::partial_sum_view::cursor
cursor	include/range/v3/view/partial_sum.hpp	/^        struct cursor$/;"	s	struct:ranges::partial_sum_view
cursor	include/range/v3/view/repeat.hpp	/^            explicit cursor(Val const & value)$/;"	f	struct:ranges::repeat_view::cursor
cursor	include/range/v3/view/repeat.hpp	/^        struct cursor$/;"	s	struct:ranges::repeat_view
cursor	include/range/v3/view/repeat_n.hpp	/^            cursor(Val const & value, std::ptrdiff_t n)$/;"	f	struct:ranges::repeat_n_view::cursor
cursor	include/range/v3/view/repeat_n.hpp	/^        struct cursor$/;"	s	struct:ranges::repeat_n_view
cursor	include/range/v3/view/sample.hpp	/^            explicit cursor(meta::const_if_c<IsConst, sample_view> * rng)$/;"	f	class:ranges::sample_view::cursor
cursor	include/range/v3/view/sample.hpp	/^        class cursor$/;"	c	class:ranges::sample_view
cursor	include/range/v3/view/set_algorithm.hpp	/^            using cursor = Cursor<IsConst, Rng1, Rng2, C, P1, P2>;$/;"	t	struct:ranges::detail::set_algorithm_view	typeref:typename:Cursor<IsConst,Rng1,Rng2,C,P1,P2>
cursor	include/range/v3/view/split_when.hpp	/^            cursor(fun_ref_t fun, iterator_t<CRng> first, sentinel_t<CRng> last)$/;"	f	struct:ranges::split_when_view::cursor
cursor	include/range/v3/view/split_when.hpp	/^        struct cursor$/;"	s	struct:ranges::split_when_view
cursor	include/range/v3/view/transform.hpp	/^            cursor(meta::const_if_c<Const, iter_transform2_view> * parent,$/;"	f	struct:ranges::iter_transform2_view::cursor
cursor	include/range/v3/view/transform.hpp	/^        struct cursor$/;"	s	struct:ranges::iter_transform2_view
cursor	include/range/v3/view/zip_with.hpp	/^            cursor(fun_ref_ fun,$/;"	f	struct:ranges::iter_zip_with_view::cursor
cursor	include/range/v3/view/zip_with.hpp	/^        struct cursor$/;"	s	struct:ranges::iter_zip_with_view
cursor_adaptor	include/range/v3/view/intersperse.hpp	/^            explicit constexpr cursor_adaptor(range_value_t<Rng> const & val)$/;"	f	struct:ranges::intersperse_view::cursor_adaptor
cursor_adaptor	include/range/v3/view/intersperse.hpp	/^        struct cursor_adaptor : adaptor_base$/;"	s	struct:ranges::intersperse_view
cursor_arrow_t	include/range/v3/iterator/basic_iterator.hpp	/^        using cursor_arrow_t = decltype(range_access::arrow(std::declval<Cur const &>()));$/;"	t	namespace:ranges
cursor_difference	include/range/v3/detail/range_access.hpp	/^        struct cursor_difference$/;"	s	struct:ranges::range_access
cursor_difference_t	include/range/v3/detail/range_access.hpp	/^        using cursor_difference_t = meta::_t<cursor_difference<Cur>>;$/;"	t	struct:ranges::range_access	typeref:typename:meta::_t<cursor_difference<Cur>>
cursor_reference_t	include/range/v3/detail/range_access.hpp	/^        using cursor_reference_t = decltype(std::declval<T const &>().read());$/;"	t	struct:ranges::range_access
cursor_reference_t	include/range/v3/iterator/basic_iterator.hpp	/^        using cursor_reference_t =$/;"	t	namespace:ranges::detail
cursor_rvalue_reference_t	include/range/v3/iterator/basic_iterator.hpp	/^        using cursor_rvalue_reference_t =$/;"	t	namespace:ranges::detail
cursor_tag	include/range/v3/detail/range_access.hpp	/^        using cursor_tag = concepts::tag<cursor_concept>;$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<cursor_concept>
cursor_tag_of	include/range/v3/detail/range_access.hpp	/^        using cursor_tag_of = concepts::tag_of<meta::list<contiguous_cursor_concept,    \/\/$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag_of<meta::list<contiguous_cursor_concept,random_access_cursor_concept,bidirectional_cursor_concept,forward_cursor_concept,input_cursor_concept,cursor_concept>,T>
cursor_tag_t	include/range/v3/iterator/basic_iterator.hpp	/^            using cursor_tag_t = concepts::tag<detail::output_cursor_concept, cursor_tag>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:concepts::tag<detail::output_cursor_concept,cursor_tag>
cursor_tag_t	include/range/v3/iterator/basic_iterator.hpp	/^            using cursor_tag_t = cursor_tag_of<Cur>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:cursor_tag_of<Cur>
cursor_traits	include/range/v3/iterator/basic_iterator.hpp	/^        using cursor_traits = cursor_traits_<Cur, (bool)readable_cursor<Cur>>;$/;"	t	namespace:ranges::detail
cursor_traits_	include/range/v3/iterator/basic_iterator.hpp	/^        struct cursor_traits_$/;"	s	namespace:ranges::detail
cursor_traits_	include/range/v3/iterator/basic_iterator.hpp	/^        struct cursor_traits_<Cur, true>$/;"	s	namespace:ranges::detail
cursor_value	include/range/v3/detail/range_access.hpp	/^        struct cursor_value : decltype(range_access::cursor_value_2_<Cur>(42))$/;"	s	struct:ranges::range_access
cursor_value_t	include/range/v3/detail/range_access.hpp	/^        using cursor_value_t = meta::_t<cursor_value<Cur>>;$/;"	t	struct:ranges::range_access	typeref:typename:meta::_t<cursor_value<Cur>>
cursor_value_t	include/range/v3/iterator/basic_iterator.hpp	/^        using cursor_value_t = typename cursor_traits<Cur>::value_t_;$/;"	t	namespace:ranges::detail	typeref:typename:cursor_traits<Cur>::value_t_
cycle_fn	include/range/v3/view/cycle.hpp	/^        struct cycle_fn$/;"	s	namespace:ranges::views
cycled_view	include/range/v3/view/cycle.hpp	/^        explicit cycled_view(Rng rng)$/;"	f	struct:ranges::cycled_view
cycled_view	include/range/v3/view/cycle.hpp	/^    struct RANGES_EMPTY_BASES cycled_view$/;"	s	namespace:ranges
cycled_view	include/range/v3/view/cycle.hpp	/^    struct cycled_view<Rng, true> : identity_adaptor<Rng>$/;"	s	namespace:ranges
cycled_view_t	include/range/v3/view/cycle.hpp	/^            using cycled_view_t = constify_if<cycled_view>;$/;"	t	struct:ranges::cycled_view::cursor	typeref:typename:constify_if<cycled_view>
d	include/git.hpp	/^  D d;$/;"	m	struct:git::make	typeref:typename:D
dangling	include/range/v3/range/dangling.hpp	/^    struct dangling$/;"	s	namespace:ranges
data	include/range/v3/detail/variant.hpp	/^            static constexpr variant_data<Ts...> & data(variant<Ts...> & var) noexcept$/;"	f	struct:ranges::detail::variant_core_access	typeref:typename:variant_data<Ts...> &
data	include/range/v3/detail/variant.hpp	/^            static constexpr variant_data<Ts...> && data(variant<Ts...> && var) noexcept$/;"	f	struct:ranges::detail::variant_core_access	typeref:typename:variant_data<Ts...> &&
data	include/range/v3/detail/variant.hpp	/^            static constexpr variant_data<Ts...> const & data($/;"	f	struct:ranges::detail::variant_core_access	typeref:typename:variant_data<Ts...> const &
data	include/range/v3/view/empty.hpp	/^        static constexpr T * data() noexcept$/;"	f	struct:ranges::empty_view	typeref:typename:T *
data	include/range/v3/view/single.hpp	/^        constexpr T * data() noexcept$/;"	f	struct:ranges::single_view	typeref:typename:T *
data	include/range/v3/view/single.hpp	/^        constexpr T const * data() const noexcept$/;"	f	struct:ranges::single_view	typeref:typename:T const *
data	include/range/v3/view/span.hpp	/^        constexpr pointer data() const noexcept$/;"	f	struct:ranges::span	typeref:typename:pointer
data_	include/range/v3/detail/variant.hpp	/^        detail::variant_data<Ts...> & data_() & noexcept$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_data<Ts...> &
data_	include/range/v3/detail/variant.hpp	/^        detail::variant_data<Ts...> && data_() && noexcept$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_data<Ts...> &&
data_	include/range/v3/detail/variant.hpp	/^        detail::variant_data<Ts...> const & data_() const & noexcept$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_data<Ts...> const &
data_	include/range/v3/iterator/common_iterator.hpp	/^            variant<I, S> * data_;$/;"	m	struct:ranges::common_iterator::emplace_fn	typeref:typename:variant<I,S> *
data_	include/range/v3/iterator/common_iterator.hpp	/^        variant<I, S> data_;$/;"	m	struct:ranges::common_iterator	typeref:typename:variant<I,S>
data_	include/range/v3/utility/optional.hpp	/^                    meta::_t<std::remove_cv<T>> data_;$/;"	m	union:ranges::detail::optional_adl::optional_storage::__anon8c726b6b020a	typeref:typename:meta::_t<std::remove_cv<T>>
data_	include/range/v3/utility/optional.hpp	/^                    meta::_t<std::remove_cv<T>> data_;$/;"	m	union:ranges::detail::optional_adl::optional_storage::__anon8c726b6b030a	typeref:typename:meta::_t<std::remove_cv<T>>
data_	include/range/v3/utility/semiregular_box.hpp	/^            T data_;$/;"	m	union:ranges::semiregular_box::__anonf59fc86d010a	typeref:typename:T
data_	include/range/v3/utility/variant.hpp	/^                T data_[N];$/;"	m	union:ranges::detail::indexed_datum::__anon577c80ba010a	typeref:typename:T[]
data_	include/range/v3/view/adaptor.hpp	/^            compressed_pair<BaseIter, Adapt> data_;$/;"	m	struct:ranges::detail::adaptor_value_type_	typeref:typename:compressed_pair<BaseIter,Adapt>
data_	include/range/v3/view/adaptor.hpp	/^        RANGES_NO_UNIQUE_ADDRESS compressed_pair<BaseSent, Adapt> data_;$/;"	m	struct:ranges::base_adaptor_sentinel	typeref:typename:RANGES_NO_UNIQUE_ADDRESS compressed_pair<BaseSent,Adapt>
data_	include/range/v3/view/span.hpp	/^        T * data_ = nullptr;$/;"	m	struct:ranges::span	typeref:typename:T *
data_	include/range/v3/view/subrange.hpp	/^            data_;$/;"	m	struct:ranges::subrange
data_t	include/range/v3/range/concepts.hpp	/^        using data_t = decltype(ranges::data(std::declval<Rng &>()));$/;"	t	namespace:ranges::detail
date	example/calendar.cpp	/^using date = greg::date;$/;"	t	typeref:typename:greg::date	file:
dates	example/calendar.cpp	/^dates(unsigned short start, unsigned short stop)$/;"	f	typeref:typename:auto
dates_from	example/calendar.cpp	/^dates_from(unsigned short year)$/;"	f	typeref:typename:auto
datum_	include/range/v3/detail/variant.hpp	/^            T datum_;$/;"	m	struct:ranges::detail::indexed_datum	typeref:typename:T
datum_t	include/range/v3/detail/variant.hpp	/^        using datum_t = detail::variant_datum_t<Index, Ts...>;$/;"	t	struct:ranges::variant	typeref:typename:detail::variant_datum_t<Index,Ts...>
day	example/calendar.cpp	/^using day = greg::date_duration;$/;"	t	typeref:typename:greg::date_duration	file:
dec	include/meta/meta.hpp	/^        using dec = defer<dec, T>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<dec,T>
dec	include/meta/meta.hpp	/^    using dec = std::integral_constant<decltype(T::type::value - 1), T::type::value - 1>;$/;"	t	namespace:meta
dec_	include/range/v3/view/zip_with.hpp	/^        struct dec_$/;"	s	namespace:ranges::detail
decay_t	include/concepts/type_traits.hpp	/^        using decay_t = typename std::decay<T>::type;$/;"	t	namespace:concepts::detail	typeref:typename:std::decay<T>::type
decrement	include/range/v3/view/sample.hpp	/^            void decrement()$/;"	f	class:ranges::detail::size_tracker	typeref:typename:void
default_URNG	include/range/v3/utility/random.hpp	/^        using default_URNG = meta::if_c<(sizeof(void *) >= sizeof(long long)),$/;"	t	namespace:ranges::detail
default_random_engine	include/range/v3/utility/random.hpp	/^        using default_random_engine = default_URNG;$/;"	t	namespace:ranges::detail	typeref:typename:default_URNG
default_random_engine	include/range/v3/utility/random.hpp	/^        using default_random_engine = sync_URNG<default_URNG>;$/;"	t	namespace:ranges::detail	typeref:typename:sync_URNG<default_URNG>
default_sentinel_t	include/range/v3/iterator/default_sentinel.hpp	/^    struct default_sentinel_t$/;"	s	namespace:ranges
defs	include/concepts/concepts.hpp	/^    inline namespace defs$/;"	n	namespace:concepts
delete_fn	include/range/v3/detail/variant.hpp	/^        struct delete_fn$/;"	s	namespace:ranges::detail
deleted_copy_assign	include/range/v3/utility/optional.hpp	/^            struct deleted_copy_assign : move_construct_layer<T>$/;"	s	namespace:ranges::detail::optional_adl
deleted_move_assign	include/range/v3/utility/optional.hpp	/^            struct deleted_move_assign : copy_assign_layer<T>$/;"	s	namespace:ranges::detail::optional_adl
delim_	include/range/v3/iterator/stream_iterators.hpp	/^        Char const * delim_;$/;"	m	struct:ranges::ostream_iterator	typeref:typename:Char const *
delim_	include/range/v3/iterator/stream_iterators.hpp	/^        Delim delim_;$/;"	m	struct:ranges::ostream_joiner	typeref:typename:Delim
delim_	include/range/v3/view/getlines.hpp	/^        char delim_;$/;"	m	struct:ranges::getlines_view	typeref:typename:char
delimit_base_fn	include/range/v3/view/delimit.hpp	/^        struct delimit_base_fn$/;"	s	namespace:ranges::views
delimit_fn	include/range/v3/view/delimit.hpp	/^        struct delimit_fn : delimit_base_fn$/;"	s	namespace:ranges::views
delimit_view	include/range/v3/view/delimit.hpp	/^        constexpr delimit_view(Rng rng, Val value)$/;"	f	struct:ranges::delimit_view
delimit_view	include/range/v3/view/delimit.hpp	/^    struct delimit_view$/;"	s	namespace:ranges
denorm_min	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t denorm_min() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
dependent_	include/range/v3/view/interface.hpp	/^        struct dependent_$/;"	s	namespace:ranges::detail
dereference_fn	include/range/v3/view/view.hpp	/^        struct dereference_fn$/;"	s	namespace:ranges::detail
derived	include/range/v3/view/interface.hpp	/^        constexpr Derived & derived() noexcept$/;"	f	struct:ranges::view_interface	typeref:typename:Derived &
derived	include/range/v3/view/interface.hpp	/^        constexpr Derived const & derived() const noexcept$/;"	f	struct:ranges::view_interface	typeref:typename:Derived const &
detail	include/concepts/concepts.hpp	/^    namespace detail$/;"	n	namespace:concepts
detail	include/concepts/swap.hpp	/^    namespace detail$/;"	n	namespace:concepts
detail	include/concepts/type_traits.hpp	/^    namespace detail$/;"	n	namespace:concepts
detail	include/meta/meta.hpp	/^    namespace detail$/;"	n	namespace:meta
detail	include/meta/meta_fwd.hpp	/^    namespace detail$/;"	n	namespace:meta
detail	include/range/v3/action/concepts.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/action/insert.hpp	/^        namespace detail$/;"	n	namespace:ranges::adl_insert_detail
detail	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/equal.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/find_end.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/heap_algorithm.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/inplace_merge.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/nth_element.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/partition.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/permutation.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/result_types.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/reverse.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/rotate.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/sample.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/search.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/search_n.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/sort.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/stable_partition.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/stable_sort.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/algorithm/unique_copy.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/detail/adl_get.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/detail/config.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/detail/range_access.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/detail/variant.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/detail/with_braced_init_args.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/experimental/utility/generator.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/functional/bind_back.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/functional/invoke.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/functional/reference_wrapper.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/access.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/basic_iterator.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/common_iterator.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/common_iterator.hpp	/^    namespace detail$/;"	s	namespace:ranges
detail	include/range/v3/iterator/concepts.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/diffmax_t.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/move_iterators.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/reverse_iterator.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/iterator/traits.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/numeric/partial_sum.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/range/concepts.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/range/conversion.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/range/dangling.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/range/traits.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/addressof.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/box.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/common_tuple.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/memory.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/optional.hpp	/^        namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/optional.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/random.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/semiregular_box.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/tagged_pair.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/utility/variant.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/adaptor.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/adjacent_filter.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/any_view.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/c_str.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/cartesian_product.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/chunk.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/common.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/concat.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/drop_last.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/empty.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/enumerate.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/facade.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/interface.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/iota.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/join.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/map.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/partial_sum.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/replace.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/replace_if.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/sample.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/set_algorithm.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/slice.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/span.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/split.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/stride.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/subrange.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/tail.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/take_exactly.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/transform.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/view.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/zip.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/range/v3/view/zip_with.hpp	/^    namespace detail$/;"	n	namespace:ranges
detail	include/std/detail/associated_types.hpp	/^    namespace detail$/;"	n	namespace:ranges
diff_t	include/range/v3/action/slice.hpp	/^            using diff_t = range_difference_t<D>;$/;"	t	struct:ranges::actions::slice_fn	typeref:typename:range_difference_t<D>
difference_result_t	include/std/detail/associated_types.hpp	/^        using difference_result_t =$/;"	t	namespace:ranges::detail
difference_t	include/range/v3/view/drop_last.hpp	/^        using difference_t = range_difference_t<Rng>;$/;"	t	struct:ranges::drop_last_view	typeref:typename:range_difference_t<Rng>
difference_type	example/calendar.cpp	/^        using difference_type = date::duration_type::duration_rep::int_type;$/;"	t	struct:ranges::incrementable_traits	typeref:typename:date::duration_type::duration_rep::int_type	file:
difference_type	include/range/v3/action/concepts.hpp	/^            using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::detail::movable_input_iterator	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/algorithm/nth_element.hpp	/^            using difference_type = iter_difference_t<I>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/algorithm/stable_partition.hpp	/^            using difference_type = iter_difference_t<I>;$/;"	t	function:ranges::detail::stable_partition_impl	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/iterator/basic_iterator.hpp	/^            using difference_type = range_access::cursor_difference_t<Cur>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:range_access::cursor_difference_t<Cur>
difference_type	include/range/v3/iterator/common_iterator.hpp	/^            using difference_type = iter_difference_t<I>;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/iterator/common_iterator.hpp	/^            using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/iterator/common_iterator.hpp	/^        using difference_type = iter_difference_t<I>;$/;"	t	struct:ranges::common_iterator	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/iterator/counted_iterator.hpp	/^            using difference_type = iter_difference_t<I>;$/;"	t	struct:ranges::_counted_iterator_::iterator_traits_	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/iterator/counted_iterator.hpp	/^        using difference_type = iter_difference_t<I>;$/;"	t	struct:ranges::counted_iterator	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/iterator/insert_iterators.hpp	/^        using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::back_insert_iterator	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/iterator/insert_iterators.hpp	/^        using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::front_insert_iterator	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/iterator/insert_iterators.hpp	/^        using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::insert_iterator	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/iterator/move_iterators.hpp	/^        using difference_type = iter_difference_t<I>;$/;"	t	struct:ranges::move_iterator	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/iterator/stream_iterators.hpp	/^        typedef ptrdiff_t difference_type;$/;"	t	struct:ranges::ostreambuf_iterator	typeref:typename:ptrdiff_t
difference_type	include/range/v3/iterator/stream_iterators.hpp	/^        using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::ostream_iterator	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/iterator/stream_iterators.hpp	/^        using difference_type = std::ptrdiff_t;$/;"	t	struct:ranges::ostream_joiner	typeref:typename:std::ptrdiff_t
difference_type	include/range/v3/range/conversion.hpp	/^            using difference_type = typename std::iterator_traits<I>::difference_type;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:std::iterator_traits<I>::difference_type
difference_type	include/range/v3/utility/memory.hpp	/^        using difference_type = iter_difference_t<I>;$/;"	t	struct:ranges::iterator_wrapper	typeref:typename:iter_difference_t<I>
difference_type	include/range/v3/utility/memory.hpp	/^        using difference_type = iter_difference_t<O>;$/;"	t	struct:ranges::raw_storage_iterator	typeref:typename:iter_difference_t<O>
difference_type	include/range/v3/view/cache1.hpp	/^            using difference_type = range_difference_t<Rng>;$/;"	t	struct:ranges::cache1_view::cursor	typeref:typename:range_difference_t<Rng>
difference_type	include/range/v3/view/cartesian_product.hpp	/^            using difference_type =$/;"	t	struct:ranges::cartesian_product_view::cursor	typeref:typename:common_type_t<std::intmax_t,range_difference_t<Views>...>
difference_type	include/range/v3/view/concat.hpp	/^            using difference_type = common_type_t<range_difference_t<Rngs>...>;$/;"	t	struct:ranges::concat_view::cursor	typeref:typename:common_type_t<range_difference_t<Rngs>...>
difference_type	include/range/v3/view/enumerate.hpp	/^                using difference_type = Diff;$/;"	t	struct:ranges::detail::index_view::cursor	typeref:typename:Diff
difference_type	include/range/v3/view/iota.hpp	/^            using difference_type = detail::iota_difference_t<From>;$/;"	t	struct:ranges::closed_iota_view::cursor	typeref:typename:detail::iota_difference_t<From>
difference_type	include/range/v3/view/iota.hpp	/^            using difference_type = detail::iota_difference_t<From>;$/;"	t	struct:ranges::iota_view::cursor	typeref:typename:detail::iota_difference_t<From>
difference_type	include/range/v3/view/iota.hpp	/^            using difference_type = diffmax_t;$/;"	t	struct:ranges::detail::promote_as_signed_	typeref:typename:diffmax_t
difference_type	include/range/v3/view/sample.hpp	/^            using difference_type = D;$/;"	t	class:ranges::sample_view::cursor	typeref:typename:D
difference_type	include/range/v3/view/span.hpp	/^        using difference_type = index_type;$/;"	t	struct:ranges::span	typeref:typename:index_type
difference_type	include/range/v3/view/split.hpp	/^            using difference_type = range_difference_t<Base>;$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:range_difference_t<Base>
difference_type	include/range/v3/view/split.hpp	/^            using difference_type = range_difference_t<Base>;$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:range_difference_t<Base>
difference_type	include/range/v3/view/transform.hpp	/^            using difference_type = difference_type_;$/;"	t	struct:ranges::iter_transform2_view::cursor	typeref:typename:difference_type_
difference_type	include/range/v3/view/zip_with.hpp	/^            using difference_type =$/;"	t	struct:ranges::iter_zip_with_view::cursor	typeref:typename:common_type_t<range_difference_t<meta::const_if_c<Const,Rngs>>...>
difference_type	include/std/detail/associated_types.hpp	/^            using difference_type = T;$/;"	t	struct:ranges::detail::with_difference_type_	typeref:typename:T
difference_type	test/p.cpp	/^  using difference_type = int;$/;"	t	struct:aiterator	typeref:typename:int	file:
difference_type_	include/range/v3/iterator/traits.hpp	/^        struct difference_type_ : meta::defer<iter_difference_t, T>$/;"	s	namespace:ranges::detail
difference_type_	include/range/v3/view/concat.hpp	/^        using difference_type_ = common_type_t<range_difference_t<Rngs>...>;$/;"	t	struct:ranges::concat_view	typeref:typename:common_type_t<range_difference_t<Rngs>...>
difference_type_	include/range/v3/view/drop.hpp	/^        using difference_type_ = range_difference_t<Rng>;$/;"	t	struct:ranges::drop_view	typeref:typename:range_difference_t<Rng>
difference_type_	include/range/v3/view/drop_exactly.hpp	/^        using difference_type_ = range_difference_t<Rng>;$/;"	t	struct:ranges::drop_exactly_view	typeref:typename:range_difference_t<Rng>
difference_type_	include/range/v3/view/transform.hpp	/^        using difference_type_ =$/;"	t	struct:ranges::iter_transform2_view	typeref:typename:common_type_t<range_difference_t<Rng1>,range_difference_t<Rng2>>
difference_type_	include/range/v3/view/zip_with.hpp	/^        using difference_type_ = common_type_t<range_difference_t<Rngs>...>;$/;"	t	struct:ranges::iter_zip_with_view	typeref:typename:common_type_t<range_difference_t<Rngs>...>
difference_type_t	include/range/v3/iterator/traits.hpp	/^    using difference_type_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:iter_difference_t<T>
diffmax_t	include/range/v3/iterator/diffmax_t.hpp	/^            constexpr diffmax_t(tag, bool neg, std::uintmax_t val)$/;"	f	struct:ranges::detail::diffmax_t
diffmax_t	include/range/v3/iterator/diffmax_t.hpp	/^        struct diffmax_t$/;"	s	namespace:ranges::detail
digits	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int digits = CHAR_BIT * sizeof(std::uintmax_t) + 1;$/;"	m	struct:std::numeric_limits	typeref:typename:int
digits	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::digits;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
digits10	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int digits10 =$/;"	m	struct:std::numeric_limits	typeref:typename:int
digits10	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::digits10;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
dirty_	include/range/v3/view/cache1.hpp	/^        bool dirty_;$/;"	m	struct:ranges::cache1_view	typeref:typename:bool
disable_sized_range	include/range/v3/range/primitives.hpp	/^    RANGES_INLINE_VAR constexpr bool disable_sized_range = false;$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
dismiss	include/range/v3/utility/scope_exit.hpp	/^        void dismiss() noexcept$/;"	f	struct:ranges::scope_exit	typeref:typename:void
dismissed_	include/range/v3/utility/scope_exit.hpp	/^        bool dismissed_{false};$/;"	m	struct:ranges::scope_exit	typeref:typename:bool
dist_	include/range/v3/view/interface.hpp	/^            Int dist_;$/;"	m	struct:ranges::detail::from_end_	typeref:typename:Int
distance_	include/range/v3/view/cartesian_product.hpp	/^            difference_type distance_(cursor const & that, meta::size_t<1>) const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:difference_type
distance_	include/range/v3/view/cartesian_product.hpp	/^            difference_type distance_(cursor const & that, meta::size_t<N>) const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:difference_type
distance_compare_fn	include/range/v3/iterator/operations.hpp	/^    struct distance_compare_fn : iter_distance_compare_fn$/;"	s	namespace:ranges
distance_fn	include/range/v3/iterator/operations.hpp	/^    struct distance_fn : iter_distance_fn$/;"	s	namespace:ranges
distance_to	include/range/v3/iterator/common_iterator.hpp	/^            auto distance_to(cpp17_iterator_cursor const & that)$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:CPP_ret (std::ptrdiff_t)(requires random_access_iterator<I>)
distance_to	include/range/v3/iterator/move_iterators.hpp	/^            auto distance_to(move_into_cursor const & that) const$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:CPP_ret (iter_difference_t<I>)(requires sized_sentinel_for<I,I>)
distance_to	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr auto distance_to(reverse_cursor<J> const & that) const$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:CPP_ret (iter_difference_t<I>)(requires sized_sentinel_for<J,I>)
distance_to	include/range/v3/view/adaptor.hpp	/^        auto distance_to(adaptor_cursor const & that) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:decltype (std::declval<C const &> ().distance_to_ (that,42))
distance_to	include/range/v3/view/adaptor.hpp	/^        static auto distance_to(I const & it0, I const & it1)$/;"	f	struct:ranges::adaptor_base	typeref:typename:CPP_ret (iter_difference_t<I>)(requires sized_sentinel_for<I,I>)
distance_to	include/range/v3/view/cache1.hpp	/^            auto distance_to(cursor const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::cache1_view::cursor	typeref:typename:CPP_ret (difference_type)(requires sized_sentinel_for<iterator_t<Rng>,iterator_t<Rng>>)
distance_to	include/range/v3/view/cache1.hpp	/^            auto distance_to(sentinel const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::cache1_view::cursor	typeref:typename:CPP_ret (difference_type)(requires sized_sentinel_for<sentinel_t<Rng>,iterator_t<Rng>>)
distance_to	include/range/v3/view/chunk.hpp	/^                constexpr auto distance_to(default_sentinel_t) const$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:CPP_ret (range_difference_t<Rng>)(requires sized_sentinel_for<sentinel_t<Rng>,iterator_t<Rng>>)
distance_to	include/range/v3/view/chunk.hpp	/^            constexpr auto distance_to(default_sentinel_t) const$/;"	f	struct:ranges::chunk_view_::outer_cursor	typeref:typename:CPP_ret (range_difference_t<Rng>)(requires sized_sentinel_for<sentinel_t<Rng>,iterator_t<Rng>>)
distance_to	include/range/v3/view/chunk.hpp	/^            constexpr auto distance_to(iterator_t<CRng> const & here,$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:CPP_ret (range_difference_t<Rng>)(requires (detail::can_sized_sentinel_<Rng,Const> ()))
distance_to	include/range/v3/view/concat.hpp	/^            auto distance_to(cursor const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:CPP_ret (difference_type)(requires and_v<sized_sentinel_for<iterator_t<Rngs>,iterator_t<Rngs>>...>)
distance_to	include/range/v3/view/enumerate.hpp	/^                Diff distance_to(cursor const & that) const$/;"	f	struct:ranges::detail::index_view::cursor	typeref:typename:Diff
distance_to	include/range/v3/view/intersperse.hpp	/^            constexpr auto distance_to(iterator_t<CRng> const & it,$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:CPP_ret (range_difference_t<Rng>)(requires sized_sentinel_for<iterator_t<CRng>,iterator_t<CRng>>)
distance_to	include/range/v3/view/iota.hpp	/^            auto distance_to(cursor const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:CPP_ret (difference_type)(requires detail::advanceable_<From>)
distance_to	include/range/v3/view/iota.hpp	/^            auto distance_to(cursor const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:CPP_ret (difference_type)(requires detail::advanceable_<From>)
distance_to	include/range/v3/view/iota.hpp	/^            auto distance_to(default_sentinel_t) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:CPP_ret (difference_type)(requires sized_sentinel_for<To,From>)
distance_to	include/range/v3/view/iota.hpp	/^            auto distance_to(sentinel const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:CPP_ret (difference_type)(requires sized_sentinel_for<To,From>)
distance_to	include/range/v3/view/repeat.hpp	/^            std::ptrdiff_t distance_to(cursor const & that) const$/;"	f	struct:ranges::repeat_view::cursor	typeref:typename:std::ptrdiff_t
distance_to	include/range/v3/view/repeat_n.hpp	/^            std::ptrdiff_t distance_to(cursor const & that) const$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:std::ptrdiff_t
distance_to	include/range/v3/view/stride.hpp	/^            constexpr auto distance_to(iterator_t<CRng> const & here,$/;"	f	struct:ranges::stride_view::adaptor	typeref:typename:CPP_ret (range_difference_t<Rng>)(requires sized_sentinel_for<Other,iterator_t<CRng>>)
distance_to	include/range/v3/view/transform.hpp	/^            auto distance_to(cursor const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::iter_transform2_view::cursor	typeref:typename:CPP_ret (difference_type)(requires sized_sentinel_for<iterator_t<R1>,iterator_t<R1>> && sized_sentinel_for<iterator_t<R2>,iterator_t<R2>>)
distance_to	include/range/v3/view/zip_with.hpp	/^            auto distance_to(cursor const & that) const -> CPP_ret(difference_type)( \/\/$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:CPP_ret (difference_type)(requires and_v<sized_sentinel_for<iterator_t<meta::const_if_c<Const,Rngs>>,iterator_t<meta::const_if_c<Const,Rngs>>>...>)
distance_to_	include/range/v3/view/adaptor.hpp	/^        R distance_to_(adaptor_cursor const & that, int) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:R
distance_to_	include/range/v3/view/adaptor.hpp	/^        R distance_to_(adaptor_cursor const & that, long) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:R
distance_to_	include/range/v3/view/concat.hpp	/^            [[noreturn]] static difference_type distance_to_(meta::size_t<cranges>,$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:[[noreturn]]difference_type
distance_to_	include/range/v3/view/concat.hpp	/^            static difference_type distance_to_(meta::size_t<N>, cursor const & from,$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:difference_type
distance_to_	include/range/v3/view/zip_with.hpp	/^        struct distance_to_$/;"	s	namespace:ranges::detail
divides	include/meta/meta.hpp	/^        using divides = defer<divides, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<divides,T,U>
divides	include/meta/meta.hpp	/^    using divides = std::integral_constant<decltype(T::type::value \/ U::type::value),$/;"	t	namespace:meta
done	include/meta/meta.hpp	/^            done,$/;"	e	enum:meta::detail::indices_strategy_
done	include/range/v3/view/any_view.hpp	/^            virtual bool done() override$/;"	f	struct:ranges::detail::any_input_view_impl	typeref:typename:bool
done	include/range/v3/view/chunk.hpp	/^                constexpr bool done() const noexcept$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:bool
done	include/range/v3/view/chunk.hpp	/^            constexpr bool done() const$/;"	f	struct:ranges::chunk_view_::outer_cursor	typeref:typename:bool
done_	include/range/v3/view/iota.hpp	/^            bool done_ = false;$/;"	m	struct:ranges::closed_iota_view::cursor	typeref:typename:bool
done_	include/range/v3/view/split.hpp	/^            constexpr bool done_() const$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:bool
drop_base_fn	include/range/v3/view/drop.hpp	/^        struct drop_base_fn$/;"	s	namespace:ranges::views
drop_exactly_base_fn	include/range/v3/view/drop_exactly.hpp	/^        struct drop_exactly_base_fn$/;"	s	namespace:ranges::views
drop_exactly_fn	include/range/v3/view/drop_exactly.hpp	/^        struct drop_exactly_fn : drop_exactly_base_fn$/;"	s	namespace:ranges::views
drop_exactly_view	include/range/v3/view/drop_exactly.hpp	/^        drop_exactly_view(Rng rng, difference_type_ n)$/;"	f	struct:ranges::drop_exactly_view
drop_exactly_view	include/range/v3/view/drop_exactly.hpp	/^    struct RANGES_EMPTY_BASES drop_exactly_view$/;"	s	namespace:ranges
drop_fn	include/range/v3/action/drop.hpp	/^        struct drop_fn$/;"	s	namespace:ranges::actions
drop_fn	include/range/v3/view/drop.hpp	/^        struct drop_fn : drop_base_fn$/;"	s	namespace:ranges::views
drop_last_base_fn	include/range/v3/view/drop_last.hpp	/^        struct drop_last_base_fn$/;"	s	namespace:ranges::views
drop_last_fn	include/range/v3/view/drop_last.hpp	/^        struct drop_last_fn : drop_last_base_fn$/;"	s	namespace:ranges::views
drop_last_view	include/range/v3/view/drop_last.hpp	/^        constexpr drop_last_view(Rng rng, difference_t n)$/;"	f	struct:ranges::drop_last_view
drop_last_view	include/range/v3/view/drop_last.hpp	/^        namespace drop_last_view$/;"	n	namespace:ranges::detail
drop_last_view	include/range/v3/view/drop_last.hpp	/^    struct drop_last_view$/;"	s	namespace:ranges
drop_last_view	include/range/v3/view/drop_last.hpp	/^    struct drop_last_view<Rng, detail::drop_last_view::mode_bidi>$/;"	s	namespace:ranges
drop_last_view	include/range/v3/view/drop_last.hpp	/^    struct drop_last_view<Rng, detail::drop_last_view::mode_forward>$/;"	s	namespace:ranges
drop_last_view	include/range/v3/view/drop_last.hpp	/^    struct drop_last_view<Rng, detail::drop_last_view::mode_sized>$/;"	s	namespace:ranges
drop_view	include/range/v3/view/drop.hpp	/^            using drop_view = ranges::drop_view<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::drop_view<Rng>
drop_view	include/range/v3/view/drop.hpp	/^        drop_view(Rng rng, difference_type_ n)$/;"	f	struct:ranges::drop_view
drop_view	include/range/v3/view/drop.hpp	/^    struct RANGES_EMPTY_BASES drop_view$/;"	s	namespace:ranges
drop_while_base_fn	include/range/v3/view/drop_while.hpp	/^        struct drop_while_base_fn$/;"	s	namespace:ranges::views
drop_while_fn	include/range/v3/action/drop_while.hpp	/^        struct drop_while_fn$/;"	s	namespace:ranges::actions
drop_while_fn	include/range/v3/view/drop_while.hpp	/^        struct drop_while_fn : drop_while_base_fn$/;"	s	namespace:ranges::views
drop_while_view	include/range/v3/view/drop_while.hpp	/^            using drop_while_view = ranges::drop_while_view<Rng, Pred>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::drop_while_view<Rng,Pred>
drop_while_view	include/range/v3/view/drop_while.hpp	/^        drop_while_view(Rng rng, Pred pred)$/;"	f	struct:ranges::drop_while_view
drop_while_view	include/range/v3/view/drop_while.hpp	/^    struct drop_while_view$/;"	s	namespace:ranges
dummy_	include/range/v3/utility/optional.hpp	/^                    char dummy_;$/;"	m	union:ranges::detail::optional_adl::optional_storage::__anon8c726b6b020a	typeref:typename:char
dummy_	include/range/v3/utility/optional.hpp	/^                    char dummy_;$/;"	m	union:ranges::detail::optional_adl::optional_storage::__anon8c726b6b030a	typeref:typename:char
dynamic_extent	include/range/v3/view/span.hpp	/^    constexpr detail::span_index_t dynamic_extent = -1;$/;"	v	namespace:ranges	typeref:typename:detail::span_index_t
ebo	include/range/v3/utility/box.hpp	/^            ebo,  \/\/ Apply Empty Base Optimization: get() returns a reference to a T base$/;"	e	enum:ranges::detail::box_compress
elapsed	example/comprehensions.cpp	/^  std::chrono::milliseconds elapsed() const {$/;"	f	class:timer	typeref:typename:std::chrono::milliseconds	file:
elem_t	include/range/v3/detail/variant.hpp	/^                using elem_t = meta::_t<$/;"	t	function:ranges::detail::variant_get::get	typeref:typename:meta::_t<std::remove_reference<meta::at_c<meta::as_list<Variant>,N> const>>
elem_t	include/range/v3/detail/variant.hpp	/^                using elem_t = meta::_t<$/;"	t	function:ranges::detail::variant_get::get	typeref:typename:meta::_t<std::remove_reference<meta::at_c<meta::as_list<Variant>,N>>>
element_assign_	include/range/v3/utility/common_tuple.hpp	/^        struct element_assign_$/;"	s	struct:ranges::common_tuple
element_t	include/range/v3/range/concepts.hpp	/^        using element_t = meta::_t<std::remove_pointer<data_t<Rng>>>;$/;"	t	namespace:ranges::detail	typeref:typename:meta::_t<std::remove_pointer<data_t<Rng>>>
element_type	include/range/v3/view/span.hpp	/^        using element_type = T;$/;"	t	struct:ranges::span	typeref:typename:T
emplace	include/range/v3/detail/variant.hpp	/^        auto emplace(Args &&... args) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::variant	typeref:typename:CPP_ret (void)(requires constructible_from<datum_t<N>,Args...>)
emplace	include/range/v3/detail/variant.hpp	/^    emplace(variant<Ts...> & var, Args &&... args)$/;"	f	namespace:ranges	typeref:typename:meta::if_c<(bool)constructible_from<detail::variant_datum_t<N,Ts...>,Args...>>
emplace	include/range/v3/utility/optional.hpp	/^        auto emplace(Args &&... args) noexcept($/;"	f	struct:ranges::optional	typeref:typename:auto
emplace	include/range/v3/utility/optional.hpp	/^        auto emplace(std::initializer_list<E> il, Args &&... args) noexcept($/;"	f	struct:ranges::optional	typeref:typename:auto
emplace_fn	include/range/v3/detail/variant.hpp	/^        struct emplace_fn$/;"	s	namespace:ranges::detail
emplace_fn	include/range/v3/iterator/common_iterator.hpp	/^        struct emplace_fn$/;"	s	struct:ranges::common_iterator
emplaced_index	include/range/v3/detail/variant.hpp	/^        constexpr auto & emplaced_index = static_const<emplaced_index_t<I>>::value;$/;"	v	namespace:ranges::__anon4da570f90110	typeref:typename:auto &
emplaced_index	include/range/v3/detail/variant.hpp	/^    inline constexpr emplaced_index_t<I> emplaced_index{};$/;"	v	namespace:ranges	typeref:typename:emplaced_index_t<I>
emplaced_index	include/range/v3/detail/variant.hpp	/^    inline emplaced_index_t<I> emplaced_index()$/;"	f	namespace:ranges	typeref:typename:emplaced_index_t<I>
emplaced_index_t	include/range/v3/detail/variant.hpp	/^    struct emplaced_index_t : meta::size_t<I>$/;"	s	namespace:ranges
empty	include/range/v3/iterator_range.hpp	/^        constexpr bool empty() const$/;"	f	struct:ranges::iterator_range	typeref:typename:bool
empty	include/range/v3/utility/any.hpp	/^        bool empty() const noexcept$/;"	f	struct:ranges::any	typeref:typename:bool
empty	include/range/v3/view/adaptor.hpp	/^        static constexpr auto empty(I const & it, S const & last) -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::adaptor_base	typeref:typename:CPP_ret (bool)(requires sentinel_for<S,I>)
empty	include/range/v3/view/delimit.hpp	/^            bool empty(I const & it, S const & last) const$/;"	f	struct:ranges::delimit_view::sentinel_adaptor	typeref:typename:bool
empty	include/range/v3/view/drop_last.hpp	/^            bool empty(I const &, adaptor const & ia, S const & s) const$/;"	f	struct:ranges::drop_last_view::sentinel_adaptor	typeref:typename:bool
empty	include/range/v3/view/empty.hpp	/^        RANGES_INLINE_VAR constexpr empty_view<T> empty{};$/;"	v	namespace:ranges::views	typeref:typename:RANGES_INLINE_VAR empty_view<T>
empty	include/range/v3/view/interface.hpp	/^        constexpr auto empty() const noexcept -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_member auto
empty	include/range/v3/view/interface.hpp	/^        constexpr auto empty() const$/;"	f	struct:ranges::view_interface	typeref:typename:auto
empty	include/range/v3/view/interface.hpp	/^        constexpr auto empty() noexcept($/;"	f	struct:ranges::view_interface	typeref:typename:auto
empty	include/range/v3/view/interface.hpp	/^        constexpr auto empty() noexcept(noexcept($/;"	f	struct:ranges::view_interface	typeref:typename:auto
empty	include/range/v3/view/intersperse.hpp	/^            static constexpr bool empty(iterator_t<CRng> const & it,$/;"	f	struct:ranges::intersperse_view::sentinel_adaptor	typeref:typename:bool
empty	include/range/v3/view/ref.hpp	/^        constexpr auto empty() const noexcept(noexcept(ranges::empty(*rng_)))$/;"	f	struct:ranges::ref_view	typeref:typename:CPP_member auto
empty	include/range/v3/view/span.hpp	/^        constexpr bool empty() const noexcept$/;"	f	struct:ranges::span	typeref:typename:bool
empty	include/range/v3/view/subrange.hpp	/^        constexpr bool empty() const$/;"	f	struct:ranges::subrange	typeref:typename:bool
empty	include/range/v3/view/take_while.hpp	/^            bool empty(iterator_t<CRng> const & it, sentinel_t<CRng> const & last) const$/;"	f	struct:ranges::iter_take_while_view::sentinel_adaptor	typeref:typename:bool
empty_variant_tag	include/range/v3/detail/variant.hpp	/^        struct empty_variant_tag$/;"	s	namespace:ranges::detail
empty_view	include/range/v3/view/empty.hpp	/^            using empty_view = ranges::empty_view<T>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::empty_view<T>
empty_view	include/range/v3/view/empty.hpp	/^    struct empty_view$/;"	s	namespace:ranges
empty_view_base	include/range/v3/view/empty.hpp	/^        struct empty_view_base$/;"	s	namespace:ranges::detail
enable_coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^        class enable_coroutine_owner$/;"	c	namespace:ranges::experimental
enable_if	include/std/detail/associated_types.hpp	/^        struct enable_if$/;"	s	namespace:ranges::detail
enable_if	include/std/detail/associated_types.hpp	/^        struct enable_if<true>$/;"	s	namespace:ranges::detail
enable_if_t	include/std/detail/associated_types.hpp	/^        using enable_if_t = typename enable_if<B>::template apply<T>;$/;"	t	namespace:ranges::detail	typeref:typename:enable_if<B>::template apply<T>
enable_view	include/range/v3/range/concepts.hpp	/^    RANGES_INLINE_VAR constexpr bool enable_view =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
enable_view_helper_	include/range/v3/range/concepts.hpp	/^            constexpr enable_view_helper_(T const * p)$/;"	f	struct:ranges::detail::enable_view_helper_
enable_view_helper_	include/range/v3/range/concepts.hpp	/^        struct enable_view_helper_$/;"	s	namespace:ranges::detail
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_($/;"	f	namespace:ranges::detail	typeref:typename:bool
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_(...)$/;"	f	namespace:ranges::detail	typeref:typename:bool
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_(enable_view_helper_ ev)$/;"	f	namespace:ranges::detail	typeref:typename:bool
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_(std::initializer_list<T> const *)$/;"	f	namespace:ranges::detail	typeref:typename:bool
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_(std::multiset<Key, Compare, Alloc> const *)$/;"	f	namespace:ranges::detail	typeref:typename:bool
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_(std::set<Key, Compare, Alloc> const *)$/;"	f	namespace:ranges::detail	typeref:typename:bool
enable_view_impl_	include/range/v3/range/concepts.hpp	/^        constexpr bool enable_view_impl_(view_base const *)$/;"	f	namespace:ranges::detail	typeref:typename:bool
end	include/range/v3/experimental/view/shared.hpp	/^            sentinel_t<Rng> end() const$/;"	f	struct:ranges::experimental::shared_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/iterator_range.hpp	/^        S end() const$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:S
end	include/range/v3/iterator_range.hpp	/^        constexpr S & end() &$/;"	f	struct:ranges::iterator_range	typeref:typename:S &
end	include/range/v3/iterator_range.hpp	/^        constexpr S const & end() const &$/;"	f	struct:ranges::iterator_range	typeref:typename:S const &
end	include/range/v3/iterator_range.hpp	/^        constexpr S end(iterator_range<I, S> && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:S
end	include/range/v3/iterator_range.hpp	/^        constexpr S end(iterator_range<I, S> const && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:S
end	include/range/v3/iterator_range.hpp	/^        constexpr S end(sized_iterator_range<I, S> && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:S
end	include/range/v3/iterator_range.hpp	/^        constexpr S end(sized_iterator_range<I, S> const && r) noexcept($/;"	f	namespace:ranges::_iterator_range_	typeref:typename:S
end	include/range/v3/view/common.hpp	/^        auto end() const$/;"	f	struct:ranges::common_view	typeref:typename:CPP_ret (detail::common_view_iterator_t<meta::const_if_c<Const,Rng>>)(requires range<meta::const_if_c<Const,Rng>>)
end	include/range/v3/view/common.hpp	/^        detail::common_view_iterator_t<Rng> end()$/;"	f	struct:ranges::common_view	typeref:typename:detail::common_view_iterator_t<Rng>
end	include/range/v3/view/counted.hpp	/^        default_sentinel_t end() const$/;"	f	struct:ranges::counted_view	typeref:typename:default_sentinel_t
end	include/range/v3/view/drop.hpp	/^        auto end() const -> CPP_ret(sentinel_t<meta::const_if_c<Const, Rng>>)( \/\/$/;"	f	struct:ranges::drop_view	typeref:typename:CPP_ret (sentinel_t<meta::const_if_c<Const,Rng>>)(requires Const && random_access_range<meta::const_if_c<Const,Rng>>)
end	include/range/v3/view/drop.hpp	/^        sentinel_t<Rng> end()$/;"	f	struct:ranges::drop_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/drop_exactly.hpp	/^        auto end() const -> CPP_ret(sentinel_t<meta::const_if_c<Const, Rng>>)( \/\/$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:CPP_ret (sentinel_t<meta::const_if_c<Const,Rng>>)(requires Const && random_access_range<meta::const_if_c<Const,Rng>>)
end	include/range/v3/view/drop_exactly.hpp	/^        sentinel_t<Rng> end()$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/drop_last.hpp	/^        auto end() const -> CPP_ret(iterator_t<CRng>)( \/\/$/;"	f	struct:ranges::drop_last_view	typeref:typename:CPP_ret (iterator_t<CRng>)(requires random_access_range<CRng> && sized_range<CRng>)
end	include/range/v3/view/drop_last.hpp	/^        default_sentinel_t end() const$/;"	f	struct:ranges::drop_last_view	typeref:typename:default_sentinel_t
end	include/range/v3/view/drop_last.hpp	/^        sentinel_t<Rng> end()$/;"	f	struct:ranges::drop_last_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/drop_while.hpp	/^        sentinel_t<Rng> end()$/;"	f	struct:ranges::drop_while_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/empty.hpp	/^            friend constexpr T * end(empty_view<T>) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:T *
end	include/range/v3/view/empty.hpp	/^        static constexpr T * end() noexcept$/;"	f	struct:ranges::empty_view	typeref:typename:T *
end	include/range/v3/view/facade.hpp	/^        constexpr auto end() -> CPP_ret(detail::facade_sentinel_t<D>)( \/\/$/;"	f	struct:ranges::view_facade	typeref:typename:CPP_ret (detail::facade_sentinel_t<D>)(requires same_as<D,Derived>)
end	include/range/v3/view/facade.hpp	/^        constexpr auto end() const -> CPP_ret(detail::facade_sentinel_t<D const>)( \/\/$/;"	f	struct:ranges::view_facade	typeref:typename:CPP_ret (detail::facade_sentinel_t<D const>)(requires same_as<D,Derived>)
end	include/range/v3/view/iota.hpp	/^        constexpr auto end(closed_iota_view<From, To> r)$/;"	f	namespace:ranges::iota_view_detail	typeref:typename:auto
end	include/range/v3/view/iota.hpp	/^        constexpr auto end(iota_view<From, To> r)$/;"	f	namespace:ranges::iota_view_detail	typeref:typename:auto
end	include/range/v3/view/ref.hpp	/^        constexpr sentinel_t<Rng> end() const noexcept(noexcept(ranges::end(*rng_)))$/;"	f	struct:ranges::ref_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/ref.hpp	/^        constexpr sentinel_t<Rng> end(ref_view<Rng> && rng) noexcept(noexcept(rng.end()))$/;"	f	namespace:ranges::_ref_view_	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/ref.hpp	/^        constexpr sentinel_t<Rng> end(ref_view<Rng> const && rng) noexcept($/;"	f	namespace:ranges::_ref_view_	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/reverse.hpp	/^        constexpr auto end() const$/;"	f	struct:ranges::reverse_view	typeref:typename:CPP_ret (reverse_iterator<iterator_t<meta::const_if_c<Const,Rng>>>)(requires Const && common_range<meta::const_if_c<Const,Rng>>)
end	include/range/v3/view/reverse.hpp	/^        constexpr reverse_iterator<iterator_t<Rng>> end()$/;"	f	struct:ranges::reverse_view	typeref:typename:reverse_iterator<iterator_t<Rng>>
end	include/range/v3/view/single.hpp	/^        constexpr T * end() noexcept$/;"	f	struct:ranges::single_view	typeref:typename:T *
end	include/range/v3/view/single.hpp	/^        constexpr T const * end() const noexcept$/;"	f	struct:ranges::single_view	typeref:typename:T const *
end	include/range/v3/view/slice.hpp	/^            auto end() const -> CPP_ret(iterator_t<BaseRng const>)( \/\/$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:CPP_ret (iterator_t<BaseRng const>)(requires range<BaseRng const>)
end	include/range/v3/view/slice.hpp	/^            default_sentinel_t end()$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:default_sentinel_t
end	include/range/v3/view/slice.hpp	/^            iterator_t<Rng> end()$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:iterator_t<Rng>
end	include/range/v3/view/sliding.hpp	/^            iterator_t<CRng> end(meta::const_if_c<Const, sliding_view> & v) const$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:iterator_t<CRng>
end	include/range/v3/view/sliding.hpp	/^            iterator_t<Rng> end(sliding_view & v)$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:iterator_t<Rng>
end	include/range/v3/view/span.hpp	/^        constexpr iterator end() const noexcept$/;"	f	struct:ranges::span	typeref:typename:iterator
end	include/range/v3/view/split.hpp	/^                constexpr default_sentinel_t end() const$/;"	f	struct:ranges::detail::split_outer_iterator::value_type	typeref:typename:default_sentinel_t
end	include/range/v3/view/split.hpp	/^        constexpr auto end() -> CPP_ret(outer_iterator<simple_view<V>()>)( \/\/$/;"	f	struct:ranges::split_view	typeref:typename:CPP_ret (outer_iterator<simple_view<V> ()>)(requires forward_range<V> && common_range<V>)
end	include/range/v3/view/split.hpp	/^        constexpr auto end() const$/;"	f	struct:ranges::split_view	typeref:typename:auto
end	include/range/v3/view/subrange.hpp	/^        constexpr S end() const noexcept(std::is_nothrow_copy_constructible<S>::value)$/;"	f	struct:ranges::subrange	typeref:typename:S
end	include/range/v3/view/subrange.hpp	/^        constexpr S end(subrange<I, S, K> && r) noexcept($/;"	f	namespace:ranges::_subrange_	typeref:typename:S
end	include/range/v3/view/subrange.hpp	/^        constexpr S end(subrange<I, S, K> const && r) noexcept($/;"	f	namespace:ranges::_subrange_	typeref:typename:S
end	include/range/v3/view/tail.hpp	/^        auto end() const -> CPP_ret(sentinel_t<meta::const_if_c<Const, Rng>>)( \/\/$/;"	f	struct:ranges::tail_view	typeref:typename:CPP_ret (sentinel_t<meta::const_if_c<Const,Rng>>)(requires Const && range<meta::const_if_c<Const,Rng>>)
end	include/range/v3/view/tail.hpp	/^        sentinel_t<Rng> end()$/;"	f	struct:ranges::tail_view	typeref:typename:sentinel_t<Rng>
end	include/range/v3/view/take_exactly.hpp	/^            default_sentinel_t end() const$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:default_sentinel_t
end	include/range/v3/view/take_exactly.hpp	/^            iterator_t<Rng> end()$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:iterator_t<Rng>
end	include/range/v3/view/tokenize.hpp	/^        auto end() const -> CPP_ret(iterator_t<Const>)( \/\/$/;"	f	struct:ranges::tokenize_view	typeref:typename:CPP_ret (iterator_t<Const>)(requires range<Rng const>)
end	include/range/v3/view/tokenize.hpp	/^        iterator_t<simple_view<Rng>()> end()$/;"	f	struct:ranges::tokenize_view	typeref:typename:iterator_t<simple_view<Rng> ()>
end	include/range/v3/view/trim.hpp	/^        iterator_t<Rng> end()$/;"	f	struct:ranges::trim_view	typeref:typename:iterator_t<Rng>
end	include/range/v3/view/unbounded.hpp	/^        constexpr unreachable_sentinel_t end() const$/;"	f	struct:ranges::unbounded_view	typeref:typename:unreachable_sentinel_t
end	test/p.cpp	/^  aiterator end() { return aiterator{}; }$/;"	f	struct:tree_iterator	typeref:typename:aiterator	file:
end1_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R1> end1_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:sentinel_t<R1>
end1_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R1> end1_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:sentinel_t<R1>
end1_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R1> end1_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:sentinel_t<R1>
end1_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R1> end1_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:sentinel_t<R1>
end1_	include/range/v3/view/transform.hpp	/^            sentinel_t<meta::const_if_c<Const, Rng1>> end1_;$/;"	m	struct:ranges::iter_transform2_view::sentinel	typeref:typename:sentinel_t<meta::const_if_c<Const,Rng1>>
end2_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R2> end2_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:sentinel_t<R2>
end2_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R2> end2_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:sentinel_t<R2>
end2_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R2> end2_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:sentinel_t<R2>
end2_	include/range/v3/view/set_algorithm.hpp	/^            sentinel_t<R2> end2_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:sentinel_t<R2>
end2_	include/range/v3/view/transform.hpp	/^            sentinel_t<meta::const_if_c<Const, Rng2>> end2_;$/;"	m	struct:ranges::iter_transform2_view::sentinel	typeref:typename:sentinel_t<meta::const_if_c<Const,Rng2>>
end_	include/range/v3/view/chunk.hpp	/^            sentinel_t<CRng> end_;$/;"	m	struct:ranges::chunk_view_::adaptor	typeref:typename:sentinel_t<CRng>
end_	include/range/v3/view/common.hpp	/^        auto end_(std::false_type) const$/;"	f	struct:ranges::common_view	typeref:typename:CPP_ret (sentinel_t<meta::const_if_c<Const,Rng>>)(requires Const && range<meta::const_if_c<Const,Rng>>)
end_	include/range/v3/view/common.hpp	/^        auto end_(std::true_type) const$/;"	f	struct:ranges::common_view	typeref:typename:CPP_ret (iterator_t<meta::const_if_c<Const,Rng>>)(requires Const && range<meta::const_if_c<Const,Rng>>)
end_	include/range/v3/view/common.hpp	/^        iterator_t<Rng> end_(std::true_type)$/;"	f	struct:ranges::common_view	typeref:typename:iterator_t<Rng>
end_	include/range/v3/view/common.hpp	/^        sentinel_t<Rng> end_(std::false_type)$/;"	f	struct:ranges::common_view	typeref:typename:sentinel_t<Rng>
end_	include/range/v3/view/concat.hpp	/^            sentinel_t<constify_if<meta::back<meta::list<Rngs...>>>> end_;$/;"	m	struct:ranges::concat_view::sentinel	typeref:typename:sentinel_t<constify_if<meta::back<meta::list<Rngs...>>>>
end_	include/range/v3/view/drop_last.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> end_;$/;"	m	struct:ranges::drop_last_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
end_	include/range/v3/view/split.hpp	/^        default_sentinel_t end_(std::false_type) const$/;"	f	struct:ranges::split_view	typeref:typename:default_sentinel_t
end_	include/range/v3/view/split.hpp	/^        outer_iterator<simple_view<V>()> end_(std::true_type) const$/;"	f	struct:ranges::split_view	typeref:typename:outer_iterator<simple_view<V> ()>
end_	include/range/v3/view/take.hpp	/^            sentinel_t<Base> end_ = sentinel_t<Base>();$/;"	m	struct:ranges::take_view::sentinel	typeref:typename:sentinel_t<Base>
end_	include/range/v3/view/trim.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> end_;$/;"	m	struct:ranges::trim_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
end_adaptor	include/range/v3/view/adaptor.hpp	/^        constexpr adaptor_base end_adaptor() const noexcept$/;"	f	struct:ranges::view_adaptor	typeref:typename:adaptor_base
end_adaptor	include/range/v3/view/adjacent_filter.hpp	/^        constexpr auto end_adaptor() const noexcept -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::adjacent_filter_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/adjacent_filter.hpp	/^        constexpr auto end_adaptor() noexcept -> adaptor<false>$/;"	f	struct:ranges::adjacent_filter_view	typeref:typename:auto
end_adaptor	include/range/v3/view/adjacent_remove_if.hpp	/^        constexpr auto end_adaptor() -> CPP_ret(adaptor)( \/\/$/;"	f	struct:ranges::adjacent_remove_if_view	typeref:typename:CPP_ret (adaptor)(requires common_range<Rng>)
end_adaptor	include/range/v3/view/adjacent_remove_if.hpp	/^        constexpr auto end_adaptor() noexcept -> CPP_ret(adaptor_base)( \/\/$/;"	f	struct:ranges::adjacent_remove_if_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/const.hpp	/^        adaptor<simple_view<Rng>()> end_adaptor()$/;"	f	struct:ranges::const_view	typeref:typename:adaptor<simple_view<Rng> ()>
end_adaptor	include/range/v3/view/const.hpp	/^        auto end_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::const_view	typeref:typename:CPP_ret (adaptor<true>)(requires range<Rng const>)
end_adaptor	include/range/v3/view/delimit.hpp	/^        sentinel_adaptor end_adaptor() const$/;"	f	struct:ranges::delimit_view	typeref:typename:sentinel_adaptor
end_adaptor	include/range/v3/view/drop_last.hpp	/^        sentinel_adaptor end_adaptor()$/;"	f	struct:ranges::drop_last_view	typeref:typename:sentinel_adaptor
end_adaptor	include/range/v3/view/exclusive_scan.hpp	/^        auto end_adaptor() const$/;"	f	struct:ranges::exclusive_scan_view	typeref:typename:CPP_ret (meta::if_<use_sentinel_t,adaptor_base,adaptor<true>>)(requires exclusive_scan_constraints<Rng const,T,Fun const>)
end_adaptor	include/range/v3/view/exclusive_scan.hpp	/^        meta::if_<use_sentinel_t, adaptor_base, adaptor<false>> end_adaptor()$/;"	f	struct:ranges::exclusive_scan_view	typeref:typename:meta::if_<use_sentinel_t,adaptor_base,adaptor<false>>
end_adaptor	include/range/v3/view/indirect.hpp	/^        constexpr auto end_adaptor() const noexcept -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::indirect_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/indirect.hpp	/^        constexpr auto end_adaptor() noexcept -> CPP_ret(adaptor<false>)( \/\/$/;"	f	struct:ranges::indirect_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/intersperse.hpp	/^        constexpr auto end_adaptor() -> CPP_ret(cursor_adaptor<false>)( \/\/$/;"	f	struct:ranges::intersperse_view	typeref:typename:CPP_ret (cursor_adaptor<false>)(requires common_range<Rng> && (!single_pass_iterator_<iterator_t<Rng>>))
end_adaptor	include/range/v3/view/intersperse.hpp	/^        constexpr auto end_adaptor() const -> CPP_ret(cursor_adaptor<Const>)( \/\/$/;"	f	struct:ranges::intersperse_view	typeref:typename:CPP_ret (cursor_adaptor<Const>)(requires Const && range<meta::const_if_c<Const,Rng>> && common_range<meta::const_if_c<Const,Rng>> && (!single_pass_iterator_<iterator_t<meta::const_if_c<Const,Rng>>>))
end_adaptor	include/range/v3/view/intersperse.hpp	/^        constexpr auto end_adaptor() const noexcept$/;"	f	struct:ranges::intersperse_view	typeref:typename:auto
end_adaptor	include/range/v3/view/intersperse.hpp	/^        constexpr auto end_adaptor() noexcept -> CPP_ret(sentinel_adaptor<false>)( \/\/$/;"	f	struct:ranges::intersperse_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/move.hpp	/^        adaptor<simple_view<Rng>()> end_adaptor()$/;"	f	struct:ranges::move_view	typeref:typename:adaptor<simple_view<Rng> ()>
end_adaptor	include/range/v3/view/move.hpp	/^        auto end_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::move_view	typeref:typename:CPP_ret (adaptor<true>)(requires input_range<Rng const>)
end_adaptor	include/range/v3/view/remove_if.hpp	/^        constexpr auto end_adaptor() -> CPP_ret(adaptor)( \/\/$/;"	f	struct:ranges::remove_if_view	typeref:typename:CPP_ret (adaptor)(requires common_range<Rng>)
end_adaptor	include/range/v3/view/remove_if.hpp	/^        constexpr auto end_adaptor() const noexcept -> CPP_ret(adaptor_base)( \/\/$/;"	f	struct:ranges::remove_if_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/sliding.hpp	/^        adaptor end_adaptor()$/;"	f	struct:ranges::sliding_view	typeref:typename:adaptor
end_adaptor	include/range/v3/view/sliding.hpp	/^        adaptor<simple_view<Rng>()> end_adaptor()$/;"	f	struct:ranges::sliding_view	typeref:typename:adaptor<simple_view<Rng> ()>
end_adaptor	include/range/v3/view/sliding.hpp	/^        auto end_adaptor() const -> CPP_ret(adaptor<true>)( \/\/$/;"	f	struct:ranges::sliding_view	typeref:typename:CPP_ret (adaptor<true>)(requires range<Rng const>)
end_adaptor	include/range/v3/view/sliding.hpp	/^        meta::if_c<common_range<Rng>, adaptor, adaptor_base> end_adaptor()$/;"	f	struct:ranges::sliding_view	typeref:typename:meta::if_c<common_range<Rng>,adaptor,adaptor_base>
end_adaptor	include/range/v3/view/stride.hpp	/^        constexpr auto end_adaptor() const noexcept$/;"	f	struct:ranges::stride_view	typeref:typename:CPP_member auto
end_adaptor	include/range/v3/view/stride.hpp	/^        constexpr auto end_adaptor() noexcept$/;"	f	struct:ranges::stride_view	typeref:typename:auto
end_adaptor	include/range/v3/view/take_while.hpp	/^        auto end_adaptor() const -> CPP_ret(sentinel_adaptor<Const>)( \/\/$/;"	f	struct:ranges::iter_take_while_view	typeref:typename:CPP_ret (sentinel_adaptor<Const>)(requires Const && range<meta::const_if_c<Const,Rng>> && invocable<Pred const &,iterator_t<meta::const_if_c<Const,Rng>>>)
end_adaptor	include/range/v3/view/take_while.hpp	/^        sentinel_adaptor<false> end_adaptor()$/;"	f	struct:ranges::iter_take_while_view	typeref:typename:sentinel_adaptor<false>
end_adaptor	include/range/v3/view/transform.hpp	/^        auto end_adaptor() const$/;"	f	struct:ranges::iter_transform_view	typeref:typename:CPP_ret (meta::if_<use_sentinel_t<Const>,adaptor_base,adaptor<Const>>)(requires Const && range<meta::const_if_c<Const,Rng>> && detail::iter_transform_1_readable<Fun const,meta::const_if_c<Const,Rng>>)
end_adaptor	include/range/v3/view/transform.hpp	/^        meta::if_<use_sentinel_t<false>, adaptor_base, adaptor<false>> end_adaptor()$/;"	f	struct:ranges::iter_transform_view	typeref:typename:meta::if_<use_sentinel_t<false>,adaptor_base,adaptor<false>>
end_adaptor_t	include/range/v3/view/adaptor.hpp	/^        using end_adaptor_t = detail::decay_t<decltype($/;"	t	namespace:ranges::detail
end_cursor	include/range/v3/view/adaptor.hpp	/^        constexpr auto end_cursor() const noexcept($/;"	f	struct:ranges::view_adaptor	typeref:typename:auto
end_cursor	include/range/v3/view/adaptor.hpp	/^        constexpr auto end_cursor() noexcept($/;"	f	struct:ranges::view_adaptor	typeref:typename:auto
end_cursor	include/range/v3/view/cache1.hpp	/^        auto end_cursor()$/;"	f	struct:ranges::cache1_view	typeref:typename:auto
end_cursor	include/range/v3/view/cartesian_product.hpp	/^        auto end_cursor() -> CPP_ret(cursor<false>)( \/\/$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:CPP_ret (cursor<false>)(requires cartesian_produce_view_can_bidi<std::false_type,Views...>)
end_cursor	include/range/v3/view/cartesian_product.hpp	/^        auto end_cursor() const -> CPP_ret(cursor<true>)( \/\/$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:CPP_ret (cursor<true>)(requires cartesian_produce_view_can_bidi<std::true_type,Views...>)
end_cursor	include/range/v3/view/cartesian_product.hpp	/^        auto end_cursor() const -> CPP_ret(default_sentinel_t)( \/\/$/;"	f	struct:ranges::cartesian_product_view	typeref:typename:CPP_ret (default_sentinel_t)(requires (!cartesian_produce_view_can_bidi<std::true_type,Views...>))
end_cursor	include/range/v3/view/concat.hpp	/^        auto end_cursor() const -> CPP_ret($/;"	f	struct:ranges::concat_view	typeref:typename:CPP_ret (meta::if_<meta::and_c<(bool)common_range<Rngs const>...>,cursor<true>,sentinel<true>>)(requires and_v<range<Rngs const>...>)
end_cursor	include/range/v3/view/concat.hpp	/^        end_cursor()$/;"	f	struct:ranges::concat_view
end_cursor	include/range/v3/view/cycle.hpp	/^        unreachable_sentinel_t end_cursor() const$/;"	f	struct:ranges::cycled_view	typeref:typename:unreachable_sentinel_t
end_cursor	include/range/v3/view/enumerate.hpp	/^            unreachable_sentinel_t end_cursor() const$/;"	f	struct:ranges::detail::index_view	typeref:typename:unreachable_sentinel_t
end_cursor	include/range/v3/view/facade.hpp	/^        constexpr default_sentinel_t end_cursor() const$/;"	f	struct:ranges::view_facade	typeref:typename:default_sentinel_t
end_cursor	include/range/v3/view/generate.hpp	/^        unreachable_sentinel_t end_cursor() const$/;"	f	struct:ranges::generate_view	typeref:typename:unreachable_sentinel_t
end_cursor	include/range/v3/view/iota.hpp	/^        auto end_cursor() const -> CPP_ret(cursor)( \/\/$/;"	f	struct:ranges::closed_iota_view	typeref:typename:CPP_ret (cursor)(requires same_as<From,To>)
end_cursor	include/range/v3/view/iota.hpp	/^        auto end_cursor() const -> CPP_ret(default_sentinel_t)( \/\/$/;"	f	struct:ranges::closed_iota_view	typeref:typename:CPP_ret (default_sentinel_t)(requires (!same_as<From,To>))
end_cursor	include/range/v3/view/join.hpp	/^        constexpr auto end_cursor()$/;"	f	struct:ranges::join_view	typeref:typename:auto
end_cursor	include/range/v3/view/repeat.hpp	/^        unreachable_sentinel_t end_cursor() const$/;"	f	struct:ranges::repeat_view	typeref:typename:unreachable_sentinel_t
end_cursor	include/range/v3/view/transform.hpp	/^        auto end_cursor() const -> CPP_ret(end_cursor_t<Const>)( \/\/$/;"	f	struct:ranges::iter_transform2_view	typeref:typename:CPP_ret (end_cursor_t<Const>)(requires Const && range<meta::const_if_c<Const,Rng1>> && range<meta::const_if_c<Const,Rng2>> && detail::iter_transform_2_readable<Fun const,meta::const_if_c<Const,Rng1>,meta::const_if_c<Const,Rng2>>)
end_cursor	include/range/v3/view/transform.hpp	/^        end_cursor_t<simple_view<Rng1>() && simple_view<Rng2>()> end_cursor()$/;"	f	struct:ranges::iter_transform2_view	typeref:typename:end_cursor_t<simple_view<Rng1> ()&& simple_view<Rng2> ()>
end_cursor	include/range/v3/view/zip_with.hpp	/^        auto end_cursor() const -> CPP_ret(end_cursor_t<Const>)( \/\/$/;"	f	struct:ranges::iter_zip_with_view	typeref:typename:CPP_ret (end_cursor_t<Const>)(requires Const && and_v<range<Rngs const>...> && views::zippable_with<Fun,meta::if_c<Const,Rngs const>...>)
end_cursor	include/range/v3/view/zip_with.hpp	/^        end_cursor_t<false> end_cursor()$/;"	f	struct:ranges::iter_zip_with_view	typeref:typename:end_cursor_t<false>
end_cursor_	include/range/v3/view/adaptor.hpp	/^        static constexpr adaptor_sentinel_t<D> end_cursor_(D & d) noexcept(noexcept($/;"	f	struct:ranges::view_adaptor	typeref:typename:adaptor_sentinel_t<D>
end_cursor_fn	include/range/v3/view/join.hpp	/^        struct end_cursor_fn$/;"	s	struct:ranges::join_view
end_cursor_impl	include/range/v3/view/cache1.hpp	/^        cursor end_cursor_impl(std::true_type)$/;"	f	struct:ranges::cache1_view	typeref:typename:cursor
end_cursor_impl	include/range/v3/view/cache1.hpp	/^        sentinel end_cursor_impl(std::false_type)$/;"	f	struct:ranges::cache1_view	typeref:typename:sentinel
end_cursor_t	include/range/v3/view/facade.hpp	/^        using end_cursor_t = detail::decay_t<decltype($/;"	t	namespace:ranges::detail
end_cursor_t	include/range/v3/view/transform.hpp	/^        using end_cursor_t = meta::if_c<$/;"	t	struct:ranges::iter_transform2_view
end_cursor_t	include/range/v3/view/zip_with.hpp	/^        using end_cursor_t =$/;"	t	struct:ranges::iter_zip_with_view
end_random_access_	include/range/v3/view/take.hpp	/^        static auto end_random_access_(Take & take, std::true_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
end_random_access_	include/range/v3/view/take.hpp	/^        static auto end_random_access_(detail::ignore_t, std::false_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
end_sized_	include/range/v3/view/take.hpp	/^        static auto end_sized_(Take & take, std::true_type, std::false_type) \/\/ sized$/;"	f	struct:ranges::take_view	typeref:typename:auto
end_sized_	include/range/v3/view/take.hpp	/^        static auto end_sized_(detail::ignore_t, std::false_type,$/;"	f	struct:ranges::take_view	typeref:typename:auto
end_sized_	include/range/v3/view/take.hpp	/^        static auto end_sized_(take_view & take, std::false_type, std::false_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
end_sized_	include/range/v3/view/take.hpp	/^        static auto end_sized_(take_view const & take, std::false_type, std::false_type)$/;"	f	struct:ranges::take_view	typeref:typename:auto
ends_	include/range/v3/view/zip_with.hpp	/^            std::tuple<sentinel_t<meta::const_if_c<Const, Rngs>>...> ends_;$/;"	m	struct:ranges::iter_zip_with_view::sentinel	typeref:typename:std::tuple<sentinel_t<meta::const_if_c<Const,Rngs>>...>
engaged_	include/range/v3/utility/optional.hpp	/^                bool engaged_;$/;"	m	struct:ranges::detail::optional_adl::optional_storage	typeref:typename:bool
engaged_	include/range/v3/utility/semiregular_box.hpp	/^        bool engaged_{false};$/;"	m	struct:ranges::semiregular_box	typeref:typename:bool
engine_	include/range/v3/view/sample.hpp	/^        URNG * engine_;$/;"	m	class:ranges::sample_view	typeref:typename:URNG *
enumerate_fn	include/range/v3/iterator/operations.hpp	/^    struct enumerate_fn : iter_enumerate_fn$/;"	s	namespace:ranges
enumerate_fn	include/range/v3/view/enumerate.hpp	/^        struct enumerate_fn$/;"	s	namespace:ranges::views
epsilon	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t epsilon() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
equal	example/calendar.cpp	/^    auto equal(cursor const& that) const -> CPP_ret(bool)($/;"	f	struct:interleave_view::cursor	typeref:typename:CPP_ret (bool)(requires forward_range<range_value_t<Rngs>>)	file:
equal	example/calendar.cpp	/^    bool equal(default_sentinel_t) const$/;"	f	struct:interleave_view::cursor	typeref:typename:bool	file:
equal	include/range/v3/experimental/utility/generator.hpp	/^                bool equal(default_sentinel_t) const$/;"	f	struct:ranges::experimental::generator::cursor	typeref:typename:bool
equal	include/range/v3/iterator/common_iterator.hpp	/^            bool equal(cpp17_iterator_cursor const & that) const$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:bool
equal	include/range/v3/iterator/move_iterators.hpp	/^            auto equal(move_into_cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:CPP_ret (bool)(requires input_iterator<I>)
equal	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr auto equal(reverse_cursor<J> const & that) const$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:CPP_ret (bool)(requires sentinel_for<J,I>)
equal	include/range/v3/view/adaptor.hpp	/^        auto equal(adaptor_cursor const & that) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:decltype (std::declval<C const &> ().equal_ (that,42))
equal	include/range/v3/view/adaptor.hpp	/^        constexpr auto equal(adaptor_sentinel<S, A> const & that) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:decltype (std::declval<adaptor_cursor const &> ().equal_ (that,42))
equal	include/range/v3/view/any_view.hpp	/^            bool equal(any_input_cursor const &) const noexcept$/;"	f	struct:ranges::detail::any_input_cursor	typeref:typename:bool
equal	include/range/v3/view/any_view.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::detail::any_input_cursor	typeref:typename:bool
equal	include/range/v3/view/cache1.hpp	/^            bool equal(cursor const & that) const$/;"	f	struct:ranges::cache1_view::cursor	typeref:typename:bool
equal	include/range/v3/view/cache1.hpp	/^            bool equal(sentinel const & that) const$/;"	f	struct:ranges::cache1_view::cursor	typeref:typename:bool
equal	include/range/v3/view/cartesian_product.hpp	/^            bool equal(cursor const & that) const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:bool
equal	include/range/v3/view/cartesian_product.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:bool
equal	include/range/v3/view/chunk.hpp	/^                constexpr bool equal(default_sentinel_t) const noexcept$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:bool
equal	include/range/v3/view/chunk.hpp	/^            constexpr bool equal(default_sentinel_t) const$/;"	f	struct:ranges::chunk_view_::outer_cursor	typeref:typename:bool
equal	include/range/v3/view/concat.hpp	/^            auto equal(cursor const & pos) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:CPP_ret (bool)(requires equality_comparable<variant<iterator_t<constify_if<Rngs>>...>>)
equal	include/range/v3/view/concat.hpp	/^            bool equal(sentinel<IsConst> const & pos) const$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:bool
equal	include/range/v3/view/enumerate.hpp	/^                bool equal(cursor const & that) const$/;"	f	struct:ranges::detail::index_view::cursor	typeref:typename:bool
equal	include/range/v3/view/generate_n.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::generate_n_view::cursor	typeref:typename:bool
equal	include/range/v3/view/getlines.hpp	/^            bool equal(cursor that) const$/;"	f	struct:ranges::getlines_view::cursor	typeref:typename:bool
equal	include/range/v3/view/getlines.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::getlines_view::cursor	typeref:typename:bool
equal	include/range/v3/view/group_by.hpp	/^            bool equal(cursor const & that) const$/;"	f	struct:ranges::group_by_view::cursor	typeref:typename:bool
equal	include/range/v3/view/group_by.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::group_by_view::cursor	typeref:typename:bool
equal	include/range/v3/view/intersperse.hpp	/^            constexpr auto equal(iterator_t<CRng> const & it0,$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:CPP_ret (bool)(requires sentinel_for<iterator_t<CRng>,iterator_t<CRng>>)
equal	include/range/v3/view/iota.hpp	/^            auto equal(cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:CPP_ret (bool)(requires equality_comparable<From>)
equal	include/range/v3/view/iota.hpp	/^            auto equal(cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:CPP_ret (bool)(requires equality_comparable<From>)
equal	include/range/v3/view/iota.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:bool
equal	include/range/v3/view/iota.hpp	/^            bool equal(sentinel const & that) const$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:bool
equal	include/range/v3/view/istream.hpp	/^            bool equal(cursor that) const$/;"	f	struct:ranges::istream_view::cursor	typeref:typename:bool
equal	include/range/v3/view/istream.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::istream_view::cursor	typeref:typename:bool
equal	include/range/v3/view/join.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	class:ranges::join_with_view::cursor	typeref:typename:bool
equal	include/range/v3/view/join.hpp	/^            constexpr auto equal(cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::join_view::cursor	typeref:typename:CPP_ret (bool)(requires ref_is_glvalue::value && equality_comparable<iterator_t<COuter>> && equality_comparable<iterator_t<CInner>>)
equal	include/range/v3/view/join.hpp	/^            constexpr bool equal(default_sentinel_t) const$/;"	f	struct:ranges::join_view::cursor	typeref:typename:bool
equal	include/range/v3/view/linear_distribute.hpp	/^            constexpr bool equal(default_sentinel_t) const noexcept$/;"	f	struct:ranges::views::linear_distribute_view	typeref:typename:bool
equal	include/range/v3/view/linear_distribute.hpp	/^            constexpr bool equal(linear_distribute_view const & other) const noexcept$/;"	f	struct:ranges::views::linear_distribute_view	typeref:typename:bool
equal	include/range/v3/view/partial_sum.hpp	/^            constexpr bool equal(default_sentinel_t) const$/;"	f	struct:ranges::partial_sum_view::cursor	typeref:typename:bool
equal	include/range/v3/view/repeat.hpp	/^            bool equal(cursor const & that) const$/;"	f	struct:ranges::repeat_view::cursor	typeref:typename:bool
equal	include/range/v3/view/repeat_n.hpp	/^            bool equal(cursor const & that) const$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:bool
equal	include/range/v3/view/repeat_n.hpp	/^            constexpr bool equal(default_sentinel_t) const$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:bool
equal	include/range/v3/view/sample.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	class:ranges::sample_view::cursor	typeref:typename:bool
equal	include/range/v3/view/set_algorithm.hpp	/^            auto equal(set_difference_cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::detail::set_difference_cursor	typeref:typename:CPP_ret (bool)(requires forward_range<Rng1>)
equal	include/range/v3/view/set_algorithm.hpp	/^            auto equal(set_intersection_cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::detail::set_intersection_cursor	typeref:typename:CPP_ret (bool)(requires forward_range<Rng1>)
equal	include/range/v3/view/set_algorithm.hpp	/^            auto equal(set_symmetric_difference_cursor const & that) const$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:CPP_ret (bool)(requires forward_range<R1> && forward_range<R2>)
equal	include/range/v3/view/set_algorithm.hpp	/^            auto equal(set_union_cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::detail::set_union_cursor	typeref:typename:CPP_ret (bool)(requires forward_range<Rng1> && forward_range<Rng2>)
equal	include/range/v3/view/set_algorithm.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::detail::set_difference_cursor	typeref:typename:bool
equal	include/range/v3/view/set_algorithm.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::detail::set_intersection_cursor	typeref:typename:bool
equal	include/range/v3/view/set_algorithm.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:bool
equal	include/range/v3/view/set_algorithm.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::detail::set_union_cursor	typeref:typename:bool
equal	include/range/v3/view/split_when.hpp	/^            bool equal(cursor const & that) const$/;"	f	struct:ranges::split_when_view::cursor	typeref:typename:bool
equal	include/range/v3/view/split_when.hpp	/^            bool equal(default_sentinel_t) const$/;"	f	struct:ranges::split_when_view::cursor	typeref:typename:bool
equal	include/range/v3/view/transform.hpp	/^            auto equal(cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::iter_transform2_view::cursor	typeref:typename:CPP_ret (bool)(requires forward_range<Rng1> && forward_range<Rng2>)
equal	include/range/v3/view/transform.hpp	/^            bool equal(sentinel<Const> const & s) const$/;"	f	struct:ranges::iter_transform2_view::cursor	typeref:typename:bool
equal	include/range/v3/view/zip_with.hpp	/^            auto equal(cursor const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:CPP_ret (bool)(requires and_v<sentinel_for<iterator_t<meta::const_if_c<Const,Rngs>>,iterator_t<meta::const_if_c<Const,Rngs>>>...>)
equal	include/range/v3/view/zip_with.hpp	/^            bool equal(sentinel<Const> const & s) const$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:bool
equal_	include/range/v3/view/adaptor.hpp	/^        bool equal_(adaptor_cursor const & that, int) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:bool
equal_	include/range/v3/view/adaptor.hpp	/^        bool equal_(adaptor_cursor const & that, long) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:bool
equal_	include/range/v3/view/adaptor.hpp	/^        constexpr bool equal_(adaptor_sentinel<S, A> const & that, int) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:bool
equal_	include/range/v3/view/adaptor.hpp	/^        constexpr bool equal_(adaptor_sentinel<S, A> const & that, long) const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:bool
equal_	include/range/v3/view/cartesian_product.hpp	/^            bool equal_(cursor const & that, meta::size_t<N>) const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:bool
equal_	include/range/v3/view/cartesian_product.hpp	/^            bool equal_(cursor const &, meta::size_t<0>) const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:bool
equal_nocheck	include/range/v3/algorithm/equal.hpp	/^        constexpr bool equal_nocheck(I0 begin0, S0 end0, I1 begin1, S1 end1, C pred,$/;"	f	namespace:ranges::detail	typeref:typename:bool
equal_range_n_fn	include/range/v3/algorithm/aux_/equal_range_n.hpp	/^        struct equal_range_n_fn$/;"	s	namespace:ranges::aux
equal_to	include/meta/meta.hpp	/^        using equal_to = defer<equal_to, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<equal_to,T,U>
equal_to	include/meta/meta.hpp	/^    using equal_to = bool_<T::type::value == U::type::value>;$/;"	t	namespace:meta	typeref:typename:bool_<T::type::value==U::type::value>
equal_to	include/range/v3/functional/comparisons.hpp	/^    struct equal_to$/;"	s	namespace:ranges
equal_to_	include/range/v3/view/zip_with.hpp	/^        struct equal_to_$/;"	s	namespace:ranges::detail
erase	include/range/v3/action/erase.hpp	/^        auto erase(Cont && cont, I first, S last)                            \/\/$/;"	f	namespace:ranges::adl_erase_detail	typeref:typename:CPP_ret (decltype (unwrap_reference (cont).erase (first,last)))(requires lvalue_container_like<Cont> && forward_iterator<I> && sentinel_for<S,I>)
erase_fn	include/range/v3/action/erase.hpp	/^        struct erase_fn$/;"	s	namespace:ranges::adl_erase_detail
except_	include/range/v3/experimental/utility/generator.hpp	/^            std::exception_ptr except_ = nullptr;$/;"	m	struct:ranges::detail::generator_promise	typeref:typename:std::exception_ptr
exchange	include/concepts/swap.hpp	/^    exchange(T &t, U &&u)$/;"	f	namespace:concepts	typeref:typename:CPP_CXX14_CONSTEXPR meta::if_c<std::is_move_constructible<T>::value && std::is_assignable<T &,U>::value,T>
exchange	include/range/v3/utility/box.hpp	/^        constexpr T exchange(T const &) const$/;"	f	struct:ranges::constant	typeref:typename:T
exchange	include/range/v3/view/chunk.hpp	/^            constexpr T exchange(T const &) const$/;"	f	struct:ranges::detail::zero	typeref:typename:T
exclusive_scan_base_fn	include/range/v3/view/exclusive_scan.hpp	/^        struct exclusive_scan_base_fn$/;"	s	namespace:ranges::views
exclusive_scan_fn	include/range/v3/view/exclusive_scan.hpp	/^        struct exclusive_scan_fn : exclusive_scan_base_fn$/;"	s	namespace:ranges::views
exclusive_scan_view	include/range/v3/view/exclusive_scan.hpp	/^        constexpr exclusive_scan_view(Rng rng, T init, Fun fun)$/;"	f	struct:ranges::exclusive_scan_view
exclusive_scan_view	include/range/v3/view/exclusive_scan.hpp	/^    struct exclusive_scan_view : view_adaptor<exclusive_scan_view<Rng, T, Fun>, Rng>$/;"	s	namespace:ranges
exclusive_scan_view_t	include/range/v3/view/exclusive_scan.hpp	/^            using exclusive_scan_view_t = meta::const_if_c<IsConst, exclusive_scan_view>;$/;"	t	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:meta::const_if_c<IsConst,exclusive_scan_view>
experimental	include/range/v3/experimental/utility/generator.hpp	/^    namespace experimental$/;"	n	namespace:ranges
experimental	include/range/v3/experimental/view/shared.hpp	/^    namespace experimental$/;"	n	namespace:ranges
extension	include/meta/meta_fwd.hpp	/^    namespace extension$/;"	n	namespace:meta
extent	include/range/v3/view/span.hpp	/^        static constexpr index_type extent = N;$/;"	m	struct:ranges::span	typeref:typename:index_type
extent	include/range/v3/view/span.hpp	/^    constexpr detail::span_index_t span<T, N>::extent;$/;"	m	class:ranges::span<T, N>	typeref:typename:detail::span_index_t
f	include/lr.hpp	/^  F f;$/;"	m	struct:lr::fmap	typeref:typename:F
facade_iterator_t	include/range/v3/view/facade.hpp	/^        using facade_iterator_t = basic_iterator<begin_cursor_t<Derived>>;$/;"	t	namespace:ranges::detail	typeref:typename:basic_iterator<begin_cursor_t<Derived>>
facade_sentinel_t	include/range/v3/view/facade.hpp	/^        using facade_sentinel_t =$/;"	t	namespace:ranges::detail	typeref:typename:meta::if_c<same_as<begin_cursor_t<Derived>,end_cursor_t<Derived>>,facade_iterator_t<Derived>,end_cursor_t<Derived>>
failed	include/range/v3/iterator/stream_iterators.hpp	/^        bool failed() const noexcept$/;"	f	struct:ranges::ostreambuf_iterator	typeref:typename:bool
failed_	include/range/v3/iterator/stream_iterators.hpp	/^        bool failed_ = false;$/;"	m	struct:ranges::ostreambuf_iterator	typeref:typename:bool
fast_exp	include/range/v3/utility/random.hpp	/^            constexpr auto fast_exp(I x, I power, I result = I{1}) -> CPP_ret(I)( \/\/$/;"	f	namespace:ranges::detail::randutils	typeref:typename:CPP_ret (I)(requires unsigned_integral<I>)
fill_default_	include/range/v3/utility/variant.hpp	/^            void fill_default_(T * p, std::false_type)$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:void
fill_default_	include/range/v3/utility/variant.hpp	/^            void fill_default_(T * p, std::true_type)$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:void
filter_base_fn	include/range/v3/view/filter.hpp	/^        struct filter_base_fn : cpp20_filter_base_fn$/;"	s	namespace:ranges::views
filter_fn	include/range/v3/view/filter.hpp	/^        struct filter_fn : filter_base_fn$/;"	s	namespace:ranges::views
filter_view	include/range/v3/view/filter.hpp	/^            using filter_view = ranges::filter_view<V, Pred>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::filter_view<V,Pred>
filter_view	include/range/v3/view/filter.hpp	/^        constexpr filter_view(Rng rng, Pred pred)$/;"	f	struct:ranges::filter_view
filter_view	include/range/v3/view/filter.hpp	/^    struct filter_view : remove_if_view<Rng, logical_negate<Pred>>$/;"	s	namespace:ranges
final_insertion_sort	include/range/v3/algorithm/sort.hpp	/^        inline void final_insertion_sort(I first, I last, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
final_suspend	include/range/v3/experimental/utility/generator.hpp	/^            std::experimental::suspend_always final_suspend() const noexcept$/;"	f	struct:ranges::detail::generator_promise	typeref:typename:std::experimental::suspend_always
find_end_impl	include/range/v3/algorithm/find_end.hpp	/^        subrange<I1> find_end_impl(I1 begin1, I1 end1, I2 begin2, I2 end2, R pred, P proj,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I1>
find_end_impl	include/range/v3/algorithm/find_end.hpp	/^        subrange<I1> find_end_impl(I1 begin1, S1 end1, I2 begin2, S2 end2, R pred, P proj,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I1>
first	include/range/v3/utility/compressed_pair.hpp	/^        constexpr First & first() &$/;"	f	struct:ranges::compressed_pair	typeref:typename:First &
first	include/range/v3/utility/compressed_pair.hpp	/^        constexpr First && first() &&$/;"	f	struct:ranges::compressed_pair	typeref:typename:First &&
first	include/range/v3/utility/compressed_pair.hpp	/^        constexpr First const & first() const &$/;"	f	struct:ranges::compressed_pair	typeref:typename:First const &
first	include/range/v3/view/sliding.hpp	/^            first,$/;"	e	enum:ranges::sliding_view_detail::cache
first	include/range/v3/view/span.hpp	/^        constexpr span<T, Count> first() const noexcept$/;"	f	struct:ranges::span	typeref:typename:span<T,Count>
first	include/range/v3/view/span.hpp	/^        constexpr span<T> first(index_type cnt) const noexcept$/;"	f	struct:ranges::span	typeref:typename:span<T>
first_	include/range/v3/functional/compose.hpp	/^        First first_;$/;"	m	struct:ranges::composed	typeref:typename:RANGES_NO_UNIQUE_ADDRESS First
first_	include/range/v3/functional/on.hpp	/^        Fn1 first_;$/;"	m	struct:ranges::transformed	typeref:typename:RANGES_NO_UNIQUE_ADDRESS Fn1
first_	include/range/v3/functional/overload.hpp	/^        First first_;$/;"	m	struct:ranges::overloaded	typeref:typename:RANGES_NO_UNIQUE_ADDRESS First
first_	include/range/v3/iterator/stream_iterators.hpp	/^        bool first_;$/;"	m	struct:ranges::ostream_joiner	typeref:typename:bool
first_	include/range/v3/view/group_by.hpp	/^                iterator_t<CRng> first_;$/;"	m	struct:ranges::group_by_view::cursor::pred	typeref:typename:iterator_t<CRng>
first_	include/range/v3/view/split_when.hpp	/^                iterator_t<CRng> first_;$/;"	m	struct:ranges::split_when_view::cursor::search_pred	typeref:typename:iterator_t<CRng>
first_	include/range/v3/view/subrange.hpp	/^        constexpr I & first_() noexcept$/;"	f	struct:ranges::subrange	typeref:typename:I &
first_	include/range/v3/view/subrange.hpp	/^        constexpr const I & first_() const noexcept$/;"	f	struct:ranges::subrange	typeref:typename:const I &
first_type	include/range/v3/utility/compressed_pair.hpp	/^        using first_type = First;$/;"	t	struct:ranges::compressed_pair	typeref:typename:First
flags_	include/range/v3/view/tokenize.hpp	/^        std::regex_constants::match_flag_type flags_;$/;"	m	struct:ranges::tokenize_view	typeref:typename:std::regex_constants::match_flag_type
fmap	include/lr.hpp	/^  fmap(F &&r) : f(std::forward<F>(r)) {}$/;"	f	struct:lr::fmap
fmap	include/lr.hpp	/^template <typename F> struct fmap {$/;"	s	namespace:lr
fn	include/range/v3/iterator/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_iter_move_
fn	include/range/v3/iterator/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_iter_swap_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_begin_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_cbegin_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_cend_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_crbegin_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_crend_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_end_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_rbegin_
fn	include/range/v3/range/access.hpp	/^        struct fn$/;"	s	namespace:ranges::_rend_
fn	include/range/v3/range/conversion.hpp	/^        struct to_container::fn : pipeable_base$/;"	s	class:ranges::detail::to_container
fn	include/range/v3/range/primitives.hpp	/^        struct fn$/;"	s	namespace:ranges::_cdata_
fn	include/range/v3/range/primitives.hpp	/^        struct fn$/;"	s	namespace:ranges::_data_
fn	include/range/v3/range/primitives.hpp	/^        struct fn$/;"	s	namespace:ranges::_empty_
fn	include/range/v3/range/primitives.hpp	/^        struct fn$/;"	s	namespace:ranges::_size_
fn_	include/range/v3/functional/bind_back.hpp	/^                Fn fn_;$/;"	m	struct:ranges::detail::bind_back_fn_::tuple_t	typeref:typename:Fn
fn_	include/range/v3/functional/indirect.hpp	/^        Fn fn_;$/;"	m	struct:ranges::indirected	typeref:typename:RANGES_NO_UNIQUE_ADDRESS Fn
fn_args_	include/range/v3/functional/bind_back.hpp	/^            tuple_t fn_args_;$/;"	m	struct:ranges::detail::bind_back_fn_	typeref:typename:tuple_t
for_each_base_fn	include/range/v3/view/for_each.hpp	/^        struct for_each_base_fn$/;"	s	namespace:ranges::views
for_each_fn	include/range/v3/view/for_each.hpp	/^        struct for_each_fn : for_each_base_fn$/;"	s	namespace:ranges::views
for_each_result	include/range/v3/algorithm/for_each.hpp	/^    using for_each_result = detail::in_fun_result<I, F>;$/;"	t	namespace:ranges	typeref:typename:detail::in_fun_result<I,F>
format_calendar	example/calendar.cpp	/^format_calendar(std::size_t months_per_line)$/;"	f	typeref:typename:auto
format_day	example/calendar.cpp	/^format_day(date d)$/;"	f	typeref:typename:std::string
format_weeks	example/calendar.cpp	/^format_weeks()$/;"	f	typeref:typename:auto
forward	include/range/v3/view/any_view.hpp	/^        forward = 3,          \/\/\/<\\brief satisfies ranges::concepts::forward_range$/;"	e	enum:ranges::category
forward	include/range/v3/view/drop_last.hpp	/^                forward,$/;"	e	enum:ranges::detail::drop_last_view::mode_enum
forward_cursor_tag	include/range/v3/detail/range_access.hpp	/^        using forward_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<forward_cursor_concept,input_cursor_tag>
forward_iterator_tag	include/range/v3/iterator/traits.hpp	/^    using forward_iterator_tag RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:std::forward_iterator_tag
forward_iterator_tag_	include/range/v3/iterator/traits.hpp	/^        using forward_iterator_tag_ =$/;"	t	namespace:ranges::detail	typeref:typename:::concepts::tag<forward_iterator_concept,input_iterator_tag_>
forward_range_tag	include/range/v3/range/concepts.hpp	/^    using forward_range_tag = ::concepts::tag<forward_range_concept, input_range_tag>;$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<forward_range_concept,input_range_tag>
forward_tuple_interface	include/range/v3/detail/adl_get.hpp	/^        struct forward_tuple_interface : TupleLike$/;"	s	namespace:ranges::_tuple_wrapper_
from	include/range/v3/view/interface.hpp	/^            From from;$/;"	m	struct:ranges::detail::slice_bounds	typeref:typename:From
from_	include/range/v3/view/iota.hpp	/^            From from_ = From();$/;"	m	struct:ranges::closed_iota_view::cursor	typeref:typename:From
from_	include/range/v3/view/iota.hpp	/^            From from_;$/;"	m	struct:ranges::iota_view::cursor	typeref:typename:From
from_	include/range/v3/view/iota.hpp	/^        From from_ = From();$/;"	m	struct:ranges::closed_iota_view	typeref:typename:From
from_	include/range/v3/view/iota.hpp	/^        From from_ = From();$/;"	m	struct:ranges::iota_view	typeref:typename:From
from_	include/range/v3/view/linear_distribute.hpp	/^            T from_, to_;$/;"	m	struct:ranges::views::linear_distribute_view	typeref:typename:T
from_	include/range/v3/view/slice.hpp	/^            range_difference_t<Rng> from_, count_;$/;"	m	struct:ranges::detail::slice_view_	typeref:typename:range_difference_t<Rng>
from_end_	include/range/v3/view/interface.hpp	/^            constexpr explicit from_end_(Int dist)$/;"	f	struct:ranges::detail::from_end_
from_end_	include/range/v3/view/interface.hpp	/^        struct from_end_$/;"	s	namespace:ranges::detail
from_end_of_t	include/range/v3/view/interface.hpp	/^        using from_end_of_t = from_end_<range_difference_t<Rng>>;$/;"	t	namespace:ranges::detail	typeref:typename:from_end_<range_difference_t<Rng>>
from_range	include/range/v3/range/conversion.hpp	/^        struct from_range$/;"	s	namespace:ranges::detail
from_range_	include/range/v3/view/all.hpp	/^            static constexpr auto from_range_(T && t, std::false_type, std::false_type,$/;"	f	struct:ranges::views::all_fn	typeref:typename:auto
from_range_	include/range/v3/view/all.hpp	/^            static constexpr auto from_range_(T && t, std::false_type, std::true_type,$/;"	f	struct:ranges::views::all_fn	typeref:typename:auto
from_range_	include/range/v3/view/all.hpp	/^            static constexpr auto from_range_(T && t, std::true_type, detail::ignore_t,$/;"	f	struct:ranges::views::all_fn	typeref:typename:auto
front	include/range/v3/view/interface.hpp	/^        constexpr auto front() -> CPP_ret(range_reference_t<D<True>>)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True>>)(requires True && forward_range<D<True>>)
front	include/range/v3/view/interface.hpp	/^        constexpr auto front() const -> CPP_ret(range_reference_t<D<True> const>)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True> const>)(requires True && forward_range<D<True> const>)
front_fn	include/range/v3/range/operations.hpp	/^    struct front_fn$/;"	s	namespace:ranges
front_insert_iterator	include/range/v3/iterator/insert_iterators.hpp	/^        explicit constexpr front_insert_iterator(Container & x)$/;"	f	struct:ranges::front_insert_iterator
front_insert_iterator	include/range/v3/iterator/insert_iterators.hpp	/^    struct front_insert_iterator$/;"	s	namespace:ranges
front_inserter_fn	include/range/v3/iterator/insert_iterators.hpp	/^    struct front_inserter_fn$/;"	s	namespace:ranges
fun	include/range/v3/algorithm/result_types.hpp	/^            Fun fun;$/;"	m	struct:ranges::detail::in_fun_result	typeref:typename:Fun
fun	include/range/v3/algorithm/result_types.hpp	/^            Fun fun;$/;"	m	struct:ranges::detail::out_fun_result	typeref:typename:Fun
fun_	include/range/v3/detail/variant.hpp	/^            Fun fun_;$/;"	m	struct:ranges::detail::variant_visitor	typeref:typename:Fun
fun_	include/range/v3/utility/scope_exit.hpp	/^        Fun fun_;$/;"	m	struct:ranges::scope_exit	typeref:typename:Fun
fun_	include/range/v3/view/exclusive_scan.hpp	/^        semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::exclusive_scan_view	typeref:typename:semiregular_box_t<Fun>
fun_	include/range/v3/view/group_by.hpp	/^                semiregular_box_ref_or_val_t<Fun, IsConst> fun_;$/;"	m	struct:ranges::group_by_view::cursor::pred	typeref:typename:semiregular_box_ref_or_val_t<Fun,IsConst>
fun_	include/range/v3/view/group_by.hpp	/^            semiregular_box_ref_or_val_t<Fun, IsConst> fun_;$/;"	m	struct:ranges::group_by_view::cursor	typeref:typename:semiregular_box_ref_or_val_t<Fun,IsConst>
fun_	include/range/v3/view/group_by.hpp	/^        semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::group_by_view	typeref:typename:semiregular_box_t<Fun>
fun_	include/range/v3/view/partial_sum.hpp	/^        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::partial_sum_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun>
fun_	include/range/v3/view/split_when.hpp	/^                fun_ref_t fun_;$/;"	m	struct:ranges::split_when_view::cursor::search_pred	typeref:typename:fun_ref_t
fun_	include/range/v3/view/split_when.hpp	/^            fun_ref_t fun_;$/;"	m	struct:ranges::split_when_view::cursor	typeref:typename:fun_ref_t
fun_	include/range/v3/view/split_when.hpp	/^        semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::split_when_view	typeref:typename:semiregular_box_t<Fun>
fun_	include/range/v3/view/transform.hpp	/^            RANGES_NO_UNIQUE_ADDRESS fun_ref_ fun_;$/;"	m	struct:ranges::iter_transform_view::adaptor	typeref:typename:RANGES_NO_UNIQUE_ADDRESS fun_ref_
fun_	include/range/v3/view/transform.hpp	/^            fun_ref_ fun_;$/;"	m	struct:ranges::iter_transform2_view::cursor	typeref:typename:fun_ref_
fun_	include/range/v3/view/transform.hpp	/^        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::iter_transform2_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun>
fun_	include/range/v3/view/transform.hpp	/^        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::iter_transform_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Fun>
fun_	include/range/v3/view/zip_with.hpp	/^            fun_ref_ fun_;$/;"	m	struct:ranges::iter_zip_with_view::cursor	typeref:typename:fun_ref_
fun_	include/range/v3/view/zip_with.hpp	/^        semiregular_box_t<Fun> fun_;$/;"	m	struct:ranges::iter_zip_with_view	typeref:typename:semiregular_box_t<Fun>
fun_ref_	include/range/v3/view/transform.hpp	/^            using fun_ref_ = semiregular_box_ref_or_val_t<Fun, Const>;$/;"	t	struct:ranges::iter_transform2_view::cursor	typeref:typename:semiregular_box_ref_or_val_t<Fun,Const>
fun_ref_	include/range/v3/view/transform.hpp	/^            using fun_ref_ = semiregular_box_ref_or_val_t<Fun, IsConst>;$/;"	t	struct:ranges::iter_transform_view::adaptor	typeref:typename:semiregular_box_ref_or_val_t<Fun,IsConst>
fun_ref_	include/range/v3/view/zip_with.hpp	/^            using fun_ref_ = semiregular_box_ref_or_val_t<Fun, Const>;$/;"	t	struct:ranges::iter_zip_with_view::cursor	typeref:typename:semiregular_box_ref_or_val_t<Fun,Const>
fun_ref_t	include/range/v3/view/split_when.hpp	/^            using fun_ref_t = semiregular_box_ref_or_val_t<Fun, IsConst>;$/;"	t	struct:ranges::split_when_view::cursor	typeref:typename:semiregular_box_ref_or_val_t<Fun,IsConst>
gcd	include/range/v3/algorithm/rotate.hpp	/^        D gcd(D x, D y)$/;"	f	namespace:ranges::detail	typeref:typename:D
gen_	include/range/v3/action/shuffle.hpp	/^                Gen & gen_;$/;"	m	struct:ranges::actions::shuffle_fn::lamduh	typeref:typename:Gen &
gen_	include/range/v3/view/generate.hpp	/^        semiregular_box_t<G> gen_;$/;"	m	struct:ranges::generate_view	typeref:typename:semiregular_box_t<G>
gen_	include/range/v3/view/generate_n.hpp	/^        semiregular_box_t<G> gen_;$/;"	m	struct:ranges::generate_n_view	typeref:typename:semiregular_box_t<G>
generate	include/range/v3/utility/random.hpp	/^                RANGES_INTENDED_MODULAR_ARITHMETIC auto generate(I first,$/;"	f	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:CPP_ret (void)(requires random_access_iterator<I> && sentinel_for<S,I>)
generate_fn	include/range/v3/view/generate.hpp	/^        struct generate_fn$/;"	s	namespace:ranges::views
generate_n_fn	include/range/v3/view/generate_n.hpp	/^        struct generate_n_fn$/;"	s	namespace:ranges::views
generate_n_result	include/range/v3/algorithm/generate_n.hpp	/^    using generate_n_result = detail::out_fun_result<O, F>;$/;"	t	namespace:ranges	typeref:typename:detail::out_fun_result<O,F>
generate_n_view	include/range/v3/view/generate_n.hpp	/^        explicit generate_n_view(G g, std::size_t n)$/;"	f	struct:ranges::generate_n_view
generate_n_view	include/range/v3/view/generate_n.hpp	/^    struct generate_n_view : view_facade<generate_n_view<G>, finite>$/;"	s	namespace:ranges
generate_result	include/range/v3/algorithm/generate.hpp	/^    using generate_result = detail::out_fun_result<O, F>;$/;"	t	namespace:ranges	typeref:typename:detail::out_fun_result<O,F>
generate_view	include/range/v3/view/generate.hpp	/^        explicit generate_view(G g)$/;"	f	struct:ranges::generate_view
generate_view	include/range/v3/view/generate.hpp	/^    struct generate_view : view_facade<generate_view<G>, infinite>$/;"	s	namespace:ranges
generator	include/range/v3/experimental/utility/generator.hpp	/^            generator(promise_type * p)$/;"	f	struct:ranges::experimental::generator
generator	include/range/v3/experimental/utility/generator.hpp	/^        struct generator : view_facade<generator<Reference, Value>>$/;"	s	namespace:ranges::experimental
generator_promise	include/range/v3/experimental/utility/generator.hpp	/^        struct generator_promise : experimental::enable_coroutine_owner$/;"	s	namespace:ranges::detail
generator_size	include/range/v3/experimental/utility/generator.hpp	/^        enum struct generator_size : generator_size_t$/;"	g	namespace:ranges::experimental	typeref:typename:generator_size_t
generator_size_t	include/range/v3/experimental/utility/generator.hpp	/^        using generator_size_t = std::size_t;$/;"	t	namespace:ranges::experimental	typeref:typename:std::size_t
get	include/newtype.hpp	/^  constexpr T const &get() const { return value; }$/;"	f	struct:abo::nt::newtype	typeref:typename:T const &
get	include/nt.hpp	/^  constexpr T &get() { return value_; }$/;"	f	class:nt::NamedType	typeref:typename:T &
get	include/nt.hpp	/^  constexpr std::remove_reference_t<T> const &get() const { return value_; }$/;"	f	class:nt::NamedType	typeref:typename:std::remove_reference_t<T> const &
get	include/range/v3/detail/variant.hpp	/^            constexpr T & get() noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:T &
get	include/range/v3/detail/variant.hpp	/^            constexpr T const & get() const noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:T const &
get	include/range/v3/detail/variant.hpp	/^            get(Variant & var)$/;"	f	namespace:ranges::detail	typeref:typename:meta::_t<std::add_lvalue_reference<meta::at_c<meta::as_list<Variant>,N>>>
get	include/range/v3/detail/variant.hpp	/^            get(Variant && var)$/;"	f	namespace:ranges::detail	typeref:typename:meta::_t<std::add_rvalue_reference<meta::at_c<meta::as_list<Variant>,N>>>
get	include/range/v3/detail/variant.hpp	/^            get(Variant const & var)$/;"	f	namespace:ranges::detail	typeref:typename:meta::_t<std::add_lvalue_reference<meta::at_c<meta::as_list<Variant>,N> const>>
get	include/range/v3/detail/variant.hpp	/^            void get() const noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:void
get	include/range/v3/detail/variant.hpp	/^        constexpr decltype(auto) get() const noexcept$/;"	f	struct:ranges::indexed_element	typeref:typename:decltype (auto)
get	include/range/v3/detail/variant.hpp	/^        void get() const noexcept$/;"	f	struct:ranges::indexed_element	typeref:typename:void
get	include/range/v3/functional/reference_wrapper.hpp	/^            constexpr T & get() const noexcept$/;"	f	struct:ranges::detail::reference_wrapper_	typeref:typename:T &
get	include/range/v3/functional/reference_wrapper.hpp	/^            constexpr T && get() const noexcept$/;"	f	struct:ranges::detail::reference_wrapper_	typeref:typename:T &&
get	include/range/v3/functional/reference_wrapper.hpp	/^        constexpr reference get() const noexcept$/;"	f	struct:ranges::reference_wrapper	typeref:typename:reference
get	include/range/v3/utility/any.hpp	/^            T & get()$/;"	f	struct:ranges::any::impl	typeref:typename:T &
get	include/range/v3/utility/any.hpp	/^            T const & get() const$/;"	f	struct:ranges::any::impl	typeref:typename:T const &
get	include/range/v3/utility/box.hpp	/^        constexpr Element & get() & noexcept$/;"	f	class:ranges::box	typeref:typename:Element &
get	include/range/v3/utility/box.hpp	/^        constexpr Element & get(box<Element, Tag, BC> & b) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:Element &
get	include/range/v3/utility/box.hpp	/^        constexpr Element & get(box<Element, meta::size_t<I>, BC> & b) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:Element &
get	include/range/v3/utility/box.hpp	/^        constexpr Element && get() && noexcept$/;"	f	class:ranges::box	typeref:typename:Element &&
get	include/range/v3/utility/box.hpp	/^        constexpr Element && get(box<Element, Tag, BC> && b) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:Element &&
get	include/range/v3/utility/box.hpp	/^        constexpr Element && get(box<Element, meta::size_t<I>, BC> && b) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:Element &&
get	include/range/v3/utility/box.hpp	/^        constexpr Element const & get($/;"	f	namespace:ranges::_get_	typeref:typename:Element const &
get	include/range/v3/utility/box.hpp	/^        constexpr Element const & get() const & noexcept$/;"	f	class:ranges::box	typeref:typename:Element const &
get	include/range/v3/utility/box.hpp	/^        constexpr Element const & get(box<Element, Tag, BC> const & b) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:Element const &
get	include/range/v3/utility/box.hpp	/^        constexpr Element const && get() const && noexcept$/;"	f	class:ranges::box	typeref:typename:Element const &&
get	include/range/v3/utility/get.hpp	/^        T && get(meta::id_t<T> && value) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:T &&
get	include/range/v3/utility/get.hpp	/^        T const & get(meta::id_t<T> const & value) noexcept$/;"	f	namespace:ranges::_get_	typeref:typename:T const &
get	include/range/v3/utility/semiregular_box.hpp	/^        constexpr T & get() & noexcept$/;"	f	struct:ranges::semiregular_box	typeref:typename:T &
get	include/range/v3/utility/semiregular_box.hpp	/^        constexpr T && get() && noexcept$/;"	f	struct:ranges::semiregular_box	typeref:typename:T &&
get	include/range/v3/utility/semiregular_box.hpp	/^        constexpr T const & get() const & noexcept$/;"	f	struct:ranges::semiregular_box	typeref:typename:T const &
get	include/range/v3/view/adaptor.hpp	/^            Adapt & get()$/;"	f	struct:ranges::adaptor_cursor::basic_adaptor_mixin	typeref:typename:Adapt &
get	include/range/v3/view/adaptor.hpp	/^            const Adapt & get() const$/;"	f	struct:ranges::adaptor_cursor::basic_adaptor_mixin	typeref:typename:const Adapt &
get	include/range/v3/view/adaptor.hpp	/^        Adapt & get()$/;"	f	struct:ranges::base_adaptor_sentinel	typeref:typename:Adapt &
get	include/range/v3/view/adaptor.hpp	/^        Adapt const & get() const$/;"	f	struct:ranges::base_adaptor_sentinel	typeref:typename:Adapt const &
get	include/range/v3/view/any_view.hpp	/^            T & get() const noexcept$/;"	f	struct:ranges::detail::any_ref	typeref:typename:T &
get	include/range/v3/view/any_view.hpp	/^            sentinel_t<Rng> const & get(Rng &) const noexcept$/;"	f	struct:ranges::detail::any_view_sentinel_impl	typeref:typename:sentinel_t<Rng> const &
get	include/range/v3/view/sample.hpp	/^            range_difference_t<Rng> get(Rng & rng, iterator_t<Rng> const & it) const$/;"	f	class:ranges::detail::size_tracker	typeref:typename:range_difference_t<Rng>
get	include/range/v3/view/sliding.hpp	/^            constexpr uncounted_t<Rng> get(iterator_t<Rng> const & it,$/;"	f	struct:ranges::sliding_view_detail::trailing	typeref:typename:uncounted_t<Rng>
get	include/range/v3/view/sliding.hpp	/^            constexpr uncounted_t<Rng> get(iterator_t<Rng> const &,$/;"	f	struct:ranges::sliding_view_detail::trailing	typeref:typename:uncounted_t<Rng>
get	include/range/v3/view/subrange.hpp	/^        constexpr auto get(subrange<I, S, K> const & r) -> CPP_ret(I)( \/\/$/;"	f	namespace:ranges::_subrange_	typeref:typename:CPP_ret (I)(requires (N==0))
get	include/range/v3/view/subrange.hpp	/^        constexpr auto get(subrange<I, S, K> const & r) -> CPP_ret(S)( \/\/$/;"	f	namespace:ranges::_subrange_	typeref:typename:CPP_ret (S)(requires (N==1))
get_begin_	include/range/v3/view/drop.hpp	/^        auto get_begin_(std::true_type, std::true_type) const$/;"	f	struct:ranges::drop_view	typeref:typename:CPP_ret (iterator_t<meta::const_if_c<Const,Rng>>)(requires Const && range<meta::const_if_c<Const,Rng>>)
get_begin_	include/range/v3/view/drop.hpp	/^        iterator_t<Rng> get_begin_(std::false_type, detail::ignore_t)$/;"	f	struct:ranges::drop_view	typeref:typename:iterator_t<Rng>
get_begin_	include/range/v3/view/drop.hpp	/^        iterator_t<Rng> get_begin_(std::true_type, std::false_type)$/;"	f	struct:ranges::drop_view	typeref:typename:iterator_t<Rng>
get_begin_	include/range/v3/view/drop_exactly.hpp	/^        auto get_begin_(std::true_type) const$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:CPP_ret (iterator_t<meta::const_if_c<Const,Rng>>)(requires Const && random_access_range<meta::const_if_c<Const,Rng>>)
get_begin_	include/range/v3/view/drop_exactly.hpp	/^        iterator_t<Rng> get_begin_(std::false_type)$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:iterator_t<Rng>
get_begin_	include/range/v3/view/drop_exactly.hpp	/^        iterator_t<Rng> get_begin_(std::true_type)$/;"	f	struct:ranges::drop_exactly_view	typeref:typename:iterator_t<Rng>
get_begin_	include/range/v3/view/drop_while.hpp	/^        iterator_t<Rng> get_begin_()$/;"	f	struct:ranges::drop_while_view	typeref:typename:iterator_t<Rng>
get_begin_	include/range/v3/view/slice.hpp	/^            iterator_t<Rng> get_begin_()$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:iterator_t<Rng>
get_categories	include/range/v3/view/any_view.hpp	/^    constexpr category get_categories() noexcept$/;"	f	namespace:ranges	typeref:typename:category
get_cursor_fn	include/range/v3/iterator/basic_iterator.hpp	/^    struct get_cursor_fn$/;"	s
get_datum_fn	include/range/v3/detail/variant.hpp	/^        struct get_datum_fn$/;"	s	namespace:ranges::detail
get_end	include/range/v3/view/drop_last.hpp	/^            auto get_end(Rng & rng, range_difference_t<Rng> n, int)$/;"	f	namespace:ranges::detail::drop_last_view	typeref:typename:CPP_ret (iterator_t<Rng>)(requires random_access_range<Rng> && sized_range<Rng>)
get_end	include/range/v3/view/drop_last.hpp	/^            auto get_end(Rng & rng, range_difference_t<Rng> n, long)$/;"	f	namespace:ranges::detail::drop_last_view	typeref:typename:CPP_ret (iterator_t<Rng>)(requires bidirectional_range<Rng> && common_range<Rng>)
get_end_	include/range/v3/view/cycle.hpp	/^            iterator get_end_(std::false_type, meta::bool_<CanBeEmpty> = {}) const$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:iterator
get_end_	include/range/v3/view/cycle.hpp	/^            iterator get_end_(std::true_type, bool = false) const$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:iterator
get_entropy	include/range/v3/utility/random.hpp	/^            inline std::array<std::uint32_t, 8> get_entropy()$/;"	f	namespace:ranges::detail::randutils	typeref:typename:std::array<std::uint32_t,8>
get_first	include/range/v3/view/map.hpp	/^        struct get_first$/;"	s	namespace:ranges::detail
get_first	include/range/v3/view/sliding.hpp	/^        iterator_t<Rng> get_first()$/;"	f	struct:ranges::sliding_view	typeref:typename:iterator_t<Rng>
get_first_second_helper	include/range/v3/view/map.hpp	/^        constexpr T & get_first_second_helper(T & t, std::true_type) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:T &
get_first_second_helper	include/range/v3/view/map.hpp	/^        constexpr auto get_first_second_helper(T & t, std::false_type) noexcept($/;"	f	namespace:ranges::detail	typeref:typename:auto
get_first_second_tag	include/range/v3/view/map.hpp	/^        using get_first_second_tag = meta::bool_<std::is_lvalue_reference<P>::value ||$/;"	t	namespace:ranges::detail	typeref:typename:meta::bool_<std::is_lvalue_reference<P>::value||std::is_lvalue_reference<E>::value>
get_fn	include/range/v3/detail/variant.hpp	/^        struct get_fn$/;"	s	namespace:ranges::detail
get_inner_	include/range/v3/view/join.hpp	/^            constexpr views::all_t<Inner> & get_inner_(ignore_t) noexcept$/;"	f	struct:ranges::detail::store_inner_	typeref:typename:views::all_t<Inner> &
get_inner_	include/range/v3/view/join.hpp	/^            static constexpr decltype(auto) get_inner_(OuterIt && outer_it)$/;"	f	struct:ranges::detail::pass_thru_inner_	typeref:typename:decltype (auto)
get_last	include/range/v3/view/sliding.hpp	/^        iterator_t<Rng> get_last()$/;"	f	struct:ranges::sliding_view	typeref:typename:iterator_t<Rng>
get_mode	include/range/v3/view/drop_last.hpp	/^            constexpr mode_enum get_mode() noexcept$/;"	f	namespace:ranges::detail::drop_last_view	typeref:typename:mode_enum
get_offset	include/range/v3/view/stride.hpp	/^            constexpr range_difference_t<Rng> get_offset(bool = true) const noexcept$/;"	f	struct:ranges::detail::stride_view_base_	typeref:typename:range_difference_t<Rng>
get_offset	include/range/v3/view/stride.hpp	/^            constexpr range_difference_t<Rng> get_offset(bool check = true) const noexcept$/;"	f	struct:ranges::detail::stride_view_base_	typeref:typename:range_difference_t<Rng>
get_random_engine	include/range/v3/utility/random.hpp	/^        default_random_engine & get_random_engine()$/;"	f	namespace:ranges::detail	typeref:typename:default_random_engine &
get_return_object	include/range/v3/experimental/utility/generator.hpp	/^            generator_promise * get_return_object() noexcept$/;"	f	struct:ranges::detail::generator_promise	typeref:typename:generator_promise *
get_return_object	include/range/v3/experimental/utility/generator.hpp	/^            sized_generator_promise * get_return_object() noexcept$/;"	f	struct:ranges::detail::sized_generator_promise	typeref:typename:sized_generator_promise *
get_second	include/range/v3/view/map.hpp	/^        struct get_second$/;"	s	namespace:ranges::detail
get_size	include/range/v3/view/drop_last.hpp	/^            range_size_t<Rng> get_size(Rng & rng, range_difference_t<Rng> n_)$/;"	f	namespace:ranges::detail::drop_last_view	typeref:typename:range_size_t<Rng>
get_size_	include/range/v3/view/subrange.hpp	/^        constexpr auto get_size_() const -> CPP_ret(size_type)( \/\/$/;"	f	struct:ranges::subrange	typeref:typename:CPP_ret (size_type)(requires sized_sentinel_for<S,I>)
get_size_	include/range/v3/view/subrange.hpp	/^        constexpr auto get_size_() const noexcept -> CPP_ret(size_type)( \/\/$/;"	f	struct:ranges::subrange	typeref:typename:CPP_member auto
get_temporary_buffer	include/range/v3/utility/memory.hpp	/^        std::pair<T *, std::ptrdiff_t> get_temporary_buffer(D count) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:std::pair<T *,std::ptrdiff_t>
get_temporary_buffer_impl	include/range/v3/utility/memory.hpp	/^        std::pair<T *, std::ptrdiff_t> get_temporary_buffer_impl($/;"	f	namespace:ranges::detail	typeref:typename:std::pair<T *,std::ptrdiff_t>
getlines_fn	include/range/v3/view/getlines.hpp	/^    struct getlines_fn$/;"	s	namespace:ranges
getlines_range	include/range/v3/view/getlines.hpp	/^    using getlines_range RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:getlines_view
getlines_view	include/range/v3/view/getlines.hpp	/^        getlines_view(std::istream & sin, char delim = '\\n')$/;"	f	struct:ranges::getlines_view
getlines_view	include/range/v3/view/getlines.hpp	/^    struct getlines_view : view_facade<getlines_view, unknown>$/;"	s	namespace:ranges
git	include/git.hpp	/^namespace git {$/;"	n
git	test/git.cpp	/^namespace git {$/;"	n	file:
greater	include/meta/meta.hpp	/^        using greater = defer<greater, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<greater,T,U>
greater	include/meta/meta.hpp	/^    using greater = bool_<(T::type::value > U::type::value)>;$/;"	t	namespace:meta
greater	include/range/v3/functional/comparisons.hpp	/^    struct greater$/;"	s	namespace:ranges
greater_equal	include/meta/meta.hpp	/^        using greater_equal = defer<greater_equal, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<greater_equal,T,U>
greater_equal	include/meta/meta.hpp	/^    using greater_equal = bool_<(T::type::value >= U::type::value)>;$/;"	t	namespace:meta
greater_equal	include/range/v3/functional/comparisons.hpp	/^    struct greater_equal$/;"	s	namespace:ranges
gregorian	example/calendar.cpp	/^    namespace gregorian$/;"	n	namespace:boost	file:
group_by_base_fn	include/range/v3/view/group_by.hpp	/^        struct group_by_base_fn$/;"	s	namespace:ranges::views
group_by_fn	include/range/v3/view/group_by.hpp	/^        struct group_by_fn : group_by_base_fn$/;"	s	namespace:ranges::views
group_by_view	include/range/v3/view/group_by.hpp	/^        constexpr group_by_view(Rng rng, Fun fun)$/;"	f	struct:ranges::group_by_view
group_by_view	include/range/v3/view/group_by.hpp	/^    struct group_by_view$/;"	s	namespace:ranges
guard	include/range/v3/utility/scope_exit.hpp	/^        using guard = scope_exit<ref_t>;$/;"	t	struct:ranges::scope_exit	typeref:typename:scope_exit<ref_t>
handle	include/range/v3/experimental/utility/generator.hpp	/^            base_t handle() const noexcept$/;"	f	struct:ranges::experimental::coroutine_owner	typeref:typename:base_t
handle	include/range/v3/experimental/utility/generator.hpp	/^            using handle = std::experimental::coroutine_handle<promise_type>;$/;"	t	struct:ranges::experimental::generator	typeref:typename:std::experimental::coroutine_handle<promise_type>
handle	include/range/v3/experimental/utility/generator.hpp	/^            using handle = std::experimental::coroutine_handle<promise_type>;$/;"	t	struct:ranges::experimental::sized_generator	typeref:typename:std::experimental::coroutine_handle<promise_type>
has_denorm	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool has_denorm = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
has_denorm	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_denorm;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
has_denorm_loss	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool has_denorm_loss = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
has_denorm_loss	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_denorm_loss;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
has_fixed_size_	include/range/v3/view/interface.hpp	/^        constexpr bool has_fixed_size_(cardinality c) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
has_infinity	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool has_infinity = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
has_infinity	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_infinity;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
has_nothrow_iter_move_v	include/range/v3/iterator/traits.hpp	/^        RANGES_INLINE_VAR constexpr bool has_nothrow_iter_move_v =$/;"	v	namespace:ranges::detail	typeref:typename:RANGES_INLINE_VAR bool
has_quiet_NaN	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool has_quiet_NaN = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
has_quiet_NaN	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_quiet_NaN;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
has_signaling_NaN	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool has_signaling_NaN = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
has_signaling_NaN	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::has_signaling_NaN;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
has_value	include/range/v3/utility/optional.hpp	/^                constexpr bool has_value() const noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:bool
head	include/range/v3/detail/variant.hpp	/^                    head_t head;$/;"	m	union:ranges::detail::variant_data_::type::__anon4da570f9020a	typeref:typename:head_t
head	include/range/v3/detail/variant.hpp	/^                    head_t head;$/;"	m	union:ranges::detail::variant_data_::type::__anon4da570f9030a	typeref:typename:head_t
head_t	include/range/v3/detail/variant.hpp	/^                using head_t = T;$/;"	t	struct:ranges::detail::variant_data_::type	typeref:typename:T
here	include/range/v3/view/split.hpp	/^        struct here$/;"	s	namespace:ranges::detail
here_or_there_	include/range/v3/view/split.hpp	/^        struct here_or_there_$/;"	s	namespace:ranges::detail
here_or_there_	include/range/v3/view/split.hpp	/^        struct here_or_there_<true>$/;"	s	namespace:ranges::detail
hook	include/range/v3/action/action.hpp	/^            struct hook$/;"	s	namespace:ranges::actions::action_closure_base_detail
hook	include/range/v3/view/view.hpp	/^            struct hook$/;"	s	namespace:ranges::views::view_closure_base_detail
i_	include/range/v3/utility/memory.hpp	/^        mutable I * i_ = nullptr;$/;"	m	struct:ranges::iterator_wrapper	typeref:typename:I *
i_	include/range/v3/view/split.hpp	/^                split_outer_iterator i_ = split_outer_iterator();$/;"	m	struct:ranges::detail::split_outer_iterator::value_type	typeref:typename:split_outer_iterator
i_	include/range/v3/view/split.hpp	/^            Outer i_ = Outer();$/;"	m	struct:ranges::detail::split_inner_iterator	typeref:typename:Outer
id	include/meta/meta.hpp	/^        using id = defer<id, T>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<id,T>
id	include/meta/meta.hpp	/^    struct id$/;"	s	namespace:meta
id_t	include/meta/meta.hpp	/^    using id_t = _t<id<T>>;$/;"	t	namespace:meta	typeref:typename:_t<id<T>>
ident	include/range/v3/functional/identity.hpp	/^    using ident RANGES_DEPRECATED("Replace uses of ranges::ident with ranges::identity") =$/;"	t	namespace:ranges	typeref:typename:identity
identity	include/range/v3/functional/identity.hpp	/^    struct identity$/;"	s	namespace:ranges
identity_adaptor	include/range/v3/view/all.hpp	/^        constexpr explicit identity_adaptor(Rng && rng)$/;"	f	struct:ranges::identity_adaptor
identity_adaptor	include/range/v3/view/all.hpp	/^        constexpr explicit identity_adaptor(Rng const & rng)$/;"	f	struct:ranges::identity_adaptor
identity_adaptor	include/range/v3/view/all.hpp	/^    struct identity_adaptor : Rng$/;"	s	namespace:ranges
if_	include/concepts/type_traits.hpp	/^        struct if_$/;"	s	namespace:concepts::detail
if_	include/concepts/type_traits.hpp	/^        struct if_<true>$/;"	s	namespace:concepts::detail
if_else_	include/concepts/type_traits.hpp	/^        struct if_else_$/;"	s	namespace:concepts::detail
if_else_	include/concepts/type_traits.hpp	/^        struct if_else_<true>$/;"	s	namespace:concepts::detail
if_else_t	include/concepts/type_traits.hpp	/^        using if_else_t = meta::invoke<if_else_<B>, T, U>;$/;"	t	namespace:concepts::detail	typeref:typename:meta::invoke<if_else_<B>,T,U>
if_t	include/concepts/type_traits.hpp	/^        using if_t = meta::invoke<if_<B>, T>;$/;"	t	namespace:concepts::detail	typeref:typename:meta::invoke<if_<B>,T>
if_then	include/std/detail/associated_types.hpp	/^        struct if_then$/;"	s	namespace:ranges::detail
if_then	include/std/detail/associated_types.hpp	/^        struct if_then<true>$/;"	s	namespace:ranges::detail
if_then_t	include/std/detail/associated_types.hpp	/^        using if_then_t = std::conditional_t<B, T, U>;$/;"	t	namespace:ranges::detail	typeref:typename:std::conditional_t<B,T,U>
if_then_t	include/std/detail/associated_types.hpp	/^        using if_then_t = typename if_then<B>::template apply<T, U>;$/;"	t	namespace:ranges::detail	typeref:typename:if_then<B>::template apply<T,U>
ignore_unused	include/concepts/swap.hpp	/^            static constexpr int ignore_unused(Ts &&...)$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:int
impl	include/concepts/concepts.hpp	/^            static constexpr bool impl(std::false_type) noexcept$/;"	f	struct:concepts::detail::and_	typeref:typename:bool
impl	include/concepts/concepts.hpp	/^            static constexpr bool impl(std::true_type) noexcept$/;"	f	struct:concepts::detail::and_	typeref:typename:bool
impl	include/concepts/swap.hpp	/^            static void impl(T &&left, U &&right, meta::index_sequence<Is...>)$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:CPP_CXX14_CONSTEXPR void
impl	include/range/v3/action/action.hpp	/^            struct impl$/;"	s	struct:ranges::actions::action_access_
impl	include/range/v3/algorithm/inplace_merge.hpp	/^            static void impl(I first, I middle, I last, iter_difference_t<I> len1,$/;"	f	struct:ranges::detail::merge_adaptive_fn	typeref:typename:void
impl	include/range/v3/functional/pipeable.hpp	/^        struct impl : Pipeable$/;"	s	struct:ranges::pipeable_access
impl	include/range/v3/range/access.hpp	/^            using impl = impl_<has_member_begin<R>>;$/;"	t	struct:ranges::_begin_::fn	typeref:typename:impl_<has_member_begin<R>>
impl	include/range/v3/range/access.hpp	/^            using impl = impl_<has_member_end<R>>;$/;"	t	struct:ranges::_end_::fn	typeref:typename:impl_<has_member_end<R>>
impl	include/range/v3/range/access.hpp	/^            using impl = impl_<has_member_rend<R> ? 0 : has_non_member_rend<R> ? 1 : 2>;$/;"	t	struct:ranges::_rend_::fn	typeref:typename:impl_<has_member_rend<R>?0:has_non_member_rend<R>?1:2>
impl	include/range/v3/range/access.hpp	/^            using impl =$/;"	t	struct:ranges::_rbegin_::fn	typeref:typename:impl_<has_member_rbegin<R>?0:has_non_member_rbegin<R>?1:2>
impl	include/range/v3/range/conversion.hpp	/^            static Cont impl(Rng && rng, std::false_type)$/;"	f	struct:ranges::detail::to_container::fn	typeref:typename:Cont
impl	include/range/v3/range/conversion.hpp	/^            static auto impl(Rng && rng, std::true_type)$/;"	f	struct:ranges::detail::to_container::fn	typeref:typename:auto
impl	include/range/v3/utility/any.hpp	/^            impl(T o)$/;"	f	struct:ranges::any::impl
impl	include/range/v3/utility/any.hpp	/^        struct impl final : interface$/;"	s	struct:ranges::any
impl	include/range/v3/utility/tuple_algorithm.hpp	/^        static constexpr Val impl(Tup &&, Val val, Fun &)$/;"	f	struct:ranges::tuple_foldl_fn	typeref:typename:Val
impl	include/range/v3/utility/tuple_algorithm.hpp	/^        static constexpr void impl(Tup && tup, Fun & fun, meta::index_sequence<Is...>)$/;"	f	struct:ranges::tuple_for_each_fn	typeref:typename:void
impl	include/range/v3/view/view.hpp	/^            struct impl$/;"	s	struct:ranges::views::view_access_
impl_	include/range/v3/range/access.hpp	/^            struct impl_$/;"	s	struct:ranges::_begin_::fn
impl_	include/range/v3/range/access.hpp	/^            struct impl_$/;"	s	struct:ranges::_end_::fn
impl_	include/range/v3/range/access.hpp	/^            struct impl_$/;"	s	struct:ranges::_rbegin_::fn
impl_	include/range/v3/range/access.hpp	/^            struct impl_$/;"	s	struct:ranges::_rend_::fn
impl_	include/range/v3/range/access.hpp	/^        struct fn::impl_<1>$/;"	s	class:ranges::_rbegin_::fn
impl_	include/range/v3/range/access.hpp	/^        struct fn::impl_<1>$/;"	s	class:ranges::_rend_::fn
impl_	include/range/v3/range/access.hpp	/^        struct fn::impl_<2>$/;"	s	class:ranges::_rbegin_::fn
impl_	include/range/v3/range/access.hpp	/^        struct fn::impl_<2>$/;"	s	class:ranges::_rend_::fn
impl_	include/range/v3/range/access.hpp	/^        struct fn::impl_<false>$/;"	s	class:ranges::_begin_::fn
impl_	include/range/v3/range/access.hpp	/^        struct fn::impl_<false>$/;"	s	class:ranges::_end_::fn
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R & r, detail::priority_tag<2>) noexcept($/;"	f	struct:ranges::_data_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, ...)$/;"	f	struct:ranges::_size_::fn	typeref:typename:CPP_ret (detail::iter_size_t<_begin_::_t<R>>)(requires forward_iterator<_begin_::_t<R>> && sized_sentinel_for<_end_::_t<R>,_begin_::_t<R>>)
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, detail::priority_tag<0>) noexcept($/;"	f	struct:ranges::_data_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, detail::priority_tag<0>) noexcept($/;"	f	struct:ranges::_empty_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, detail::priority_tag<1>) noexcept($/;"	f	struct:ranges::_data_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, detail::priority_tag<1>) noexcept($/;"	f	struct:ranges::_empty_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, detail::priority_tag<2>) noexcept($/;"	f	struct:ranges::_empty_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, int) noexcept(noexcept(((R &&) r).size()))$/;"	f	struct:ranges::_size_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr auto impl_(R && r, long) noexcept(noexcept(size((R &&) r)))$/;"	f	struct:ranges::_size_::fn	typeref:typename:auto
impl_	include/range/v3/range/primitives.hpp	/^            static constexpr std::size_t impl_(R (&)[N], int) noexcept$/;"	f	struct:ranges::_size_::fn	typeref:typename:std::size_t
impl_	include/range/v3/view/drop.hpp	/^            static auto impl_(Rng && rng, range_difference_t<Rng> n, input_range_tag)$/;"	f	struct:ranges::views::drop_base_fn	typeref:typename:drop_view<all_t<Rng>>
impl_	include/range/v3/view/drop.hpp	/^            static auto impl_(Rng && rng, range_difference_t<Rng> n,$/;"	f	struct:ranges::views::drop_base_fn	typeref:typename:CPP_ret (subrange<iterator_t<Rng>,sentinel_t<Rng>>)(requires forwarding_range_<Rng> && sized_range<Rng>)
impl_	include/range/v3/view/drop_exactly.hpp	/^            static auto impl_(Rng && rng, range_difference_t<Rng> n, input_range_tag)$/;"	f	struct:ranges::views::drop_exactly_base_fn	typeref:typename:drop_exactly_view<all_t<Rng>>
impl_	include/range/v3/view/drop_exactly.hpp	/^            static auto impl_(Rng && rng, range_difference_t<Rng> n,$/;"	f	struct:ranges::views::drop_exactly_base_fn	typeref:typename:CPP_ret (subrange<iterator_t<Rng>,sentinel_t<Rng>>)(requires forwarding_range_<Rng>)
impl_	include/range/v3/view/slice.hpp	/^            static auto impl_(Rng && rng, range_difference_t<Rng> from,$/;"	f	struct:ranges::views::slice_base_fn	typeref:typename:CPP_ret (subrange<iterator_t<Rng>>)(requires forwarding_range_<Rng>)
impl_	include/range/v3/view/slice.hpp	/^            static constexpr slice_view<all_t<Rng>> impl_(Rng && rng,$/;"	f	struct:ranges::views::slice_base_fn	typeref:typename:slice_view<all_t<Rng>>
impl_	include/range/v3/view/take_exactly.hpp	/^            static constexpr auto impl_(Rng && rng, range_difference_t<Rng> n,$/;"	f	struct:ranges::views::take_exactly_base_fn	typeref:typename:CPP_ret (subrange<iterator_t<Rng>>)(requires forwarding_range_<Rng>)
impl_	include/range/v3/view/take_exactly.hpp	/^            static constexpr take_exactly_view<all_t<Rng>> impl_($/;"	f	struct:ranges::views::take_exactly_base_fn	typeref:typename:take_exactly_view<all_t<Rng>>
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr auto impl_i(I first, S end_, sentinel_tag)$/;"	f	struct:ranges::iter_enumerate_fn	typeref:typename:CPP_ret (std::pair<iter_difference_t<I>,I>)(requires sized_sentinel_for<I,I>)
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr auto impl_i(I first, S last, sentinel_tag)$/;"	f	struct:ranges::iter_enumerate_fn	typeref:typename:CPP_ret (std::pair<iter_difference_t<I>,I>)(requires (!sized_sentinel_for<I,I>))
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr int impl_i(I first, S last, iter_difference_t<I> n, sentinel_tag)$/;"	f	struct:ranges::iter_distance_compare_fn	typeref:typename:int
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr int impl_i(I first, S last, iter_difference_t<I> n,$/;"	f	struct:ranges::iter_distance_compare_fn	typeref:typename:int
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr iter_difference_t<I> impl_i(I first, S last, sentinel_tag)$/;"	f	struct:ranges::iter_distance_fn	typeref:typename:iter_difference_t<I>
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr iter_difference_t<I> impl_i(I first, S last, sized_sentinel_tag)$/;"	f	struct:ranges::iter_distance_fn	typeref:typename:iter_difference_t<I>
impl_i	include/range/v3/iterator/operations.hpp	/^        static constexpr std::pair<iter_difference_t<I>, I> impl_i(I first, S last,$/;"	f	struct:ranges::iter_enumerate_fn	typeref:typename:std::pair<iter_difference_t<I>,I>
impl_r	include/range/v3/iterator/operations.hpp	/^        static constexpr range_difference_t<Rng> impl_r(Rng & rng, sized_range_tag)$/;"	f	struct:ranges::distance_fn	typeref:typename:range_difference_t<Rng>
impl_r	include/range/v3/iterator/operations.hpp	/^        static int impl_r(Rng & rng, range_difference_t<Rng> n, range_tag)$/;"	f	struct:ranges::distance_compare_fn	typeref:typename:int
impl_r	include/range/v3/iterator/operations.hpp	/^        static int impl_r(Rng & rng, range_difference_t<Rng> n, sized_range_tag)$/;"	f	struct:ranges::distance_compare_fn	typeref:typename:int
impl_r	include/range/v3/iterator/operations.hpp	/^        static range_difference_t<Rng> impl_r(Rng & rng, range_tag)$/;"	f	struct:ranges::distance_fn	typeref:typename:range_difference_t<Rng>
impl_r	include/range/v3/iterator/operations.hpp	/^        static std::pair<range_difference_t<Rng>, iterator_t<Rng>> impl_r($/;"	f	struct:ranges::enumerate_fn	typeref:typename:std::pair<range_difference_t<Rng>,iterator_t<Rng>>
impl_r	include/range/v3/iterator/operations.hpp	/^        static std::pair<range_difference_t<Rng>, iterator_t<Rng>> impl_r(Rng & rng,$/;"	f	struct:ranges::enumerate_fn	typeref:typename:std::pair<range_difference_t<Rng>,iterator_t<Rng>>
impl_v	include/range/v3/range/access.hpp	/^            static constexpr impl<R> impl_v{};$/;"	m	struct:ranges::_begin_::fn	typeref:typename:impl<R>
impl_v	include/range/v3/range/access.hpp	/^            static constexpr impl<R> impl_v{};$/;"	m	struct:ranges::_end_::fn	typeref:typename:impl<R>
in	include/range/v3/algorithm/result_types.hpp	/^            I in;$/;"	m	struct:ranges::detail::in_fun_result	typeref:typename:I
in	include/range/v3/algorithm/result_types.hpp	/^            I in;$/;"	m	struct:ranges::detail::in_out1_out2_result	typeref:typename:I
in	include/range/v3/algorithm/result_types.hpp	/^            I in;$/;"	m	struct:ranges::detail::in_out_result	typeref:typename:I
in1	include/range/v3/algorithm/result_types.hpp	/^            I1 in1;$/;"	m	struct:ranges::detail::in1_in2_out_result	typeref:typename:I1
in1	include/range/v3/algorithm/result_types.hpp	/^            I1 in1;$/;"	m	struct:ranges::detail::in1_in2_result	typeref:typename:I1
in1	include/range/v3/algorithm/result_types.hpp	/^            I1 in1;$/;"	m	struct:ranges::detail::in1_out_result	typeref:typename:I1
in1_in2_out_result	include/range/v3/algorithm/result_types.hpp	/^        struct in1_in2_out_result$/;"	s	namespace:ranges::detail
in1_in2_result	include/range/v3/algorithm/result_types.hpp	/^        struct in1_in2_result$/;"	s	namespace:ranges::detail
in1_out_result	include/range/v3/algorithm/result_types.hpp	/^        struct in1_out_result$/;"	s	namespace:ranges::detail
in2	include/range/v3/algorithm/result_types.hpp	/^            I2 in2;$/;"	m	struct:ranges::detail::in1_in2_out_result	typeref:typename:I2
in2	include/range/v3/algorithm/result_types.hpp	/^            I2 in2;$/;"	m	struct:ranges::detail::in1_in2_result	typeref:typename:I2
in_fun_result	include/range/v3/algorithm/result_types.hpp	/^        struct in_fun_result$/;"	s	namespace:ranges::detail
in_out1_out2_result	include/range/v3/algorithm/result_types.hpp	/^        struct in_out1_out2_result$/;"	s	namespace:ranges::detail
in_out_result	include/range/v3/algorithm/result_types.hpp	/^        struct in_out_result$/;"	s	namespace:ranges::detail
in_place_t	include/range/v3/utility/in_place.hpp	/^    struct in_place_t$/;"	s	namespace:ranges
inc	include/meta/meta.hpp	/^        using inc = defer<inc, T>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<inc,T>
inc	include/meta/meta.hpp	/^    using inc = std::integral_constant<decltype(T::type::value + 1), T::type::value + 1>;$/;"	t	namespace:meta
inc_	include/range/v3/view/zip_with.hpp	/^        struct inc_$/;"	s	namespace:ranges::detail
incrementable_traits	example/calendar.cpp	/^    struct incrementable_traits<date>$/;"	s	namespace:ranges	file:
incrementable_traits	include/range/v3/iterator/traits.hpp	/^        using incrementable_traits = ranges::incrementable_traits<T>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::incrementable_traits<T>
incrementable_traits	include/std/detail/associated_types.hpp	/^    struct incrementable_traits : detail::incrementable_traits_1_<T>$/;"	s	namespace:ranges
incrementable_traits	include/std/detail/associated_types.hpp	/^    struct incrementable_traits<T const> : incrementable_traits<T>$/;"	s	namespace:ranges
incrementable_traits_1_	include/std/detail/associated_types.hpp	/^        struct incrementable_traits_1_ : incrementable_traits_2_<T>$/;"	s	namespace:ranges::detail
incrementable_traits_1_	include/std/detail/associated_types.hpp	/^        struct incrementable_traits_1_<T *>$/;"	s	namespace:ranges::detail
incrementable_traits_2_	include/std/detail/associated_types.hpp	/^        struct incrementable_traits_2_$/;"	s	namespace:ranges::detail
incremented_	include/range/v3/view/split.hpp	/^            bool incremented_ = false;$/;"	m	struct:ranges::detail::split_inner_iterator	typeref:typename:bool
index	include/range/v3/detail/variant.hpp	/^        constexpr std::size_t index() const noexcept$/;"	f	struct:ranges::variant	typeref:typename:std::size_t
index_	include/range/v3/detail/variant.hpp	/^        std::size_t index_;$/;"	m	struct:ranges::variant	typeref:typename:std::size_t
index_	include/range/v3/view/enumerate.hpp	/^                Size index_{0};$/;"	m	struct:ranges::detail::index_view::cursor	typeref:typename:Size
index_fn	include/range/v3/range/operations.hpp	/^    struct index_fn$/;"	s	namespace:ranges
index_sequence	include/meta/meta.hpp	/^    using index_sequence = integer_sequence<std::size_t, Is...>;$/;"	t	namespace:meta	typeref:typename:integer_sequence<std::size_t,Is...>
index_type	include/range/v3/view/span.hpp	/^        using index_type = detail::span_index_t;$/;"	t	struct:ranges::span	typeref:typename:detail::span_index_t
index_view	include/range/v3/view/enumerate.hpp	/^        struct index_view : view_facade<index_view<Size, Diff>, infinite>$/;"	s	namespace:ranges::detail
indexed_datum	include/range/v3/detail/variant.hpp	/^            constexpr indexed_datum(reference_wrapper<T &&> ref) noexcept$/;"	f	struct:ranges::detail::indexed_datum
indexed_datum	include/range/v3/detail/variant.hpp	/^            constexpr indexed_datum(reference_wrapper<T &> ref) noexcept$/;"	f	struct:ranges::detail::indexed_datum
indexed_datum	include/range/v3/detail/variant.hpp	/^        struct indexed_datum$/;"	s	namespace:ranges::detail
indexed_datum	include/range/v3/detail/variant.hpp	/^        struct indexed_datum<T &&, Index>$/;"	s	namespace:ranges::detail
indexed_datum	include/range/v3/detail/variant.hpp	/^        struct indexed_datum<T &, Index>$/;"	s	namespace:ranges::detail
indexed_datum	include/range/v3/detail/variant.hpp	/^        struct indexed_datum<void, Index>$/;"	s	namespace:ranges::detail
indexed_datum	include/range/v3/utility/variant.hpp	/^        struct indexed_datum<T[N], Index>$/;"	s	namespace:ranges::detail
indexed_element	include/range/v3/detail/variant.hpp	/^        constexpr indexed_element(reference_wrapper<T> r) noexcept$/;"	f	struct:ranges::indexed_element
indexed_element	include/range/v3/detail/variant.hpp	/^    struct indexed_element$/;"	s	namespace:ranges
indexed_element	include/range/v3/detail/variant.hpp	/^    struct indexed_element<void, Index>$/;"	s	namespace:ranges
indexed_element_fn	include/range/v3/detail/variant.hpp	/^        struct indexed_element_fn$/;"	s	namespace:ranges::detail
indices_fn	include/range/v3/view/indices.hpp	/^        struct indices_fn : iota_view<std::size_t>$/;"	s	namespace:ranges::views
indices_strategy_	include/meta/meta.hpp	/^        enum class indices_strategy_$/;"	g	namespace:meta::detail
indirect_fn	include/range/v3/functional/indirect.hpp	/^    struct indirect_fn$/;"	s	namespace:ranges
indirect_fn	include/range/v3/view/indirect.hpp	/^        struct indirect_fn$/;"	s	namespace:ranges::views
indirect_invoke_result	include/range/v3/iterator/concepts.hpp	/^    struct RANGES_DEPRECATED("Please switch to indirect_result_t") indirect_invoke_result$/;"	s	namespace:ranges
indirect_invoke_result_t	include/range/v3/iterator/concepts.hpp	/^    using indirect_invoke_result_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:indirect_result_t<Fun,Is...>
indirect_result_of	include/range/v3/iterator/concepts.hpp	/^        indirect_result_of<Fun(Is...)> : meta::defer<indirect_result_t, Fun, Is...>$/;"	s	namespace:ranges
indirect_result_of	include/range/v3/iterator/concepts.hpp	/^    struct indirect_result_of$/;"	s	namespace:ranges
indirect_result_of_t	include/range/v3/iterator/concepts.hpp	/^    using indirect_result_of_t RANGES_DEPRECATED("Please switch to indirect_result_t") =$/;"	t	namespace:ranges	typeref:typename:meta::_t<indirect_result_of<Sig>>
indirect_result_t	include/range/v3/iterator/concepts.hpp	/^    using indirect_result_t =$/;"	t	namespace:ranges
indirect_view	include/range/v3/view/indirect.hpp	/^        explicit constexpr indirect_view(Rng rng)$/;"	f	struct:ranges::indirect_view
indirect_view	include/range/v3/view/indirect.hpp	/^    struct indirect_view : view_adaptor<indirect_view<Rng>, Rng>$/;"	s	namespace:ranges
indirect_zip_fn_	include/range/v3/view/zip.hpp	/^        struct indirect_zip_fn_$/;"	s	namespace:ranges::detail
indirected	include/range/v3/functional/indirect.hpp	/^        indirected(Fn fn)$/;"	f	struct:ranges::indirected
indirected	include/range/v3/functional/indirect.hpp	/^    struct indirected$/;"	s	namespace:ranges
infinity	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t infinity() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
infinity	include/range/v3/utility/infinity.hpp	/^    struct infinity$/;"	s	namespace:ranges
info_	include/range/v3/view/any_view.hpp	/^            std::type_info const * info_ = nullptr;$/;"	m	struct:ranges::detail::any_ref	typeref:typename:std::type_info const *
init	include/range/v3/view/any_view.hpp	/^            virtual void init() override$/;"	f	struct:ranges::detail::any_input_view_impl	typeref:typename:void
init	include/range/v3/view/any_view.hpp	/^            void init(Rng & rng) noexcept$/;"	f	struct:ranges::detail::any_view_sentinel_impl	typeref:typename:void
init_	include/range/v3/view/exclusive_scan.hpp	/^        semiregular_box_t<T> init_;$/;"	m	struct:ranges::exclusive_scan_view	typeref:typename:semiregular_box_t<T>
initial_suspend	include/range/v3/experimental/utility/generator.hpp	/^            std::experimental::suspend_always initial_suspend() const noexcept$/;"	f	struct:ranges::detail::generator_promise	typeref:typename:std::experimental::suspend_always
initial_suspend	include/range/v3/experimental/utility/generator.hpp	/^            std::experimental::suspend_never initial_suspend() const noexcept$/;"	f	struct:ranges::detail::sized_generator_promise	typeref:typename:std::experimental::suspend_never
inner_	include/range/v3/view/join.hpp	/^            views::all_t<Inner> inner_ = views::all_t<Inner>();$/;"	m	struct:ranges::detail::store_inner_	typeref:typename:views::all_t<Inner>
inner_	include/range/v3/view/join.hpp	/^        Inner inner_{};$/;"	m	struct:ranges::join_with_view	typeref:typename:Inner
inner_it_	include/range/v3/view/join.hpp	/^            iterator_t<CInner> inner_it_{};$/;"	m	struct:ranges::join_view::cursor	typeref:typename:iterator_t<CInner>
inner_product_fn	include/range/v3/numeric/inner_product.hpp	/^    struct inner_product_fn$/;"	s	namespace:ranges
inner_value_t	include/range/v3/view/join.hpp	/^            using inner_value_t = range_value_t<range_reference_t<Rng>>;$/;"	t	struct:ranges::views::join_base_fn	typeref:typename:range_value_t<range_reference_t<Rng>>
inner_view	include/range/v3/view/chunk.hpp	/^                constexpr explicit inner_view(chunk_view_ & view) noexcept$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view
inner_view	include/range/v3/view/chunk.hpp	/^            struct inner_view : view_facade<inner_view, finite>$/;"	s	struct:ranges::chunk_view_::outer_cursor
inplace_merge_no_buffer_fn	include/range/v3/algorithm/inplace_merge.hpp	/^        struct inplace_merge_no_buffer_fn$/;"	s	namespace:ranges::detail
inplace_stable_sort	include/range/v3/algorithm/stable_sort.hpp	/^        void inplace_stable_sort(I first, I last, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
input	include/range/v3/view/any_view.hpp	/^        input = 1,            \/\/\/<\\brief satisfies ranges::concepts::input_range$/;"	e	enum:ranges::category
input_cursor_tag	include/range/v3/detail/range_access.hpp	/^        using input_cursor_tag = concepts::tag<input_cursor_concept, cursor_tag>;$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<input_cursor_concept,cursor_tag>
input_iterator_tag	include/range/v3/iterator/traits.hpp	/^    using input_iterator_tag RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:std::input_iterator_tag
input_iterator_tag_	include/range/v3/iterator/traits.hpp	/^        using input_iterator_tag_ = ::concepts::tag<input_iterator_concept>;$/;"	t	namespace:ranges::detail	typeref:typename:::concepts::tag<input_iterator_concept>
input_range_tag	include/range/v3/range/concepts.hpp	/^    using input_range_tag = ::concepts::tag<input_range_concept, range_tag>;$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<input_range_concept,range_tag>
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, I i, S j)$/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (insert_result_t<Cont &,detail::cpp17_iterator_t<I,S>,detail::cpp17_iterator_t<I,S>>)(requires lvalue_container_like<Cont> && sentinel_for<S,I> && (!range<S>))
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, I p, N n, T && t)$/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (insert_result_t<Cont &,I,N,T>)(requires lvalue_container_like<Cont> && input_iterator<I> && integral<N> && constructible_from<range_value_t<Cont>,T>)
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, I p, Rng && rng)$/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (decltype (detail::insert_impl (static_cast<Cont &&> (cont),std::move (p),static_cast<Rng &&> (rng),meta::bool_<random_access_reservable<Cont> && sized_range<Rng>>{})))(requires lvalue_container_like<Cont> && input_iterator<I> && range<Rng>)
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, I p, T && t)$/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (insert_result_t<Cont &,I,T>)(requires lvalue_container_like<Cont> && input_iterator<I> && (!range<T> && constructible_from<range_value_t<Cont>,T>))
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, P p, I i, S j) -> CPP_ret(decltype(detail::insert_impl($/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (decltype (detail::insert_impl (static_cast<Cont &&> (cont),std::move (p),std::move (i),std::move (j),meta::bool_<random_access_reservable<Cont> && sized_sentinel_for<S,I>>{})))(requires lvalue_container_like<Cont> && input_iterator<P> && sentinel_for<S,I> && (!range<S>))
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, Rng && rng)$/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (insert_result_t<Cont &,detail::range_cpp17_iterator_t<Rng>,detail::range_cpp17_iterator_t<Rng>>)(requires lvalue_container_like<Cont> && range<Rng>)
insert	include/range/v3/action/insert.hpp	/^        auto insert(Cont && cont, T && t) -> CPP_ret(insert_result_t<Cont &, T>)( \/\/$/;"	f	namespace:ranges::adl_insert_detail	typeref:typename:CPP_ret (insert_result_t<Cont &,T>)(requires lvalue_container_like<Cont> && (!range<T> && constructible_from<range_value_t<Cont>,T>))
insert_fn	include/range/v3/action/insert.hpp	/^        struct insert_fn$/;"	s	namespace:ranges::adl_insert_detail
insert_impl	include/range/v3/action/insert.hpp	/^            auto insert_impl(Cont && cont, I p, Rng && rng, std::false_type)$/;"	f	namespace:ranges::adl_insert_detail::detail	typeref:typename:CPP_ret (decltype (unwrap_reference (cont).insert (p,range_cpp17_iterator_t<Rng>{ranges::begin(rng)},range_cpp17_iterator_t<Rng>{ranges::end(rng)})))(requires range<Rng>)
insert_impl	include/range/v3/action/insert.hpp	/^            auto insert_impl(Cont && cont, P p, I i, S j, std::false_type)$/;"	f	namespace:ranges::adl_insert_detail::detail	typeref:typename:CPP_ret (decltype (unwrap_reference (cont).insert (p,cpp17_iterator_t<I,S>{i},cpp17_iterator_t<I,S>{j})))(requires sentinel_for<S,I> && (!range<S>))
insert_impl	include/range/v3/action/insert.hpp	/^            auto insert_impl(Cont && cont_, I p, Rng && rng, std::true_type)$/;"	f	namespace:ranges::adl_insert_detail::detail	typeref:typename:CPP_ret (decltype (unwrap_reference (cont_).insert (begin (unwrap_reference (cont_)),range_cpp17_iterator_t<Rng>{ranges::begin(rng)},range_cpp17_iterator_t<Rng>{ranges::end(rng)})))(requires random_access_reservable<Cont> && sized_range<Rng>)
insert_impl	include/range/v3/action/insert.hpp	/^            auto insert_impl(Cont && cont_, P p, I i, S j, std::true_type)$/;"	f	namespace:ranges::adl_insert_detail::detail	typeref:typename:CPP_ret (decltype (unwrap_reference (cont_).insert (ranges::begin (unwrap_reference (cont_)),cpp17_iterator_t<I,S>{i},cpp17_iterator_t<I,S>{j})))(requires sized_sentinel_for<S,I> && random_access_reservable<Cont> && (!range<S>))
insert_iterator	include/range/v3/iterator/insert_iterators.hpp	/^        explicit constexpr insert_iterator(Container & x, typename Container::iterator w)$/;"	f	struct:ranges::insert_iterator
insert_iterator	include/range/v3/iterator/insert_iterators.hpp	/^    struct insert_iterator$/;"	s	namespace:ranges
insert_reserve_helper	include/range/v3/action/insert.hpp	/^            auto insert_reserve_helper(Cont & cont, P const p,$/;"	f	namespace:ranges::adl_insert_detail::detail	typeref:typename:CPP_ret (iterator_t<Cont>)(requires container<Cont> && input_iterator<P> && random_access_reservable<Cont>)
insert_result_t	include/range/v3/action/insert.hpp	/^            using insert_result_t =$/;"	t	struct:ranges::adl_insert_detail::insert_fn
insert_result_t	include/range/v3/action/insert.hpp	/^        using insert_result_t = decltype($/;"	t	namespace:ranges::adl_insert_detail
insert_t	include/range/v3/action/push_back.hpp	/^        using insert_t = decltype(static_cast<void>($/;"	t	namespace:ranges::adl_push_back_detail
insert_t	include/range/v3/action/push_front.hpp	/^        using insert_t = decltype(static_cast<void>($/;"	t	namespace:ranges::adl_push_front_detail
inserter_fn	include/range/v3/iterator/insert_iterators.hpp	/^    struct inserter_fn$/;"	s	namespace:ranges
insertion_sort	include/range/v3/algorithm/sort.hpp	/^        inline void insertion_sort(I first, I last, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
int_	include/meta/meta.hpp	/^    using int_ = std::integral_constant<int, I>;$/;"	t	namespace:meta	typeref:typename:std::integral_constant<int,I>
integer_range	include/meta/meta.hpp	/^    using integer_range =$/;"	t	namespace:meta
integer_sequence	include/meta/meta.hpp	/^    struct integer_sequence$/;"	s	namespace:meta
interface	include/range/v3/utility/any.hpp	/^        struct interface$/;"	s	struct:ranges::any
interleave	example/calendar.cpp	/^interleave()$/;"	f	typeref:typename:auto
interleave_view	example/calendar.cpp	/^    explicit interleave_view(Rngs rngs)$/;"	f	class:interleave_view	file:
interleave_view	example/calendar.cpp	/^class interleave_view : public view_facade<interleave_view<Rngs>>$/;"	c	file:
intersperse_base_fn	include/range/v3/view/intersperse.hpp	/^        struct intersperse_base_fn$/;"	s	namespace:ranges::views
intersperse_fn	include/range/v3/view/intersperse.hpp	/^        struct intersperse_fn : intersperse_base_fn$/;"	s	namespace:ranges::views
intersperse_view	include/range/v3/view/intersperse.hpp	/^        constexpr intersperse_view(Rng rng, range_value_t<Rng> val)$/;"	f	struct:ranges::intersperse_view
intersperse_view	include/range/v3/view/intersperse.hpp	/^    struct intersperse_view$/;"	s	namespace:ranges
introsort_loop	include/range/v3/algorithm/sort.hpp	/^        inline void introsort_loop(I first, I last, Size depth_limit, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
introsort_threshold	include/range/v3/algorithm/sort.hpp	/^        constexpr int introsort_threshold()$/;"	f	namespace:ranges::detail	typeref:typename:int
ints_fn	include/range/v3/view/iota.hpp	/^        struct ints_fn : iota_view<int>$/;"	s	namespace:ranges::views
invalid	include/range/v3/experimental/utility/generator.hpp	/^            invalid = ~generator_size_t(0)$/;"	e	enum:ranges::experimental::generator_size
invalid	include/range/v3/view/drop_last.hpp	/^                invalid$/;"	e	enum:ranges::detail::drop_last_view::mode_enum
invoke	include/concepts/concepts.hpp	/^        using invoke = T;$/;"	t	struct:concepts::return_t_	typeref:typename:T
invoke	include/concepts/type_traits.hpp	/^            using invoke = T;$/;"	t	struct:concepts::detail::_xref	typeref:typename:T
invoke	include/concepts/type_traits.hpp	/^            using invoke = T;$/;"	t	struct:concepts::detail::if_	typeref:typename:T
invoke	include/concepts/type_traits.hpp	/^            using invoke = T;$/;"	t	struct:concepts::detail::if_else_	typeref:typename:T
invoke	include/concepts/type_traits.hpp	/^            using invoke = U const volatile;$/;"	t	struct:concepts::detail::_xref	typeref:typename:U const volatile
invoke	include/concepts/type_traits.hpp	/^            using invoke = U const;$/;"	t	struct:concepts::detail::_xref	typeref:typename:U const
invoke	include/concepts/type_traits.hpp	/^            using invoke = U volatile;$/;"	t	struct:concepts::detail::_xref	typeref:typename:U volatile
invoke	include/concepts/type_traits.hpp	/^            using invoke = U;$/;"	t	struct:concepts::detail::if_else_	typeref:typename:U
invoke	include/concepts/type_traits.hpp	/^            using invoke =$/;"	t	struct:concepts::detail::_xref	typeref:typename:meta::_t<std::add_lvalue_reference<meta::invoke<_xref<T>,U>>>
invoke	include/concepts/type_traits.hpp	/^            using invoke =$/;"	t	struct:concepts::detail::_xref	typeref:typename:meta::_t<std::add_rvalue_reference<meta::invoke<_xref<T>,U>>>
invoke	include/meta/meta.hpp	/^        using invoke = _t<decltype(id::impl(static_cast<list<Ts...> *>(nullptr)))>;$/;"	t	struct:meta::id
invoke	include/meta/meta.hpp	/^        using invoke = defer<invoke, Fn, Args...>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<invoke,Fn,Args...>
invoke	include/meta/meta.hpp	/^    using invoke = typename Fn::template invoke<Args...>;$/;"	t	namespace:meta	typeref:typename:Fn::template invoke<Args...>
invoke	include/range/v3/range/conversion.hpp	/^            using invoke = decltype(from_range::from_rng_<Rng>(0));$/;"	t	struct:ranges::detail::from_range
invoke	include/range/v3/view/interface.hpp	/^            using invoke = T;$/;"	t	struct:ranges::detail::dependent_	typeref:typename:T
invoke	include/range/v3/view/split.hpp	/^            using invoke = here<It>;$/;"	t	struct:ranges::detail::here_or_there_	typeref:typename:here<It>
invoke	include/range/v3/view/split.hpp	/^            using invoke = there;$/;"	t	struct:ranges::detail::here_or_there_	typeref:typename:there
invoke_fn	include/range/v3/functional/invoke.hpp	/^    struct invoke_fn$/;"	s	namespace:ranges
invoke_result	include/range/v3/functional/invoke.hpp	/^    using invoke_result = detail::_invoke_result_<void, Fun, Args...>;$/;"	t	namespace:ranges	typeref:typename:detail::_invoke_result_<void,Fun,Args...>
invoke_result_t	include/range/v3/functional/invoke.hpp	/^    using invoke_result_t = meta::_t<invoke_result<Fun, Args...>>;$/;"	t	namespace:ranges	typeref:typename:meta::_t<invoke_result<Fun,Args...>>
iota_advance_	include/range/v3/view/iota.hpp	/^        auto iota_advance_(I & i, iota_difference_t<I> n) -> CPP_ret(void)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (void)(requires (!unsigned_integral<I>))
iota_advance_	include/range/v3/view/iota.hpp	/^        auto iota_advance_(Int & i, iota_difference_t<Int> n) -> CPP_ret(void)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (void)(requires unsigned_integral<Int>)
iota_difference_t	include/range/v3/view/iota.hpp	/^        using iota_difference_t = typename if_then_t<$/;"	t	namespace:ranges::detail
iota_distance_	include/range/v3/view/iota.hpp	/^        auto iota_distance_(I const & i, I const & s) -> CPP_ret(iota_difference_t<I>)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (iota_difference_t<I>)(requires advanceable_<I> && (!integral<I>))
iota_distance_	include/range/v3/view/iota.hpp	/^        auto iota_distance_(Int i0, Int i1) -> CPP_ret(iota_difference_t<Int>)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (iota_difference_t<Int>)(requires signed_integral<Int>)
iota_distance_	include/range/v3/view/iota.hpp	/^        auto iota_distance_(Int i0, Int i1) -> CPP_ret(iota_difference_t<Int>)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (iota_difference_t<Int>)(requires unsigned_integral<Int>)
iota_fn	include/range/v3/numeric/iota.hpp	/^    struct iota_fn$/;"	s	namespace:ranges
iota_fn	include/range/v3/view/iota.hpp	/^        struct iota_fn$/;"	s	namespace:ranges::views
iota_view	include/range/v3/view/iota.hpp	/^        constexpr explicit iota_view(From from)$/;"	f	struct:ranges::iota_view
iota_view	include/range/v3/view/iota.hpp	/^        constexpr iota_view(meta::id_t<From> from, meta::id_t<To> to)$/;"	f	struct:ranges::iota_view
iota_view	include/range/v3/view/iota.hpp	/^    struct RANGES_EMPTY_BASES iota_view$/;"	s	namespace:ranges
iota_view_detail	include/range/v3/view/iota.hpp	/^    namespace iota_view_detail$/;"	n	namespace:ranges
is_adl_indirectly_movable_v	include/range/v3/iterator/access.hpp	/^        RANGES_INLINE_VAR constexpr bool is_adl_indirectly_movable_v =$/;"	v	namespace:ranges::_iter_move_	typeref:typename:RANGES_INLINE_VAR bool
is_adl_indirectly_swappable_v	include/range/v3/iterator/access.hpp	/^        RANGES_INLINE_VAR constexpr bool is_adl_indirectly_swappable_v =$/;"	v	namespace:ranges::_iter_swap_	typeref:typename:RANGES_INLINE_VAR bool
is_adl_swappable_v	include/concepts/swap.hpp	/^        CPP_INLINE_VAR constexpr bool is_adl_swappable_v =$/;"	v	namespace:concepts::adl_swap_detail	typeref:typename:CPP_INLINE_VAR bool
is_bounded	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_bounded = true;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_bounded	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_bounded;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_callable	include/meta/meta.hpp	/^    using is_callable = bool_<is_callable_v<T>>;$/;"	t	namespace:meta	typeref:typename:bool_<is_callable_v<T>>
is_callable_	include/meta/meta.hpp	/^        META_INLINE_VAR constexpr bool is_callable_ = false;$/;"	v	namespace:meta::detail	typeref:typename:META_INLINE_VAR bool
is_callable_	include/meta/meta.hpp	/^        struct is_callable_$/;"	s	namespace:meta::detail
is_callable_v	include/meta/meta.hpp	/^    META_INLINE_VAR constexpr bool is_callable_v = detail::is_callable_<T>;$/;"	v	namespace:meta	typeref:typename:META_INLINE_VAR bool
is_callable_v	include/meta/meta.hpp	/^    META_INLINE_VAR constexpr bool is_callable_v = invocable<T>;$/;"	v	namespace:meta	typeref:typename:META_INLINE_VAR bool
is_char_type	include/range/v3/view/c_str.hpp	/^        using is_char_type = is_char_type_<meta::_t<std::remove_cv<T>>>;$/;"	t	namespace:ranges::detail	typeref:typename:is_char_type_<meta::_t<std::remove_cv<T>>>
is_char_type_	include/range/v3/view/c_str.hpp	/^        struct is_char_type_ : std::false_type$/;"	s	namespace:ranges::detail
is_char_type_	include/range/v3/view/c_str.hpp	/^        struct is_char_type_<char16_t> : std::true_type$/;"	s	namespace:ranges::detail
is_char_type_	include/range/v3/view/c_str.hpp	/^        struct is_char_type_<char32_t> : std::true_type$/;"	s	namespace:ranges::detail
is_char_type_	include/range/v3/view/c_str.hpp	/^        struct is_char_type_<char> : std::true_type$/;"	s	namespace:ranges::detail
is_char_type_	include/range/v3/view/c_str.hpp	/^        struct is_char_type_<wchar_t> : std::true_type$/;"	s	namespace:ranges::detail
is_common_range	include/range/v3/view/common.hpp	/^        struct is_common_range : meta::bool_<common_range<Rng>>$/;"	s	namespace:ranges::detail
is_convertible	include/concepts/type_traits.hpp	/^        using is_convertible = std::is_convertible<meta::_t<std::add_rvalue_reference<From>>, To/;"	t	namespace:concepts::detail	typeref:typename:std::is_convertible<meta::_t<std::add_rvalue_reference<From>>,To>
is_exact	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_exact = true;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_exact	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_exact;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_hashable	include/ntskills.hpp	/^  static constexpr bool is_hashable = true;$/;"	m	struct:nt::Hashable	typeref:typename:bool
is_heap_n_fn	include/range/v3/algorithm/heap_algorithm.hpp	/^        struct is_heap_n_fn$/;"	s	namespace:ranges::detail
is_heap_until_n_fn	include/range/v3/algorithm/heap_algorithm.hpp	/^        struct is_heap_until_n_fn$/;"	s	namespace:ranges::detail
is_iec559	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_iec559 = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_iec559	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_iec559;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_indirectly_movable	include/range/v3/iterator/access.hpp	/^    struct is_indirectly_movable : meta::bool_<is_indirectly_movable_v<I, O>>$/;"	s	namespace:ranges
is_indirectly_movable_v	include/range/v3/iterator/access.hpp	/^    RANGES_INLINE_VAR constexpr bool is_indirectly_movable_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_indirectly_swappable	include/range/v3/iterator/access.hpp	/^    struct is_indirectly_swappable : meta::bool_<is_indirectly_swappable_v<T, U>>$/;"	s	namespace:ranges
is_indirectly_swappable_v	include/range/v3/iterator/access.hpp	/^    RANGES_INLINE_VAR constexpr bool is_indirectly_swappable_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_integer	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_integer = true;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_integer	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_integer;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_integral_	include/std/detail/associated_types.hpp	/^        constexpr bool is_integral_(...)$/;"	f	namespace:ranges::detail	typeref:typename:bool
is_integral_	include/std/detail/associated_types.hpp	/^        constexpr bool is_integral_(int, int T::* = nullptr)$/;"	f	namespace:ranges::detail	typeref:typename:bool
is_integral_	include/std/detail/associated_types.hpp	/^        constexpr bool is_integral_(long)$/;"	f	namespace:ranges::detail	typeref:typename:bool
is_invocable_v	include/range/v3/functional/invoke.hpp	/^    RANGES_INLINE_VAR constexpr bool is_invocable_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_lvalue_container_like	include/range/v3/action/concepts.hpp	/^        auto is_lvalue_container_like(T &) noexcept -> CPP_ret(std::true_type)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:auto
is_lvalue_container_like	include/range/v3/action/concepts.hpp	/^        auto is_lvalue_container_like(ref_view<T>) noexcept -> CPP_ret(std::true_type)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:auto
is_lvalue_container_like	include/range/v3/action/concepts.hpp	/^        auto is_lvalue_container_like(reference_wrapper<T>) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
is_lvalue_container_like	include/range/v3/action/concepts.hpp	/^        auto is_lvalue_container_like(std::reference_wrapper<T>) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
is_lvalue_container_like_t	include/range/v3/action/concepts.hpp	/^        using is_lvalue_container_like_t =$/;"	t	namespace:ranges::detail
is_modulo	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_modulo = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_modulo	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_modulo;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_movable_v	include/concepts/swap.hpp	/^        CPP_INLINE_VAR constexpr bool is_movable_v =$/;"	v	namespace:concepts::detail	typeref:typename:CPP_INLINE_VAR bool
is_nothrow_indirectly_movable	include/range/v3/iterator/access.hpp	/^    struct is_nothrow_indirectly_movable$/;"	s	namespace:ranges
is_nothrow_indirectly_movable_v	include/range/v3/iterator/access.hpp	/^    RANGES_INLINE_VAR constexpr bool is_nothrow_indirectly_movable_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_nothrow_indirectly_swappable	include/range/v3/iterator/access.hpp	/^    struct is_nothrow_indirectly_swappable$/;"	s	namespace:ranges
is_nothrow_indirectly_swappable_v	include/range/v3/iterator/access.hpp	/^    RANGES_INLINE_VAR constexpr bool is_nothrow_indirectly_swappable_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_nothrow_invocable_impl_	include/range/v3/functional/invoke.hpp	/^        struct is_nothrow_invocable_impl_$/;"	s	namespace:ranges::detail
is_nothrow_invocable_impl_	include/range/v3/functional/invoke.hpp	/^        struct is_nothrow_invocable_impl_<true>$/;"	s	namespace:ranges::detail
is_nothrow_invocable_v	include/range/v3/functional/invoke.hpp	/^    RANGES_INLINE_VAR constexpr bool is_nothrow_invocable_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_nothrow_swappable	include/concepts/swap.hpp	/^    struct is_nothrow_swappable$/;"	s	namespace:concepts
is_nothrow_swappable	include/range/v3/utility/swap.hpp	/^    using is_nothrow_swappable = concepts::is_nothrow_swappable<T>;$/;"	t	namespace:ranges	typeref:typename:concepts::is_nothrow_swappable<T>
is_nothrow_swappable_with	include/concepts/swap.hpp	/^    struct is_nothrow_swappable_with$/;"	s	namespace:concepts
is_nothrow_swappable_with	include/range/v3/utility/swap.hpp	/^    using is_nothrow_swappable_with = concepts::is_nothrow_swappable_with<T, U>;$/;"	t	namespace:ranges	typeref:typename:concepts::is_nothrow_swappable_with<T,U>
is_nothrow_swappable_with_	include/concepts/swap.hpp	/^        struct is_nothrow_swappable_with_$/;"	s	namespace:concepts::adl_swap_detail
is_object_	include/std/detail/associated_types.hpp	/^        constexpr bool is_object_(int, T * (*q)(T &) = nullptr, T * p = nullptr,$/;"	f	namespace:ranges::detail	typeref:typename:bool
is_object_	include/std/detail/associated_types.hpp	/^        constexpr bool is_object_(long)$/;"	f	namespace:ranges::detail	typeref:typename:bool
is_permutation_impl	include/range/v3/algorithm/permutation.hpp	/^        bool is_permutation_impl(I1 begin1, S1 end1, I2 begin2, S2 end2, C pred, P1 proj1,$/;"	f	namespace:ranges::detail	typeref:typename:bool
is_pipeable	include/range/v3/functional/pipeable.hpp	/^    using is_pipeable = meta::bool_<is_pipeable_v<T>>;$/;"	t	namespace:ranges	typeref:typename:meta::bool_<is_pipeable_v<T>>
is_pipeable_v	include/range/v3/functional/pipeable.hpp	/^    RANGES_INLINE_VAR constexpr bool is_pipeable_v = META_IS_BASE_OF(pipeable_base, T);$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_random_access_common_	include/range/v3/view/take_exactly.hpp	/^        struct is_random_access_common_$/;"	s	namespace:ranges::detail
is_reference_wrapper	include/range/v3/functional/invoke.hpp	/^    using is_reference_wrapper = meta::bool_<is_reference_wrapper_v<T>>;$/;"	t	namespace:ranges	typeref:typename:meta::bool_<is_reference_wrapper_v<T>>
is_reference_wrapper_t	include/range/v3/functional/invoke.hpp	/^    using is_reference_wrapper_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:meta::_t<is_reference_wrapper<T>>
is_reference_wrapper_v	include/range/v3/functional/invoke.hpp	/^        RANGES_INLINE_VAR constexpr bool is_reference_wrapper_v =$/;"	v	namespace:ranges::detail	typeref:typename:RANGES_INLINE_VAR bool
is_reference_wrapper_v	include/range/v3/functional/invoke.hpp	/^    RANGES_INLINE_VAR constexpr bool is_reference_wrapper_v =$/;"	v	namespace:ranges	typeref:typename:RANGES_INLINE_VAR bool
is_satisfied_by	include/concepts/concepts.hpp	/^    struct is_satisfied_by$/;"	s	namespace:concepts
is_signed	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_signed = true;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_signed	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_signed;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_six	example/any_all_none_of.cpp	/^auto is_six = [](int i) { return i == 6; };$/;"	v	typeref:typename:auto
is_six	example/count_if.cpp	/^auto is_six = [](int i) -> bool { return i == 6; };$/;"	v	typeref:typename:auto
is_six	example/find.cpp	/^auto is_six = [](int i) -> bool { return i == 6; };$/;"	v	typeref:typename:auto
is_sized_sentinel_	include/range/v3/view/subrange.hpp	/^        constexpr auto is_sized_sentinel_() noexcept -> CPP_ret(bool)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:auto
is_specialized	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool is_specialized = true;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
is_specialized	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::is_specialized;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
is_swappable	include/concepts/swap.hpp	/^    struct is_swappable$/;"	s	namespace:concepts
is_swappable	include/range/v3/utility/swap.hpp	/^    using is_swappable = concepts::is_swappable<T>;$/;"	t	namespace:ranges	typeref:typename:concepts::is_swappable<T>
is_swappable_with	include/concepts/swap.hpp	/^    struct is_swappable_with$/;"	s	namespace:concepts
is_swappable_with	include/range/v3/utility/swap.hpp	/^    using is_swappable_with = concepts::is_swappable_with<T, U>;$/;"	t	namespace:ranges	typeref:typename:concepts::is_swappable_with<T,U>
is_swappable_with_	include/concepts/swap.hpp	/^        struct is_swappable_with_$/;"	s	namespace:concepts::adl_swap_detail
is_trait	include/meta/meta.hpp	/^    using is_trait = bool_<is_trait_v<T>>;$/;"	t	namespace:meta	typeref:typename:bool_<is_trait_v<T>>
is_trait_	include/meta/meta.hpp	/^        META_INLINE_VAR constexpr bool is_trait_ = false;$/;"	v	namespace:meta::detail	typeref:typename:META_INLINE_VAR bool
is_trait_	include/meta/meta.hpp	/^        struct is_trait_$/;"	s	namespace:meta::detail
is_trait_v	include/meta/meta.hpp	/^    META_INLINE_VAR constexpr bool is_trait_v = detail::is_trait_<T>;$/;"	v	namespace:meta	typeref:typename:META_INLINE_VAR bool
is_trait_v	include/meta/meta.hpp	/^    META_INLINE_VAR constexpr bool is_trait_v = trait<T>;$/;"	v	namespace:meta	typeref:typename:META_INLINE_VAR bool
is_transparent	include/range/v3/functional/arithmetic.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::bitwise_or	typeref:typename:void
is_transparent	include/range/v3/functional/arithmetic.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::minus	typeref:typename:void
is_transparent	include/range/v3/functional/arithmetic.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::multiplies	typeref:typename:void
is_transparent	include/range/v3/functional/arithmetic.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::plus	typeref:typename:void
is_transparent	include/range/v3/functional/comparisons.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::equal_to	typeref:typename:void
is_transparent	include/range/v3/functional/comparisons.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::greater	typeref:typename:void
is_transparent	include/range/v3/functional/comparisons.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::greater_equal	typeref:typename:void
is_transparent	include/range/v3/functional/comparisons.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::less	typeref:typename:void
is_transparent	include/range/v3/functional/comparisons.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::less_equal	typeref:typename:void
is_transparent	include/range/v3/functional/comparisons.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::not_equal_to	typeref:typename:void
is_transparent	include/range/v3/functional/identity.hpp	/^        using is_transparent = void;$/;"	t	struct:ranges::identity	typeref:typename:void
is_true	include/meta/meta_fwd.hpp	/^    META_CONCEPT is_true = META_CONCEPT_BARRIER(true);$/;"	v	namespace:meta	typeref:typename:META_CONCEPT
is_v	include/meta/meta_fwd.hpp	/^    META_INLINE_VAR constexpr bool is_v = false;$/;"	v	namespace:meta	typeref:typename:META_INLINE_VAR bool
is_writable_cursor	include/range/v3/detail/range_access.hpp	/^        struct is_writable_cursor$/;"	s	namespace:ranges::detail
is_writable_cursor_	include/range/v3/detail/range_access.hpp	/^        struct is_writable_cursor_ : std::true_type$/;"	s	namespace:ranges::detail
is_writable_cursor_	include/range/v3/detail/range_access.hpp	/^        struct is_writable_cursor_<Cur, true>$/;"	s	namespace:ranges::detail
islr	include/lr.hpp	/^template <typename T> struct islr : std::false_type {};$/;"	s	namespace:lr
islr_t	include/lr.hpp	/^template <typename T> using islr_t = typename islr<T>::type;$/;"	t	namespace:lr	typeref:typename:islr<T>::type
islr_v	include/lr.hpp	/^template <typename T> inline constexpr bool islr_v = islr<T>::value;$/;"	v	namespace:lr	typeref:typename:bool
istream	include/range/v3/view/istream.hpp	/^        inline auto istream(std::istream & sin) -> CPP_ret(istream_view<Val>)( \/\/$/;"	f	namespace:ranges::_istream_	typeref:typename:CPP_ret (istream_view<Val>)(requires copy_constructible<Val> && default_constructible<Val>)
istream_range	include/range/v3/view/istream.hpp	/^    using istream_range RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:istream_view<Val>
istream_view	include/range/v3/view/istream.hpp	/^        explicit istream_view(std::istream & sin)$/;"	f	struct:ranges::istream_view
istream_view	include/range/v3/view/istream.hpp	/^    struct istream_view : view_facade<istream_view<Val>, unknown>$/;"	s	namespace:ranges
it	include/range/v3/view/chunk.hpp	/^        constexpr iterator_t<Rng> & it() noexcept$/;"	f	struct:ranges::chunk_view_	typeref:typename:iterator_t<Rng> &
it	include/range/v3/view/chunk.hpp	/^        constexpr iterator_t<Rng> const & it() const noexcept$/;"	f	struct:ranges::chunk_view_	typeref:typename:iterator_t<Rng> const &
it1_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R1> it1_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:iterator_t<R1>
it1_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R1> it1_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:iterator_t<R1>
it1_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R1> it1_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:iterator_t<R1>
it1_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R1> it1_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:iterator_t<R1>
it1_	include/range/v3/view/transform.hpp	/^            iterator_t<R1> it1_;$/;"	m	struct:ranges::iter_transform2_view::cursor	typeref:typename:iterator_t<R1>
it2_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R2> it2_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:iterator_t<R2>
it2_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R2> it2_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:iterator_t<R2>
it2_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R2> it2_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:iterator_t<R2>
it2_	include/range/v3/view/set_algorithm.hpp	/^            iterator_t<R2> it2_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:iterator_t<R2>
it2_	include/range/v3/view/transform.hpp	/^            iterator_t<R2> it2_;$/;"	m	struct:ranges::iter_transform2_view::cursor	typeref:typename:iterator_t<R2>
it_	include/range/v3/iterator/common_iterator.hpp	/^            I it_;$/;"	m	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:I
it_	include/range/v3/iterator/move_iterators.hpp	/^            I it_ = I();$/;"	m	struct:ranges::detail::move_into_cursor	typeref:typename:I
it_	include/range/v3/iterator/reverse_iterator.hpp	/^            I it_;$/;"	m	struct:ranges::detail::reverse_cursor	typeref:typename:I
it_	include/range/v3/range/conversion.hpp	/^            I it_;$/;"	m	struct:ranges::detail::to_container_iterator	typeref:typename:I
it_	include/range/v3/view/counted.hpp	/^        I it_;$/;"	m	struct:ranges::counted_view	typeref:typename:I
it_	include/range/v3/view/cycle.hpp	/^            iterator it_{};$/;"	m	struct:ranges::cycled_view::cursor	typeref:typename:iterator
it_	include/range/v3/view/sliding.hpp	/^            uncounted_t<Rng> it_;$/;"	m	struct:ranges::sliding_view_detail::trailing	typeref:typename:uncounted_t<Rng>
it_	include/range/v3/view/unbounded.hpp	/^        I it_;$/;"	m	struct:ranges::unbounded_view	typeref:typename:I
it_cache_	include/range/v3/view/chunk.hpp	/^        mutable iter_cache_t it_cache_;$/;"	m	struct:ranges::chunk_view_	typeref:typename:iter_cache_t
iter_arrow_t	include/range/v3/iterator/traits.hpp	/^        using iter_arrow_t = decltype(std::declval<I &>().operator->());$/;"	t	namespace:ranges::detail
iter_cache_t	include/range/v3/view/chunk.hpp	/^        using iter_cache_t = detail::non_propagating_cache<iterator_t<Rng>>;$/;"	t	struct:ranges::chunk_view_	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
iter_common_reference_t	include/range/v3/iterator/traits.hpp	/^    using iter_common_reference_t =$/;"	t	namespace:ranges	typeref:typename:common_reference_t<iter_reference_t<I>,iter_value_t<I> &>
iter_concept_t	include/range/v3/iterator/concepts.hpp	/^        using iter_concept_t =$/;"	t	namespace:ranges::detail
iter_diff_t	include/range/v3/range/access.hpp	/^            using iter_diff_t =$/;"	t	struct:ranges::_end_::fn
iter_difference_t	include/range/v3/iterator/traits.hpp	/^    using iter_difference_t = typename incrementable_traits<T>::difference_type;$/;"	t	namespace:ranges	typeref:typename:incrementable_traits<T>::difference_type
iter_difference_t	include/range/v3/iterator/traits.hpp	/^    using iter_difference_t =$/;"	t	namespace:ranges	typeref:typename:detail::if_then_t<detail::is_std_iterator_traits_specialized_v<T>,std::iterator_traits<T>,incrementable_traits<T>>::difference_type
iter_distance_compare_fn	include/range/v3/iterator/operations.hpp	/^    struct iter_distance_compare_fn$/;"	s	namespace:ranges
iter_distance_fn	include/range/v3/iterator/operations.hpp	/^    struct iter_distance_fn$/;"	s	namespace:ranges
iter_enumerate_fn	include/range/v3/iterator/operations.hpp	/^    struct iter_enumerate_fn$/;"	s	namespace:ranges
iter_move	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto iter_move(basic_iterator<Cur> const & it) noexcept($/;"	f	namespace:_basic_iterator_	typeref:typename:auto
iter_move	include/range/v3/iterator/basic_iterator.hpp	/^        friend constexpr auto iter_move(basic_iterator const & it) noexcept($/;"	f	typeref:typename:auto
iter_move	include/range/v3/iterator/common_iterator.hpp	/^        constexpr auto iter_move(common_iterator<I, S> const & i) noexcept($/;"	f	namespace:ranges::_common_iterator_	typeref:typename:auto
iter_move	include/range/v3/iterator/common_iterator.hpp	/^        friend constexpr auto iter_move(common_iterator const & i) noexcept($/;"	f	namespace:ranges	typeref:typename:auto
iter_move	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto iter_move(counted_iterator<I> const & i) noexcept($/;"	f	namespace:ranges::_counted_iterator_	typeref:typename:auto
iter_move	include/range/v3/iterator/counted_iterator.hpp	/^        friend constexpr auto iter_move(counted_iterator const & i) noexcept($/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_member auto
iter_move	include/range/v3/view/const.hpp	/^            rvalue_reference_ iter_move(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::const_view::adaptor	typeref:typename:rvalue_reference_
iter_move	include/range/v3/view/move.hpp	/^            range_rvalue_reference_t<CRng> iter_move(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::move_view::adaptor	typeref:typename:range_rvalue_reference_t<CRng>
iter_move	include/range/v3/view/split.hpp	/^            friend constexpr decltype(auto) iter_move($/;"	f	namespace:ranges::detail	typeref:typename:decltype (auto)
iter_move_	include/range/v3/view/adaptor.hpp	/^        X iter_move_(detail::ignore_t) const noexcept(noexcept(X(static_cast<X &&>($/;"	f	struct:ranges::adaptor_cursor	typeref:typename:X
iter_move_	include/range/v3/view/adaptor.hpp	/^        X iter_move_(int) const noexcept(noexcept($/;"	f	struct:ranges::adaptor_cursor	typeref:typename:X
iter_pointer_t	include/range/v3/iterator/traits.hpp	/^        using iter_pointer_t =$/;"	t	namespace:ranges::detail
iter_ref	include/range/v3/utility/memory.hpp	/^    auto iter_ref(I & i) -> CPP_ret(iterator_wrapper<I>)( \/\/$/;"	f	namespace:ranges	typeref:typename:CPP_ret (iterator_wrapper<I>)(requires input_or_output_iterator<I>)
iter_reference_t	include/range/v3/iterator/access.hpp	/^    using iter_reference_t = detail::iter_reference_t_<R>;$/;"	t	namespace:ranges	typeref:typename:detail::iter_reference_t_<R>
iter_reference_t	include/range/v3/iterator/basic_iterator.hpp	/^            using iter_reference_t = basic_proxy_reference<Cur>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:basic_proxy_reference<Cur>
iter_reference_t	include/range/v3/iterator/basic_iterator.hpp	/^            using iter_reference_t =$/;"	t	struct:ranges::iterator_associated_types_base_
iter_reference_t_	include/range/v3/iterator/access.hpp	/^        using iter_reference_t_ = R;$/;"	t	namespace:ranges::detail	typeref:typename:R
iter_rvalue_reference_t	include/range/v3/iterator/traits.hpp	/^        using iter_rvalue_reference_t = R;$/;"	t	namespace:ranges::detail	typeref:typename:R
iter_rvalue_reference_t	include/range/v3/iterator/traits.hpp	/^    using iter_rvalue_reference_t = detail::iter_rvalue_reference_t<I>;$/;"	t	namespace:ranges	typeref:typename:detail::iter_rvalue_reference_t<I>
iter_size_fn	include/range/v3/iterator/operations.hpp	/^    struct iter_size_fn$/;"	s	namespace:ranges
iter_size_t	include/range/v3/iterator/traits.hpp	/^        using iter_size_t =$/;"	t	namespace:ranges::detail
iter_swap	include/range/v3/iterator/common_iterator.hpp	/^        auto iter_swap(common_iterator<I1, S1> const & x,$/;"	f	namespace:ranges::_common_iterator_	typeref:typename:auto
iter_swap	include/range/v3/iterator/common_iterator.hpp	/^        friend auto iter_swap($/;"	f	namespace:ranges	typeref:typename:auto
iter_swap	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto iter_swap($/;"	f	namespace:ranges::_counted_iterator_	typeref:typename:auto
iter_swap	include/range/v3/iterator/counted_iterator.hpp	/^        friend constexpr auto iter_swap(counted_iterator const & x,$/;"	f	namespace:ranges	typeref:typename:auto
iter_swap	include/range/v3/view/split.hpp	/^            friend constexpr auto iter_swap($/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_member auto
iter_t	include/range/v3/range/conversion.hpp	/^                using iter_t = range_cpp17_iterator_t<Rng>;$/;"	t	function:ranges::detail::to_container::fn::operator ()	typeref:typename:range_cpp17_iterator_t<Rng>
iter_t	include/range/v3/range/conversion.hpp	/^                using iter_t = to_container_iterator<Rng, cont_t>;$/;"	t	function:ranges::detail::to_container::fn::operator ()	typeref:typename:to_container_iterator<Rng,cont_t>
iter_take_while_base_fn	include/range/v3/view/take_while.hpp	/^        struct iter_take_while_base_fn$/;"	s	namespace:ranges::views
iter_take_while_fn	include/range/v3/view/take_while.hpp	/^        struct iter_take_while_fn : iter_take_while_base_fn$/;"	s	namespace:ranges::views
iter_take_while_view	include/range/v3/view/take_while.hpp	/^        constexpr iter_take_while_view(Rng rng, Pred pred)$/;"	f	struct:ranges::iter_take_while_view
iter_take_while_view	include/range/v3/view/take_while.hpp	/^    struct iter_take_while_view$/;"	s	namespace:ranges
iter_traits_t	include/range/v3/iterator/concepts.hpp	/^        using iter_traits_t = if_then_t<is_std_iterator_traits_specialized_v<I>,$/;"	t	namespace:ranges::detail	typeref:typename:if_then_t<is_std_iterator_traits_specialized_v<I>,std::iterator_traits<I>,I>
iter_transform2_view	include/range/v3/view/transform.hpp	/^        constexpr iter_transform2_view(Rng1 rng1, Rng2 rng2, Fun fun)$/;"	f	struct:ranges::iter_transform2_view
iter_transform2_view	include/range/v3/view/transform.hpp	/^    struct iter_transform2_view$/;"	s	namespace:ranges
iter_transform_base_fn	include/range/v3/view/transform.hpp	/^        struct iter_transform_base_fn$/;"	s	namespace:ranges::views
iter_transform_fn	include/range/v3/view/transform.hpp	/^        struct iter_transform_fn : iter_transform_base_fn$/;"	s	namespace:ranges::views
iter_transform_view	include/range/v3/view/transform.hpp	/^        iter_transform_view(Rng rng, Fun fun)$/;"	f	struct:ranges::iter_transform_view
iter_transform_view	include/range/v3/view/transform.hpp	/^    struct iter_transform_view : view_adaptor<iter_transform_view<Rng, Fun>, Rng>$/;"	s	namespace:ranges
iter_value_t	include/range/v3/iterator/access.hpp	/^    using iter_value_t = detail::iter_value_t_<uncvref_t<R>>;$/;"	t	namespace:ranges	typeref:typename:detail::iter_value_t_<uncvref_t<R>>
iter_value_t_	include/range/v3/iterator/access.hpp	/^        using iter_value_t_ = typename readable_traits<T>::value_type;$/;"	t	namespace:ranges::detail	typeref:typename:readable_traits<T>::value_type
iter_value_t_	include/range/v3/iterator/access.hpp	/^        using iter_value_t_ =$/;"	t	namespace:ranges::detail	typeref:typename:if_then_t<is_std_iterator_traits_specialized_v<T>,std::iterator_traits<T>,readable_traits<T>>::value_type
iter_zip_with_fn	include/range/v3/view/zip_with.hpp	/^        struct iter_zip_with_fn$/;"	s	namespace:ranges::views
iter_zip_with_view	include/range/v3/view/zip_with.hpp	/^        explicit iter_zip_with_view(Fun fun, Rngs... rngs)$/;"	f	struct:ranges::iter_zip_with_view
iter_zip_with_view	include/range/v3/view/zip_with.hpp	/^        explicit iter_zip_with_view(Rngs... rngs)$/;"	f	struct:ranges::iter_zip_with_view
iter_zip_with_view	include/range/v3/view/zip_with.hpp	/^    struct iter_zip_with_view$/;"	s	namespace:ranges
iterator	include/range/v3/iterator_range.hpp	/^        using iterator = I;$/;"	t	struct:ranges::iterator_range	typeref:typename:I
iterator	include/range/v3/iterator_range.hpp	/^        using iterator = I;$/;"	t	struct:ranges::sized_iterator_range	typeref:typename:I
iterator	include/range/v3/view/cycle.hpp	/^            using iterator = iterator_t<CRng>;$/;"	t	struct:ranges::cycled_view::cursor	typeref:typename:iterator_t<CRng>
iterator	include/range/v3/view/span.hpp	/^        using iterator = T *;$/;"	t	struct:ranges::span	typeref:typename:T *
iterator	include/range/v3/view/subrange.hpp	/^        using iterator = I;$/;"	t	struct:ranges::subrange	typeref:typename:I
iterator_associated_types_base	include/range/v3/iterator/basic_iterator.hpp	/^        using iterator_associated_types_base =$/;"	t	namespace:ranges
iterator_associated_types_base_	include/range/v3/iterator/basic_iterator.hpp	/^        struct iterator_associated_types_base_ : range_access::mixin_base_t<Cur>$/;"	s	namespace:ranges
iterator_associated_types_base_	include/range/v3/iterator/basic_iterator.hpp	/^        struct iterator_associated_types_base_<Cur, true>$/;"	s	namespace:ranges
iterator_category	include/range/v3/action/concepts.hpp	/^            using iterator_category = std::input_iterator_tag;$/;"	t	struct:ranges::detail::movable_input_iterator	typeref:typename:std::input_iterator_tag
iterator_category	include/range/v3/iterator/basic_iterator.hpp	/^            using iterator_category = Category;$/;"	t	struct:ranges::detail::with_iterator_category	typeref:typename:Category
iterator_category	include/range/v3/iterator/basic_iterator.hpp	/^            using iterator_category = cpp17_iter_cat_of_t<Cur>;$/;"	v	namespace:ranges::detail	typeref:struct:readable_iterator_associated_types_base using
iterator_category	include/range/v3/iterator/common_iterator.hpp	/^            using iterator_category = std::output_iterator_tag;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:std::output_iterator_tag
iterator_category	include/range/v3/iterator/concepts.hpp	/^        using iterator_category =$/;"	t	namespace:ranges::detail
iterator_category	include/range/v3/iterator/concepts.hpp	/^    using iterator_category RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:detail::iterator_category<I>
iterator_category	include/range/v3/iterator/counted_iterator.hpp	/^            using iterator_category = std::output_iterator_tag;$/;"	t	struct:ranges::_counted_iterator_::iterator_traits_	typeref:typename:std::output_iterator_tag
iterator_category	include/range/v3/iterator/move_iterators.hpp	/^        using iterator_category = std::input_iterator_tag;$/;"	t	struct:ranges::move_iterator	typeref:typename:std::input_iterator_tag
iterator_category	include/range/v3/range/conversion.hpp	/^            using iterator_category = typename std::iterator_traits<I>::iterator_category;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:std::iterator_traits<I>::iterator_category
iterator_category	include/range/v3/view/split.hpp	/^            using iterator_category = std::input_iterator_tag;$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:std::input_iterator_tag
iterator_category	include/range/v3/view/split.hpp	/^            using iterator_category =$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:if_then_t<derived_from<BaseIterCategory,std::forward_iterator_tag>,std::forward_iterator_tag,std::input_iterator_tag>
iterator_category	test/p.cpp	/^  using iterator_category = std::input_iterator_tag;$/;"	t	struct:aiterator	typeref:typename:std::input_iterator_tag	file:
iterator_category_	include/range/v3/iterator/concepts.hpp	/^        struct iterator_category_$/;"	s	namespace:ranges::detail
iterator_category_	include/range/v3/iterator/concepts.hpp	/^        struct iterator_category_<I, true>$/;"	s	namespace:ranges::detail
iterator_category_t	include/range/v3/iterator/concepts.hpp	/^    using iterator_category_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:meta::_t<detail::iterator_category<I>>
iterator_concept	include/range/v3/iterator/basic_iterator.hpp	/^            using iterator_concept = cpp20_iter_cat_of_t<Cur>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:cpp20_iter_cat_of_t<Cur>
iterator_concept	include/range/v3/iterator/common_iterator.hpp	/^            using iterator_concept =$/;"	t	struct:ranges::detail::common_iterator_std_traits
iterator_concept	include/range/v3/iterator/counted_iterator.hpp	/^            using iterator_concept = ranges::contiguous_iterator_tag;$/;"	t	struct:ranges::_counted_iterator_::contiguous_iterator_concept_base	typeref:typename:ranges::contiguous_iterator_tag
iterator_concept	include/range/v3/view/split.hpp	/^            using iterator_concept = typename Outer::iterator_concept;$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:Outer::iterator_concept
iterator_concept	include/range/v3/view/split.hpp	/^            using iterator_concept =$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:if_then_t<forward_range<Base>,std::forward_iterator_tag,std::input_iterator_tag>
iterator_range	include/range/v3/iterator_range.hpp	/^        constexpr iterator_range(I first, S last)$/;"	f	struct:ranges::iterator_range
iterator_range	include/range/v3/iterator_range.hpp	/^    struct RANGES_EMPTY_BASES iterator_range$/;"	s	namespace:ranges
iterator_t	include/range/v3/range/access.hpp	/^    using iterator_t = decltype(begin(std::declval<Rng &>()));$/;"	t	namespace:ranges
iterator_t	include/range/v3/view/tokenize.hpp	/^        using iterator_t =$/;"	t	struct:ranges::tokenize_view	typeref:typename:std::regex_token_iterator<iterator_t<meta::const_if_c<Const,Rng>>>
iterator_tag_of	include/range/v3/iterator/concepts.hpp	/^    using iterator_tag_of = concepts::tag_of<$/;"	t	namespace:ranges	typeref:typename:concepts::tag_of<meta::list<contiguous_iterator_concept,random_access_iterator_concept,bidirectional_iterator_concept,forward_iterator_concept,input_iterator_concept>,T>
iterator_traits_	include/range/v3/iterator/counted_iterator.hpp	/^        struct iterator_traits_$/;"	s	namespace:ranges::_counted_iterator_
iterator_type	include/range/v3/iterator/counted_iterator.hpp	/^        using iterator_type = I;$/;"	t	struct:ranges::counted_iterator	typeref:typename:I
iterator_type	include/range/v3/iterator/move_iterators.hpp	/^        using iterator_type = I;$/;"	t	struct:ranges::move_iterator	typeref:typename:I
iterator_wrapper	include/range/v3/utility/memory.hpp	/^        iterator_wrapper(I & i)$/;"	f	struct:ranges::iterator_wrapper
iterator_wrapper	include/range/v3/utility/memory.hpp	/^        iterator_wrapper(iterator_wrapper const & that)$/;"	f	struct:ranges::iterator_wrapper
iterator_wrapper	include/range/v3/utility/memory.hpp	/^    struct iterator_wrapper$/;"	s	namespace:ranges
its_	example/calendar.cpp	/^    std::vector<iterator_t<range_value_t<Rngs>>> its_;$/;"	m	struct:interleave_view::cursor	typeref:typename:std::vector<iterator_t<range_value_t<Rngs>>>	file:
its_	include/range/v3/view/cartesian_product.hpp	/^            std::tuple<iterator_t<constify_if<Views>>...> its_;$/;"	m	struct:ranges::cartesian_product_view::cursor	typeref:typename:std::tuple<iterator_t<constify_if<Views>>...>
its_	include/range/v3/view/concat.hpp	/^            variant<iterator_t<constify_if<Rngs>>...> its_;$/;"	m	struct:ranges::concat_view::cursor	typeref:typename:variant<iterator_t<constify_if<Rngs>>...>
its_	include/range/v3/view/zip_with.hpp	/^            std::tuple<iterator_t<meta::const_if_c<Const, Rngs>>...> its_;$/;"	m	struct:ranges::iter_zip_with_view::cursor	typeref:typename:std::tuple<iterator_t<meta::const_if_c<Const,Rngs>>...>
join_action_value_t_	include/range/v3/action/join.hpp	/^        using join_action_value_t_ =$/;"	t	namespace:ranges::actions
join_base_fn	include/range/v3/view/join.hpp	/^        struct join_base_fn : cpp20_join_fn$/;"	s	namespace:ranges::views
join_cardinality	include/range/v3/view/join.hpp	/^        constexpr cardinality join_cardinality() noexcept$/;"	f	namespace:ranges::detail	typeref:typename:cardinality
join_cardinality_	include/range/v3/view/join.hpp	/^        constexpr cardinality join_cardinality_($/;"	f	namespace:ranges::detail	typeref:typename:cardinality
join_fn	include/range/v3/action/join.hpp	/^        struct join_fn$/;"	s	namespace:ranges::actions
join_fn	include/range/v3/view/join.hpp	/^        struct join_fn : join_base_fn$/;"	s	namespace:ranges::views
join_months	example/calendar.cpp	/^join_months()$/;"	f	typeref:typename:auto
join_view	include/range/v3/view/join.hpp	/^            using join_view = ranges::join_view<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::join_view<Rng>
join_view	include/range/v3/view/join.hpp	/^        explicit join_view(Rng rng)$/;"	f	struct:ranges::join_view
join_view	include/range/v3/view/join.hpp	/^    struct RANGES_EMPTY_BASES join_view$/;"	s	namespace:ranges
join_view_inner	include/range/v3/view/join.hpp	/^        using join_view_inner =$/;"	t	namespace:ranges::detail	typeref:typename:if_then_t<!std::is_reference<range_reference_t<Rng>> store_inner_<range_reference_t<>> pass_thru_inner_>
join_with_view	include/range/v3/view/join.hpp	/^        join_with_view(Rng rng, ValRng val)$/;"	f	struct:ranges::join_with_view
join_with_view	include/range/v3/view/join.hpp	/^    struct join_with_view$/;"	s	namespace:ranges
keep_	include/range/v3/iterator/common_iterator.hpp	/^            iter_value_t<I> keep_;$/;"	m	struct:ranges::common_iterator::arrow_proxy_	typeref:typename:iter_value_t<I>
keys_fn	include/range/v3/view/map.hpp	/^        struct keys_fn$/;"	s	namespace:ranges::views
lamduh	include/range/v3/action/push_back.hpp	/^            struct lamduh$/;"	s	struct:ranges::adl_push_back_detail::push_back_fn
lamduh	include/range/v3/action/push_front.hpp	/^            struct lamduh$/;"	s	struct:ranges::adl_push_front_detail::push_front_fn
lamduh	include/range/v3/action/shuffle.hpp	/^            struct lamduh$/;"	s	struct:ranges::actions::shuffle_fn
lamduh	include/range/v3/action/split.hpp	/^            struct lamduh$/;"	s	struct:ranges::actions::split_fn
lamduh	include/range/v3/view/join.hpp	/^            struct lamduh$/;"	s	struct:ranges::views::join_fn
lamduh	include/range/v3/view/sample.hpp	/^            struct lamduh$/;"	s	struct:ranges::views::sample_fn
last	include/range/v3/view/sliding.hpp	/^            last$/;"	e	enum:ranges::sliding_view_detail::cache
last	include/range/v3/view/span.hpp	/^        constexpr span<T, Count> last() const noexcept$/;"	f	struct:ranges::span	typeref:typename:span<T,Count>
last	include/range/v3/view/span.hpp	/^        constexpr span<T> last(index_type cnt) const noexcept$/;"	f	struct:ranges::span	typeref:typename:span<T>
last_	include/range/v3/view/cache1.hpp	/^            sentinel_t<Rng> last_;$/;"	m	struct:ranges::cache1_view::sentinel	typeref:typename:sentinel_t<Rng>
last_	include/range/v3/view/group_by.hpp	/^            sentinel_t<CRng> last_;$/;"	m	struct:ranges::group_by_view::cursor	typeref:typename:sentinel_t<CRng>
last_	include/range/v3/view/split_when.hpp	/^                sentinel_t<CRng> last_;$/;"	m	struct:ranges::split_when_view::cursor::search_pred	typeref:typename:sentinel_t<CRng>
last_	include/range/v3/view/split_when.hpp	/^            sentinel_t<CRng> last_;$/;"	m	struct:ranges::split_when_view::cursor	typeref:typename:sentinel_t<CRng>
last_	include/range/v3/view/subrange.hpp	/^        constexpr S & last_() noexcept$/;"	f	struct:ranges::subrange	typeref:typename:S &
last_	include/range/v3/view/subrange.hpp	/^        constexpr const S & last_() const noexcept$/;"	f	struct:ranges::subrange	typeref:typename:const S &
layout_months	example/calendar.cpp	/^layout_months()$/;"	f	typeref:typename:auto
lazy	include/meta/meta.hpp	/^    namespace lazy$/;"	n	namespace:meta
lazy_yield_if_fn	include/range/v3/view/for_each.hpp	/^    struct lazy_yield_if_fn$/;"	s	namespace:ranges
less	include/meta/meta.hpp	/^        using less = defer<less, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<less,T,U>
less	include/meta/meta.hpp	/^    using less = bool_<(T::type::value < U::type::value)>;$/;"	t	namespace:meta
less	include/range/v3/functional/comparisons.hpp	/^    struct less$/;"	s	namespace:ranges
less_equal	include/meta/meta.hpp	/^        using less_equal = defer<less_equal, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<less_equal,T,U>
less_equal	include/meta/meta.hpp	/^    using less_equal = bool_<(T::type::value <= U::type::value)>;$/;"	t	namespace:meta
less_equal	include/range/v3/functional/comparisons.hpp	/^    struct less_equal$/;"	s	namespace:ranges
linear_distribute_fn	include/range/v3/view/linear_distribute.hpp	/^        struct linear_distribute_fn$/;"	s	namespace:ranges::views
linear_distribute_view	include/range/v3/view/linear_distribute.hpp	/^            constexpr linear_distribute_view(T from, T to__, std::ptrdiff_t n) noexcept$/;"	f	struct:ranges::views::linear_distribute_view
linear_distribute_view	include/range/v3/view/linear_distribute.hpp	/^        struct linear_distribute_view : view_facade<linear_distribute_view<T>, finite>$/;"	s	namespace:ranges::views
linear_insert	include/range/v3/algorithm/sort.hpp	/^        inline void linear_insert(I first, I last, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
list_like	include/meta/meta_fwd.hpp	/^    META_CONCEPT list_like = is_v<T, list>;$/;"	v	namespace:meta	typeref:typename:META_CONCEPT
local	include/range/v3/functional/pipeable.hpp	/^                constexpr explicit local(Fun && f)$/;"	f	struct:ranges::make_pipeable_fn::operator ()::local
local	include/range/v3/functional/pipeable.hpp	/^            struct local$/;"	s	function:ranges::make_pipeable_fn::operator ()
log2	include/range/v3/algorithm/sort.hpp	/^        inline Size log2(Size n)$/;"	f	namespace:ranges::detail	typeref:typename:Size
logical_negate	include/range/v3/functional/not_fn.hpp	/^    struct logical_negate$/;"	s	namespace:ranges
lookupTree	test/main.cpp	/^static auto lookupTree = make(git_tree_lookup, git_tree_free);$/;"	v	typeref:typename:auto	file:
lower_bound_n_fn	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^        struct lower_bound_n_fn$/;"	s	namespace:ranges::aux
lower_bound_predicate	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^        struct lower_bound_predicate$/;"	s	namespace:ranges::detail
lowest	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t lowest() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
lr	include/lr.hpp	/^namespace lr {$/;"	n
main	example/accumulate_ints.cpp	/^int main()$/;"	f	typeref:typename:int
main	example/any_all_none_of.cpp	/^main()$/;"	f	typeref:typename:int
main	example/calendar.cpp	/^main()$/;"	f	typeref:typename:int
main	example/calendar.cpp	/^main(int argc, char *argv[]) try$/;"	f	typeref:typename:int
main	example/comprehension_conversion.cpp	/^int main()$/;"	f	typeref:typename:int
main	example/comprehensions.cpp	/^int main() {$/;"	f	typeref:typename:int
main	example/count.cpp	/^main()$/;"	f	typeref:typename:int
main	example/count_if.cpp	/^main()$/;"	f	typeref:typename:int
main	example/filter_transform.cpp	/^int main()$/;"	f	typeref:typename:int
main	example/find.cpp	/^main()$/;"	f	typeref:typename:int
main	example/for_each_assoc.cpp	/^main()$/;"	f	typeref:typename:int
main	example/for_each_sequence.cpp	/^main()$/;"	f	typeref:typename:int
main	example/hello.cpp	/^main()$/;"	f	typeref:typename:int
main	example/is_sorted.cpp	/^main()$/;"	f	typeref:typename:int
main	example/sort_unique.cpp	/^int main()$/;"	f	typeref:typename:int
main	test/main.cpp	/^int main() {$/;"	f	typeref:typename:int
main	test/oset.cpp	/^int main() {$/;"	f	typeref:typename:int
main	test/p.cpp	/^int main() {$/;"	f	typeref:typename:int
make	include/git.hpp	/^  make(C _c, D _d) : c(_c), d(_d) {}$/;"	f	struct:git::make
make	include/git.hpp	/^template <typename T, typename... Args> struct make {$/;"	s	namespace:git
make2	include/git.hpp	/^  make2(C _c) : c(_c) {}$/;"	f	struct:git::make2
make2	include/git.hpp	/^template <typename T, typename... Args> struct make2 {$/;"	s	namespace:git
make_action_closure_fn	include/range/v3/action/action.hpp	/^    struct make_action_closure_fn$/;"	s	namespace:ranges
make_action_fn	include/range/v3/action/action.hpp	/^        using make_action_fn RANGES_DEPRECATED($/;"	t	namespace:ranges::actions	typeref:typename:make_action_fn_
make_action_fn_	include/range/v3/action/action.hpp	/^        struct make_action_fn_$/;"	s	namespace:ranges::actions
make_common_pair	include/range/v3/utility/common_tuple.hpp	/^        using make_common_pair =$/;"	t	namespace:ranges::detail
make_common_pair_fn	include/range/v3/utility/common_tuple.hpp	/^    struct make_common_pair_fn$/;"	s	namespace:ranges
make_common_tuple	include/range/v3/utility/common_tuple.hpp	/^        using make_common_tuple =$/;"	t	namespace:ranges::detail
make_common_tuple_fn	include/range/v3/utility/common_tuple.hpp	/^    struct make_common_tuple_fn$/;"	s	namespace:ranges
make_compressed_pair_fn	include/range/v3/utility/compressed_pair.hpp	/^    struct make_compressed_pair_fn$/;"	s	namespace:ranges
make_compressed_tuple_fn	include/range/v3/utility/compressed_pair.hpp	/^    struct make_compressed_tuple_fn$/;"	s	namespace:ranges
make_counted_iterator	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto make_counted_iterator(I i, iter_difference_t<I> n)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (counted_iterator<I>)(requires input_or_output_iterator<I>)
make_empty	include/range/v3/detail/variant.hpp	/^            static variant<Ts...> make_empty(meta::id<variant<Ts...>> = {}) noexcept$/;"	f	struct:ranges::detail::variant_core_access	typeref:typename:variant<Ts...>
make_index_sequence	include/meta/meta.hpp	/^    using make_index_sequence = make_integer_sequence<std::size_t, N>;$/;"	t	namespace:meta	typeref:typename:make_integer_sequence<std::size_t,N>
make_index_sequence	include/meta/meta.hpp	/^    using make_index_sequence =$/;"	t	namespace:meta
make_indices_	include/meta/meta.hpp	/^        struct make_indices_$/;"	s	namespace:meta::detail
make_indices_	include/meta/meta.hpp	/^        struct make_indices_<0u, index_sequence<0>, indices_strategy_::done>$/;"	s	namespace:meta::detail
make_indices_	include/meta/meta.hpp	/^        struct make_indices_<End, index_sequence<Values...>, indices_strategy_::recurse>$/;"	s	namespace:meta::detail
make_indices_	include/meta/meta.hpp	/^        struct make_indices_<End, index_sequence<Values...>, indices_strategy_::repeat>$/;"	s	namespace:meta::detail
make_integer_sequence	include/meta/meta.hpp	/^    using make_integer_sequence = decltype(detail::make_integer_sequence_<T, N>());$/;"	t	namespace:meta
make_integer_sequence	include/meta/meta.hpp	/^    using make_integer_sequence =$/;"	t	namespace:meta
make_iterator_range_fn	include/range/v3/iterator_range.hpp	/^    struct make_iterator_range_fn$/;"	s	namespace:ranges
make_lower_bound_predicate	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^        lower_bound_predicate<Pred, Val> make_lower_bound_predicate(Pred & pred,$/;"	f	namespace:ranges::detail	typeref:typename:lower_bound_predicate<Pred,Val>
make_move_iterator_fn	include/range/v3/iterator/move_iterators.hpp	/^    struct make_move_iterator_fn$/;"	s	namespace:ranges
make_move_sentinel_fn	include/range/v3/iterator/move_iterators.hpp	/^    struct make_move_sentinel_fn$/;"	s	namespace:ranges
make_named	include/nt.hpp	/^constexpr StrongType<T> make_named(T const &value) {$/;"	f	namespace:nt	typeref:typename:StrongType<T>
make_ostream_joiner_fn	include/range/v3/iterator/stream_iterators.hpp	/^    struct make_ostream_joiner_fn$/;"	s	namespace:ranges
make_pipeable_fn	include/range/v3/functional/pipeable.hpp	/^    struct make_pipeable_fn$/;"	s	namespace:ranges
make_raw_buffer	include/range/v3/utility/memory.hpp	/^    raw_buffer<Val> make_raw_buffer(Val * val)$/;"	f	namespace:ranges	typeref:typename:raw_buffer<Val>
make_reverse_iterator_fn	include/range/v3/iterator/reverse_iterator.hpp	/^    struct make_reverse_iterator_fn$/;"	s	namespace:ranges
make_span	include/range/v3/view/span.hpp	/^    constexpr span<ElementType> make_span(ElementType * first,$/;"	f	namespace:ranges	typeref:typename:span<ElementType>
make_span	include/range/v3/view/span.hpp	/^    constexpr span<ElementType> make_span(ElementType * ptr,$/;"	f	namespace:ranges	typeref:typename:span<ElementType>
make_subrange_fn	include/range/v3/view/subrange.hpp	/^    struct make_subrange_fn$/;"	s	namespace:ranges
make_tagged_tuple	include/range/v3/utility/tagged_tuple.hpp	/^    constexpr tagged_tuple<Tags(bind_element_t<Ts>)...> make_tagged_tuple(Ts &&... ts)$/;"	f	namespace:ranges	typeref:typename:RANGES_DEPRECATED ("ranges::make_tagged_tuple is deprecated.")tagged_tuple<Tags (bind_element_t<Ts>)...>
make_tuple_fn	include/range/v3/utility/tuple_algorithm.hpp	/^    struct make_tuple_fn$/;"	s	namespace:ranges
make_unique	include/range/v3/utility/memory.hpp	/^        auto make_unique(Args &&... args) -> CPP_ret(std::unique_ptr<T>)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (std::unique_ptr<T>)(requires (!std::is_array<T>::value))
make_upper_bound_predicate	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^        upper_bound_predicate<Pred, Val> make_upper_bound_predicate(Pred & pred,$/;"	f	namespace:ranges::detail	typeref:typename:upper_bound_predicate<Pred,Val>
make_variant_visitor	include/range/v3/detail/variant.hpp	/^        variant_visitor<Fun, Variant> make_variant_visitor($/;"	f	namespace:ranges::detail	typeref:typename:variant_visitor<Fun,Variant>
make_view_closure_fn	include/range/v3/view/view.hpp	/^    struct make_view_closure_fn$/;"	s	namespace:ranges
make_view_fn	include/range/v3/view/view.hpp	/^        using make_view_fn RANGES_DEPRECATED($/;"	t	namespace:ranges::views	typeref:typename:make_view_fn_
make_view_fn_	include/range/v3/view/view.hpp	/^        struct make_view_fn_$/;"	s	namespace:ranges::views
makeuptr	test/oset.cpp	/^constexpr auto makeuptr(int (*c)(T **, Args...), void (*d)(T *),$/;"	f	typeref:typename:auto
mask	include/range/v3/view/any_view.hpp	/^        mask = random_access, \/\/\/<\\brief Mask away any properties other than iterator$/;"	e	enum:ranges::category
max	include/range/v3/algorithm/result_types.hpp	/^            U max;$/;"	m	struct:ranges::detail::min_max_result	typeref:typename:U
max	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t max() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
max_digits10	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int max_digits10 = 0;$/;"	m	struct:std::numeric_limits	typeref:typename:int
max_digits10	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::max_digits10;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
max_exponent	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int max_exponent = 0;$/;"	m	struct:std::numeric_limits	typeref:typename:int
max_exponent	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::max_exponent;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
max_exponent10	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int max_exponent10 = 0;$/;"	m	struct:std::numeric_limits	typeref:typename:int
max_exponent10	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::max_exponent10;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
maybe_dangling_	include/range/v3/range/dangling.hpp	/^            using maybe_dangling_ = if_then_t<forwarding_range_<R>, U, dangling>;$/;"	t	namespace:ranges::detail	typeref:typename:if_then_t<forwarding_range_<R>,U,dangling>
member_data_t	include/range/v3/range/primitives.hpp	/^            using member_data_t = detail::decay_t<decltype(std::declval<R>().data())>;$/;"	t	struct:ranges::_data_::fn
member_size_t	include/range/v3/range/primitives.hpp	/^            using member_size_t = decltype(+(std::declval<R>()).size());$/;"	t	struct:ranges::_size_::fn
merge_adaptive_fn	include/range/v3/algorithm/inplace_merge.hpp	/^        struct merge_adaptive_fn$/;"	s	namespace:ranges::detail
merge_n_fn	include/range/v3/algorithm/aux_/merge_n.hpp	/^        struct merge_n_fn$/;"	s	namespace:ranges::aux
merge_n_result	include/range/v3/algorithm/aux_/merge_n.hpp	/^        using merge_n_result = detail::in1_in2_out_result<I0, I1, O>;$/;"	t	namespace:ranges::aux	typeref:typename:detail::in1_in2_out_result<I0,I1,O>
merge_n_with_buffer_fn	include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp	/^        struct merge_n_with_buffer_fn$/;"	s	namespace:ranges::aux
merge_result	include/range/v3/algorithm/merge.hpp	/^    using merge_result = detail::in1_in2_out_result<I0, I1, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_in2_out_result<I0,I1,O>
merge_sort_chunk_size	include/range/v3/algorithm/stable_sort.hpp	/^        constexpr int merge_sort_chunk_size()$/;"	f	namespace:ranges::detail	typeref:typename:int
merge_sort_loop	include/range/v3/algorithm/stable_sort.hpp	/^        void merge_sort_loop(I1 first, I1 last, I2 result, D step_size, C & pred,$/;"	f	namespace:ranges::detail	typeref:typename:void
merge_sort_with_buffer	include/range/v3/algorithm/stable_sort.hpp	/^        void merge_sort_with_buffer(I first, I last, V * buffer, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
message	include/lr.hpp	/^  std::string message;$/;"	m	struct:lr::L	typeref:typename:std::string
meta	include/meta/meta.hpp	/^namespace meta$/;"	n
meta	include/meta/meta_fwd.hpp	/^namespace meta$/;"	n
min	include/range/v3/algorithm/result_types.hpp	/^            T min;$/;"	m	struct:ranges::detail::min_max_result	typeref:typename:T
min	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t min() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
min_exponent	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int min_exponent = 0;$/;"	m	struct:std::numeric_limits	typeref:typename:int
min_exponent	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::min_exponent;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
min_exponent10	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int min_exponent10 = 0;$/;"	m	struct:std::numeric_limits	typeref:typename:int
min_exponent10	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::min_exponent10;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
min_max_result	include/range/v3/algorithm/result_types.hpp	/^        struct min_max_result$/;"	s	namespace:ranges::detail
minmax_element_result	include/range/v3/algorithm/minmax_element.hpp	/^    using minmax_element_result = detail::min_max_result<I, I>;$/;"	t	namespace:ranges	typeref:typename:detail::min_max_result<I,I>
minmax_result	include/range/v3/algorithm/minmax.hpp	/^    using minmax_result = detail::min_max_result<T, T>;$/;"	t	namespace:ranges	typeref:typename:detail::min_max_result<T,T>
minus	include/meta/meta.hpp	/^        using minus = defer<minus, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<minus,T,U>
minus	include/meta/meta.hpp	/^    using minus = std::integral_constant<decltype(T::type::value - U::type::value),$/;"	t	namespace:meta
minus	include/range/v3/functional/arithmetic.hpp	/^    struct minus$/;"	s	namespace:ranges
mismatch_result	include/range/v3/algorithm/mismatch.hpp	/^    using mismatch_result = detail::in1_in2_result<I1, I2>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_in2_result<I1,I2>
mix_entropy	include/range/v3/utility/random.hpp	/^                auto mix_entropy(I first, S last) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:CPP_ret (void)(requires input_iterator<I> && sentinel_for<S,I> && convertible_to<iter_reference_t<I>,IntRep>)
mix_rounds	include/range/v3/utility/random.hpp	/^                static constexpr std::size_t mix_rounds = 1 + (count <= 2);$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::size_t
mixer_	include/range/v3/utility/random.hpp	/^                std::array<IntRep, count> mixer_;$/;"	m	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::array<IntRep,count>
mixin	include/range/v3/iterator/common_iterator.hpp	/^                explicit mixin(I it)$/;"	f	struct:ranges::detail::cpp17_iterator_cursor::mixin
mixin	include/range/v3/iterator/common_iterator.hpp	/^            struct mixin : basic_mixin<cpp17_iterator_cursor>$/;"	s	struct:ranges::detail::cpp17_iterator_cursor
mixin	include/range/v3/iterator/move_iterators.hpp	/^                explicit mixin(I it)$/;"	f	struct:ranges::detail::move_into_cursor::mixin
mixin	include/range/v3/iterator/move_iterators.hpp	/^            struct mixin : basic_mixin<move_into_cursor>$/;"	s	struct:ranges::detail::move_into_cursor
mixin	include/range/v3/iterator/reverse_iterator.hpp	/^                constexpr mixin(I it)$/;"	f	struct:ranges::detail::reverse_cursor::mixin
mixin	include/range/v3/iterator/reverse_iterator.hpp	/^            struct mixin : basic_mixin<reverse_cursor>$/;"	s	struct:ranges::detail::reverse_cursor
mixin	include/range/v3/view/adaptor.hpp	/^        using mixin = meta::_t<decltype(basic_adaptor_mixin_2_<Adapt>(42))>;$/;"	t	struct:ranges::adaptor_cursor
mixin_base_	include/range/v3/detail/range_access.hpp	/^        struct mixin_base_$/;"	s	struct:ranges::range_access
mixin_base_t	include/range/v3/detail/range_access.hpp	/^        using mixin_base_t = meta::_t<mixin_base_<Cur>>;$/;"	t	struct:ranges::range_access	typeref:typename:meta::_t<mixin_base_<Cur>>
mixin_t	include/range/v3/iterator/basic_iterator.hpp	/^        using mixin_t = range_access::mixin_base_t<Cur>;$/;"	t	struct:basic_iterator	typeref:typename:range_access::mixin_base_t<Cur>
mode_bidi	include/range/v3/view/drop_last.hpp	/^            using mode_bidi = mode_t<mode_enum::bidi>;$/;"	t	namespace:ranges::detail::drop_last_view	typeref:typename:mode_t<mode_enum::bidi>
mode_enum	include/range/v3/view/drop_last.hpp	/^            enum class mode_enum$/;"	g	namespace:ranges::detail::drop_last_view
mode_forward	include/range/v3/view/drop_last.hpp	/^            using mode_forward = mode_t<mode_enum::forward>;$/;"	t	namespace:ranges::detail::drop_last_view	typeref:typename:mode_t<mode_enum::forward>
mode_invalid	include/range/v3/view/drop_last.hpp	/^            using mode_invalid = mode_t<mode_enum::invalid>;$/;"	t	namespace:ranges::detail::drop_last_view	typeref:typename:mode_t<mode_enum::invalid>
mode_of	include/range/v3/view/drop_last.hpp	/^            using mode_of = mode_t<drop_last_view::get_mode<Rng>()>;$/;"	t	namespace:ranges::detail::drop_last_view
mode_sized	include/range/v3/view/drop_last.hpp	/^            using mode_sized = mode_t<mode_enum::sized>;$/;"	t	namespace:ranges::detail::drop_last_view	typeref:typename:mode_t<mode_enum::sized>
mode_t	include/range/v3/view/drop_last.hpp	/^            using mode_t = std::integral_constant<mode_enum, Mode>;$/;"	t	namespace:ranges::detail::drop_last_view	typeref:typename:std::integral_constant<mode_enum,Mode>
modulus	include/meta/meta.hpp	/^        using modulus = defer<modulus, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<modulus,T,U>
modulus	include/meta/meta.hpp	/^    using modulus = std::integral_constant<decltype(T::type::value % U::type::value),$/;"	t	namespace:meta
month_title	example/calendar.cpp	/^month_title(date d)$/;"	f	typeref:typename:std::string
movable_input_iterator	include/range/v3/action/concepts.hpp	/^        struct movable_input_iterator$/;"	s	namespace:ranges::detail
move	include/range/v3/iterator/move_iterators.hpp	/^            constexpr auto move() const noexcept(has_nothrow_iter_move_v<II>)$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:auto
move	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr iter_rvalue_reference_t<I> move() const$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:iter_rvalue_reference_t<I>
move	include/range/v3/view/adaptor.hpp	/^        auto move() const$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:auto
move	include/range/v3/view/chunk.hpp	/^                constexpr iter_rvalue_reference_t<iterator_t<Rng>> move() const$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:iter_rvalue_reference_t<iterator_t<Rng>>
move	include/range/v3/view/join.hpp	/^            rvalue_reference move() const$/;"	f	class:ranges::join_with_view::cursor	typeref:typename:rvalue_reference
move	include/range/v3/view/set_algorithm.hpp	/^            rvalue_reference_type move() const$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:rvalue_reference_type
move	include/range/v3/view/set_algorithm.hpp	/^            rvalue_reference_type move() const$/;"	f	struct:ranges::detail::set_union_cursor	typeref:typename:rvalue_reference_type
move_assign	include/range/v3/utility/semiregular_box.hpp	/^        void move_assign(T && t, std::false_type)$/;"	f	struct:ranges::semiregular_box	typeref:typename:void
move_assign	include/range/v3/utility/semiregular_box.hpp	/^        void move_assign(T && t, std::true_type)$/;"	f	struct:ranges::semiregular_box	typeref:typename:void
move_assign_layer	include/range/v3/utility/optional.hpp	/^            using move_assign_layer = meta::if_c<$/;"	t	namespace:ranges::detail::optional_adl
move_backward_result	include/range/v3/algorithm/move_backward.hpp	/^    using move_backward_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
move_construct_layer	include/range/v3/utility/optional.hpp	/^            using move_construct_layer =$/;"	t	namespace:ranges::detail::optional_adl
move_fn	include/range/v3/algorithm/move.hpp	/^    struct RANGES_EMPTY_BASES move_fn$/;"	s	namespace:ranges
move_fn	include/range/v3/utility/move.hpp	/^        struct move_fn : move_tag$/;"	s	namespace:ranges::aux
move_fn	include/range/v3/view/move.hpp	/^        struct move_fn$/;"	s	namespace:ranges::views
move_into_cursor	include/range/v3/iterator/move_iterators.hpp	/^            explicit move_into_cursor(I it)$/;"	f	struct:ranges::detail::move_into_cursor
move_into_cursor	include/range/v3/iterator/move_iterators.hpp	/^        struct move_into_cursor : move_into_cursor_types<I>$/;"	s	namespace:ranges::detail
move_into_cursor_types	include/range/v3/iterator/move_iterators.hpp	/^        using move_into_cursor_types = move_into_cursor_types_<I, (bool)readable<I>>;$/;"	t	namespace:ranges::detail
move_into_cursor_types_	include/range/v3/iterator/move_iterators.hpp	/^        struct move_into_cursor_types_$/;"	s	namespace:ranges::detail
move_into_cursor_types_	include/range/v3/iterator/move_iterators.hpp	/^        struct move_into_cursor_types_<I, true>$/;"	s	namespace:ranges::detail
move_into_fn	include/range/v3/iterator/move_iterators.hpp	/^    struct move_into_fn$/;"	s	namespace:ranges
move_iterator	include/range/v3/iterator/move_iterators.hpp	/^        explicit move_iterator(I i)$/;"	f	struct:ranges::move_iterator
move_iterator	include/range/v3/iterator/move_iterators.hpp	/^    struct move_iterator$/;"	s	namespace:ranges
move_result	include/range/v3/algorithm/move.hpp	/^    using move_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
move_sentinel	include/range/v3/iterator/move_iterators.hpp	/^        constexpr explicit move_sentinel(S s)$/;"	f	struct:ranges::move_sentinel
move_sentinel	include/range/v3/iterator/move_iterators.hpp	/^        constexpr move_sentinel()$/;"	f	struct:ranges::move_sentinel
move_sentinel	include/range/v3/iterator/move_iterators.hpp	/^    struct move_sentinel$/;"	s	namespace:ranges
move_t	include/range/v3/utility/move.hpp	/^        using move_t =$/;"	t	namespace:ranges::aux
move_view	include/range/v3/view/move.hpp	/^        explicit move_view(Rng rng)$/;"	f	struct:ranges::move_view
move_view	include/range/v3/view/move.hpp	/^    struct move_view : view_adaptor<move_view<Rng>, Rng>$/;"	s	namespace:ranges
mtx_	include/range/v3/utility/random.hpp	/^            mutable std::mutex mtx_;$/;"	m	class:ranges::detail::sync_URNG	typeref:typename:std::mutex
multiplies	include/meta/meta.hpp	/^        using multiplies = defer<multiplies, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<multiplies,T,U>
multiplies	include/meta/meta.hpp	/^    using multiplies = std::integral_constant<decltype(T::type::value * U::type::value),$/;"	t	namespace:meta
multiplies	include/range/v3/functional/arithmetic.hpp	/^    struct multiplies$/;"	s	namespace:ranges
mutable_	include/range/v3/utility/box.hpp	/^        constexpr explicit mutable_(T && t)$/;"	f	struct:ranges::mutable_
mutable_	include/range/v3/utility/box.hpp	/^        constexpr explicit mutable_(T const & t)$/;"	f	struct:ranges::mutable_
mutable_	include/range/v3/utility/box.hpp	/^    struct RANGES_DEPRECATED("The ranges::mutable_ class template is deprecated") mutable_$/;"	s	namespace:ranges
my_cardinality	include/range/v3/view/cartesian_product.hpp	/^        static constexpr auto my_cardinality =$/;"	m	struct:ranges::cartesian_product_view	typeref:typename:auto
my_cardinality	include/range/v3/view/transform.hpp	/^        static constexpr cardinality my_cardinality = detail::transform2_cardinality($/;"	m	struct:ranges::iter_transform2_view	typeref:typename:cardinality
n	include/range/v3/view/concat.hpp	/^                difference_type n;$/;"	m	struct:ranges::concat_view::cursor::advance_fwd_fun	typeref:typename:difference_type
n	include/range/v3/view/concat.hpp	/^                difference_type n;$/;"	m	struct:ranges::concat_view::cursor::advance_rev_fun	typeref:typename:difference_type
n	include/range/v3/view/sample.hpp	/^                Size n;$/;"	m	struct:ranges::views::sample_fn::lamduh	typeref:typename:Size
n_	example/calendar.cpp	/^    std::size_t n_;$/;"	m	struct:interleave_view::cursor	typeref:typename:std::size_t	file:
n_	include/range/v3/iterator/operations.hpp	/^    constexpr void advance_fn::n_(I & i, iter_difference_t<I> n,$/;"	f	class:ranges::advance_fn	typeref:typename:void
n_	include/range/v3/view/chunk.hpp	/^            range_difference_t<CRng> n_;$/;"	m	struct:ranges::chunk_view_::adaptor	typeref:typename:range_difference_t<CRng>
n_	include/range/v3/view/chunk.hpp	/^        range_difference_t<Rng> n_ = 0;$/;"	m	struct:ranges::chunk_view_	typeref:typename:range_difference_t<Rng>
n_	include/range/v3/view/chunk.hpp	/^        range_difference_t<Rng> n_;$/;"	m	struct:ranges::chunk_view_	typeref:typename:range_difference_t<Rng>
n_	include/range/v3/view/counted.hpp	/^        iter_difference_t<I> n_;$/;"	m	struct:ranges::counted_view	typeref:typename:iter_difference_t<I>
n_	include/range/v3/view/cycle.hpp	/^            std::intmax_t n_ = 0;$/;"	m	struct:ranges::cycled_view::cursor	typeref:typename:std::intmax_t
n_	include/range/v3/view/drop.hpp	/^        difference_type_ n_;$/;"	m	struct:ranges::drop_view	typeref:typename:difference_type_
n_	include/range/v3/view/drop_exactly.hpp	/^        difference_type_ n_;$/;"	m	struct:ranges::drop_exactly_view	typeref:typename:difference_type_
n_	include/range/v3/view/drop_last.hpp	/^        difference_t n_;$/;"	m	struct:ranges::drop_last_view	typeref:typename:difference_t
n_	include/range/v3/view/generate_n.hpp	/^        std::size_t n_;$/;"	m	struct:ranges::generate_n_view	typeref:typename:std::size_t
n_	include/range/v3/view/linear_distribute.hpp	/^            std::ptrdiff_t n_;$/;"	m	struct:ranges::views::linear_distribute_view	typeref:typename:std::ptrdiff_t
n_	include/range/v3/view/repeat.hpp	/^            std::ptrdiff_t n_ = 0;$/;"	m	struct:ranges::repeat_view::cursor	typeref:typename:std::ptrdiff_t
n_	include/range/v3/view/repeat_n.hpp	/^            std::ptrdiff_t n_;$/;"	m	struct:ranges::repeat_n_view::cursor	typeref:typename:std::ptrdiff_t
n_	include/range/v3/view/repeat_n.hpp	/^        std::ptrdiff_t n_;$/;"	m	struct:ranges::repeat_n_view	typeref:typename:std::ptrdiff_t
n_	include/range/v3/view/sliding.hpp	/^            range_difference_t<Rng> n_ = 0;$/;"	m	struct:ranges::sliding_view::adaptor	typeref:typename:range_difference_t<Rng>
n_	include/range/v3/view/sliding.hpp	/^            range_difference_t<Rng> n_;$/;"	m	struct:ranges::sliding_view_detail::sv_base	typeref:typename:range_difference_t<Rng>
n_	include/range/v3/view/take_exactly.hpp	/^            range_difference_t<Rng> n_;$/;"	m	struct:ranges::detail::take_exactly_view_	typeref:typename:range_difference_t<Rng>
named_type_impl_h	include/nt.hpp	/^#define named_type_impl_h$/;"	d
narrow_cast	include/range/v3/view/span.hpp	/^        constexpr auto narrow_cast(From from) noexcept -> CPP_ret(To)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:auto
neg_	include/range/v3/iterator/diffmax_t.hpp	/^            bool neg_;$/;"	m	struct:ranges::detail::diffmax_t	typeref:typename:bool
negate	include/meta/meta.hpp	/^        using negate = defer<negate, T>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<negate,T>
negate	include/meta/meta.hpp	/^    using negate = std::integral_constant<decltype(-T::type::value), -T::type::value>;$/;"	t	namespace:meta
new_value_	include/range/v3/view/replace.hpp	/^            Val2 new_value_;$/;"	m	struct:ranges::detail::replacer_fn	typeref:typename:Val2
newtype	include/newtype.hpp	/^  constexpr newtype(U &&u) : value(std::forward<U>(u)) {}$/;"	f	struct:abo::nt::newtype
newtype	include/newtype.hpp	/^struct newtype : Skills<newtype<Tag, T, Skills...>>... {$/;"	s	namespace:abo::nt
next	example/calendar.cpp	/^    void next()$/;"	f	struct:interleave_view::cursor	typeref:typename:void	file:
next	include/range/v3/experimental/utility/generator.hpp	/^                void next()$/;"	f	struct:ranges::experimental::generator::cursor	typeref:typename:void
next	include/range/v3/iterator/common_iterator.hpp	/^            void next()$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:void
next	include/range/v3/iterator/move_iterators.hpp	/^            void next()$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:void
next	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr void next()$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:void
next	include/range/v3/view/adaptor.hpp	/^        static auto next(I & it) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::adaptor_base	typeref:typename:CPP_ret (void)(requires input_or_output_iterator<I>)
next	include/range/v3/view/adaptor.hpp	/^        void next()$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:void
next	include/range/v3/view/adjacent_filter.hpp	/^            constexpr void next(iterator_t<CRng> & it) const$/;"	f	struct:ranges::adjacent_filter_view::adaptor	typeref:typename:void
next	include/range/v3/view/adjacent_remove_if.hpp	/^            constexpr void next(iterator_t<Rng> & it) const$/;"	f	struct:ranges::adjacent_remove_if_view::adaptor	typeref:typename:void
next	include/range/v3/view/any_view.hpp	/^            virtual void next() override$/;"	f	struct:ranges::detail::any_input_view_impl	typeref:typename:void
next	include/range/v3/view/any_view.hpp	/^            void next()$/;"	f	struct:ranges::detail::any_input_cursor	typeref:typename:void
next	include/range/v3/view/cache1.hpp	/^            void next()$/;"	f	struct:ranges::cache1_view::cursor	typeref:typename:void
next	include/range/v3/view/cartesian_product.hpp	/^            void next()$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
next	include/range/v3/view/chunk.hpp	/^                constexpr void next()$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:void
next	include/range/v3/view/chunk.hpp	/^            constexpr void next()$/;"	f	struct:ranges::chunk_view_::outer_cursor	typeref:typename:void
next	include/range/v3/view/chunk.hpp	/^            constexpr void next(iterator_t<CRng> & it)$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:void
next	include/range/v3/view/concat.hpp	/^            void next()$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:void
next	include/range/v3/view/cycle.hpp	/^            void next()$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:void
next	include/range/v3/view/drop_last.hpp	/^            void next(iterator_t<Rng> & it)$/;"	f	struct:ranges::drop_last_view::adaptor	typeref:typename:void
next	include/range/v3/view/enumerate.hpp	/^                void next()$/;"	f	struct:ranges::detail::index_view::cursor	typeref:typename:void
next	include/range/v3/view/exclusive_scan.hpp	/^            void next(iterator_t<CRng> & it)$/;"	f	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:void
next	include/range/v3/view/generate.hpp	/^            void next()$/;"	f	struct:ranges::generate_view::cursor	typeref:typename:void
next	include/range/v3/view/generate_n.hpp	/^            void next()$/;"	f	struct:ranges::generate_n_view::cursor	typeref:typename:void
next	include/range/v3/view/getlines.hpp	/^            void next()$/;"	f	struct:ranges::getlines_view::cursor	typeref:typename:void
next	include/range/v3/view/getlines.hpp	/^        void next()$/;"	f	struct:ranges::getlines_view	typeref:typename:void
next	include/range/v3/view/group_by.hpp	/^            void next()$/;"	f	struct:ranges::group_by_view::cursor	typeref:typename:void
next	include/range/v3/view/intersperse.hpp	/^            constexpr void next(iterator_t<CRng> & it)$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:void
next	include/range/v3/view/iota.hpp	/^            void next()$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:void
next	include/range/v3/view/iota.hpp	/^            void next()$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:void
next	include/range/v3/view/istream.hpp	/^            void next()$/;"	f	struct:ranges::istream_view::cursor	typeref:typename:void
next	include/range/v3/view/istream.hpp	/^        void next()$/;"	f	struct:ranges::istream_view	typeref:typename:void
next	include/range/v3/view/join.hpp	/^            constexpr void next()$/;"	f	struct:ranges::join_view::cursor	typeref:typename:void
next	include/range/v3/view/join.hpp	/^            void next()$/;"	f	class:ranges::join_with_view::cursor	typeref:typename:void
next	include/range/v3/view/linear_distribute.hpp	/^            constexpr void next() noexcept$/;"	f	struct:ranges::views::linear_distribute_view	typeref:typename:void
next	include/range/v3/view/partial_sum.hpp	/^            constexpr void next()$/;"	f	struct:ranges::partial_sum_view::cursor	typeref:typename:void
next	include/range/v3/view/remove_if.hpp	/^            constexpr void next(iterator_t<Rng> & it) const$/;"	f	struct:ranges::remove_if_view::adaptor	typeref:typename:void
next	include/range/v3/view/repeat.hpp	/^            void next()$/;"	f	struct:ranges::repeat_view::cursor	typeref:typename:void
next	include/range/v3/view/repeat_n.hpp	/^            void next()$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:void
next	include/range/v3/view/sample.hpp	/^            void next()$/;"	f	class:ranges::sample_view::cursor	typeref:typename:void
next	include/range/v3/view/set_algorithm.hpp	/^            void next()$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:void
next	include/range/v3/view/set_algorithm.hpp	/^            void next()$/;"	f	struct:ranges::detail::set_union_cursor	typeref:typename:void
next	include/range/v3/view/sliding.hpp	/^            void next()$/;"	f	struct:ranges::sliding_view_detail::trailing	typeref:typename:void
next	include/range/v3/view/sliding.hpp	/^            void next(iterator_t<Rng> & it)$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:void
next	include/range/v3/view/split_when.hpp	/^            void next()$/;"	f	struct:ranges::split_when_view::cursor	typeref:typename:void
next	include/range/v3/view/stride.hpp	/^            constexpr void next(iterator_t<CRng> & it)$/;"	f	struct:ranges::stride_view::adaptor	typeref:typename:void
next	include/range/v3/view/subrange.hpp	/^        constexpr subrange next(iter_difference_t<I> n = 1) const$/;"	f	struct:ranges::subrange	typeref:typename:RANGES_NODISCARD subrange
next_	include/range/v3/view/cartesian_product.hpp	/^            void next_(meta::size_t<1>)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
next_	include/range/v3/view/cartesian_product.hpp	/^            void next_(meta::size_t<N>)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
next_fn	include/range/v3/iterator/operations.hpp	/^    struct next_fn$/;"	s	namespace:ranges
next_fun	include/range/v3/view/concat.hpp	/^            struct next_fun$/;"	s	struct:ranges::concat_view::cursor
next_to_if	include/range/v3/algorithm/find_end.hpp	/^        auto next_to_if(I i, S s) -> CPP_ret(meta::if_c<B, I, S>)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (meta::if_c<B,I,S>)(requires input_iterator<I> && sentinel_for<S,I>)
next_to_if	include/range/v3/algorithm/find_end.hpp	/^        auto next_to_if(I i, S s, std::true_type) -> CPP_ret(I)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (I)(requires input_iterator<I> && sentinel_for<S,I>)
next_to_if	include/range/v3/algorithm/find_end.hpp	/^        auto next_to_if(I, S s, std::false_type) -> CPP_ret(S)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (S)(requires input_iterator<I> && sentinel_for<S,I>)
nil_	include/meta/meta.hpp	/^    struct nil_$/;"	s	namespace:meta
nil_	include/std/detail/associated_types.hpp	/^        struct nil_$/;"	s	namespace:ranges::detail
non_member_size_t	include/range/v3/range/primitives.hpp	/^            using non_member_size_t = decltype(+size(std::declval<R>()));$/;"	t	struct:ranges::_size_::fn
non_propagating_cache	include/range/v3/utility/optional.hpp	/^            constexpr non_propagating_cache(non_propagating_cache && that) noexcept$/;"	f	struct:ranges::detail::non_propagating_cache
non_propagating_cache	include/range/v3/utility/optional.hpp	/^            constexpr non_propagating_cache(non_propagating_cache const &) noexcept$/;"	f	struct:ranges::detail::non_propagating_cache
non_propagating_cache	include/range/v3/utility/optional.hpp	/^            constexpr non_propagating_cache(nullopt_t) noexcept$/;"	f	struct:ranges::detail::non_propagating_cache
non_propagating_cache	include/range/v3/utility/optional.hpp	/^        struct non_propagating_cache : optional<T>$/;"	s	namespace:ranges::detail
non_propagating_cache	include/range/v3/utility/optional.hpp	/^        struct non_propagating_cache<T, Tag, false>$/;"	s	namespace:ranges::detail
none	include/range/v3/utility/box.hpp	/^            none, \/\/ Nothing special: get() returns a reference to a T member subobject$/;"	e	enum:ranges::detail::box_compress
none	include/range/v3/view/any_view.hpp	/^        none = 0,             \/\/\/<\\brief No concepts met.$/;"	e	enum:ranges::category
none	include/range/v3/view/sliding.hpp	/^            none,$/;"	e	enum:ranges::sliding_view_detail::cache
nope	include/concepts/swap.hpp	/^        struct nope$/;"	s	namespace:concepts::adl_swap_detail
nope	include/range/v3/iterator/access.hpp	/^        struct nope$/;"	s	namespace:ranges::_iter_swap_
not_	include/concepts/concepts.hpp	/^        struct not_ : boolean$/;"	s	namespace:concepts::detail
not_equal_to	include/meta/meta.hpp	/^        using not_equal_to = defer<not_equal_to, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<not_equal_to,T,U>
not_equal_to	include/meta/meta.hpp	/^    using not_equal_to = bool_<T::type::value != U::type::value>;$/;"	t	namespace:meta	typeref:typename:bool_<T::type::value!=U::type::value>
not_equal_to	include/range/v3/functional/comparisons.hpp	/^    struct not_equal_to$/;"	s	namespace:ranges
not_fn_fn	include/range/v3/functional/not_fn.hpp	/^    struct not_fn_fn$/;"	s	namespace:ranges
nothrow_copy_t	include/range/v3/utility/scope_exit.hpp	/^        using nothrow_copy_t = std::is_nothrow_copy_constructible<Fun>;$/;"	t	struct:ranges::scope_exit	typeref:typename:std::is_nothrow_copy_constructible<Fun>
nothrow_move_t	include/range/v3/utility/scope_exit.hpp	/^        using nothrow_move_t = std::is_nothrow_move_constructible<Fun>;$/;"	t	struct:ranges::scope_exit	typeref:typename:std::is_nothrow_move_constructible<Fun>
nt	include/newtype.hpp	/^namespace abo::nt {$/;"	n	namespace:abo
nt	include/nt.hpp	/^namespace nt {$/;"	n
nt	include/ntskills.hpp	/^namespace nt {$/;"	n
nullopt	include/range/v3/utility/optional.hpp	/^            static constexpr nullopt_t nullopt{nullopt_t::tag{}};$/;"	m	struct:ranges::detail::nullopt_holder	typeref:typename:nullopt_t
nullopt	include/range/v3/utility/optional.hpp	/^        constexpr auto & nullopt = detail::nullopt_holder<void>::nullopt;$/;"	v	namespace:ranges::__anon8c726b6b0110	typeref:typename:auto &
nullopt	include/range/v3/utility/optional.hpp	/^        constexpr nullopt_t nullopt_holder<T>::nullopt;$/;"	m	class:ranges::detail::nullopt_holder<T>	typeref:typename:nullopt_t
nullopt	include/range/v3/utility/optional.hpp	/^    inline constexpr nullopt_t nullopt{nullopt_t::tag{}};$/;"	v	namespace:ranges	typeref:typename:nullopt_t
nullopt_holder	include/range/v3/utility/optional.hpp	/^        struct nullopt_holder$/;"	s	namespace:ranges::detail
nullopt_t	include/range/v3/utility/optional.hpp	/^        explicit constexpr nullopt_t(tag) noexcept$/;"	f	struct:ranges::nullopt_t
nullopt_t	include/range/v3/utility/optional.hpp	/^    struct nullopt_t$/;"	s	namespace:ranges
nullptr_	include/range/v3/range/concepts.hpp	/^        constexpr T const * nullptr_(int)$/;"	f	namespace:ranges::detail	typeref:typename:T const *
nullptr_	include/range/v3/range/concepts.hpp	/^        constexpr int nullptr_(long)$/;"	f	namespace:ranges::detail	typeref:typename:int
nullptr_v	include/meta/meta.hpp	/^        META_INLINE_VAR constexpr T *nullptr_v = nullptr;$/;"	v	namespace:meta::detail	typeref:typename:META_INLINE_VAR T *
nullptr_v	include/range/v3/utility/nullptr_v.hpp	/^    constexpr T * nullptr_v = nullptr;$/;"	v	namespace:ranges	typeref:typename:T *
numeric_limits	include/range/v3/iterator/diffmax_t.hpp	/^    struct numeric_limits<::ranges::detail::diffmax_t const volatile>$/;"	s	namespace:std
numeric_limits	include/range/v3/iterator/diffmax_t.hpp	/^    struct numeric_limits<::ranges::detail::diffmax_t const>$/;"	s	namespace:std
numeric_limits	include/range/v3/iterator/diffmax_t.hpp	/^    struct numeric_limits<::ranges::detail::diffmax_t volatile>$/;"	s	namespace:std
numeric_limits	include/range/v3/iterator/diffmax_t.hpp	/^    struct numeric_limits<::ranges::detail::diffmax_t>$/;"	s	namespace:std
obj	include/range/v3/utility/any.hpp	/^            T obj;$/;"	m	struct:ranges::any::impl	typeref:typename:T
obj_	include/range/v3/view/any_view.hpp	/^            void const volatile * obj_ = nullptr;$/;"	m	struct:ranges::detail::any_ref	typeref:typename:void const volatile *
obj_	include/range/v3/view/istream.hpp	/^        semiregular_box_t<Val> obj_;$/;"	m	struct:ranges::istream_view	typeref:typename:semiregular_box_t<Val>
offset	include/range/v3/view/chunk.hpp	/^            constexpr offset_t<Const> & offset()$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:offset_t<Const> &
offset	include/range/v3/view/chunk.hpp	/^            constexpr offset_t<Const> const & offset() const$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:offset_t<Const> const &
offset_	include/range/v3/view/stride.hpp	/^            range_difference_t<Rng> offset_ = -1;$/;"	m	struct:ranges::detail::stride_view_base_	typeref:typename:range_difference_t<Rng>
offset_t	include/range/v3/view/chunk.hpp	/^        using offset_t =$/;"	t	struct:ranges::chunk_view_
oidFromStr	test/main.cpp	/^static auto oidFromStr = make2(git_oid_fromstr);$/;"	v	typeref:typename:auto	file:
old_action_	include/range/v3/action/action.hpp	/^            constexpr explicit old_action_(Action a) noexcept($/;"	f	struct:ranges::actions::old_action_
old_action_	include/range/v3/action/action.hpp	/^        struct old_action_ : pipeable_base$/;"	s	namespace:ranges::actions
old_value_	include/range/v3/view/replace.hpp	/^            Val1 old_value_;$/;"	m	struct:ranges::detail::replacer_fn	typeref:typename:Val1
old_view_	include/range/v3/view/view.hpp	/^            constexpr explicit old_view_(ViewFn a) noexcept($/;"	f	struct:ranges::views::old_view_
old_view_	include/range/v3/view/view.hpp	/^        struct old_view_ : pipeable_base$/;"	s	namespace:ranges::views
on_fn	include/range/v3/functional/on.hpp	/^    struct on_fn$/;"	s	namespace:ranges
openRepository	test/main.cpp	/^static auto openRepository = make(git_repository_open, git_repository_free);$/;"	v	typeref:typename:auto	file:
operator !	include/concepts/concepts.hpp	/^            constexpr T operator!() const noexcept$/;"	f	struct:concepts::detail::not_	typeref:typename:T
operator !	include/concepts/concepts.hpp	/^            constexpr not_<and_> operator!() const noexcept$/;"	f	struct:concepts::detail::and_	typeref:typename:not_<and_>
operator !	include/range/v3/iterator/diffmax_t.hpp	/^            constexpr bool operator!() const noexcept$/;"	f	struct:ranges::detail::diffmax_t	typeref:typename:bool
operator !=	include/ntskills.hpp	/^  bool operator!=(T const &other) const { return !(*this == other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator !=	include/range/v3/detail/variant.hpp	/^    auto operator!=(variant<Ts...> const & lhs, variant<Us...> const & rhs)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires and_v<equality_comparable_with<Ts,Us>...>)
operator !=	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator!=(basic_proxy_reference_<Cur, IsReadable> const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (bool)(requires readable_cursor<Cur> && equality_comparable<cursor_value_t<Cur>>)
operator !=	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator!=(cursor_value_t<Cur> const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (bool)(requires readable_cursor<Cur> && equality_comparable<cursor_value_t<Cur>>)
operator !=	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator!=(S const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sentinel_for_cursor<S,Cur>)
operator !=	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator!=(basic_iterator<Cur> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sentinel_for_cursor<Cur2,Cur>)
operator !=	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator!=(basic_iterator<Cur> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sentinel_for_cursor<S,Cur>)
operator !=	include/range/v3/iterator/common_iterator.hpp	/^    auto operator!=(common_iterator<I1, S1> const & x, common_iterator<I2, S2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires sentinel_for<S1,I2> && sentinel_for<S2,I1>)
operator !=	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator!=(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires common_with<I1,I2>)
operator !=	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr bool operator!=(counted_iterator<I> const & x, default_sentinel_t y)$/;"	f	namespace:ranges	typeref:typename:bool
operator !=	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr bool operator!=(default_sentinel_t x, counted_iterator<I> const & y)$/;"	f	namespace:ranges	typeref:typename:bool
operator !=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr bool operator!=(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator !=	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator!=(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires equality_comparable_with<I,I2>)
operator !=	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator!=(move_iterator<I> const & i, move_sentinel const & s)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires sentinel_for<S,I>)
operator !=	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator!=(move_sentinel const & s, move_iterator<I> const & i)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires sentinel_for<S,I>)
operator !=	include/range/v3/iterator/unreachable_sentinel.hpp	/^        friend constexpr auto operator!=(I const &, unreachable_sentinel_t) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator !=	include/range/v3/iterator/unreachable_sentinel.hpp	/^        friend constexpr auto operator!=(unreachable_sentinel_t, I const &) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator !=	include/range/v3/range/conversion.hpp	/^            friend bool operator!=(to_container_iterator const & a,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator !=	include/range/v3/utility/infinity.hpp	/^        friend constexpr auto operator!=(Integer, infinity) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator !=	include/range/v3/utility/infinity.hpp	/^        friend constexpr auto operator!=(infinity, Integer) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator !=	include/range/v3/utility/infinity.hpp	/^        friend constexpr bool operator!=(infinity, infinity)$/;"	f	namespace:ranges	typeref:typename:bool
operator !=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator!=(T const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator !=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator!=(optional<T> const & x, U const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator !=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator!=(optional<T> const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator !=	include/range/v3/utility/optional.hpp	/^            constexpr bool operator!=(nullopt_t, optional<T> const & x) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator !=	include/range/v3/utility/optional.hpp	/^            constexpr bool operator!=(optional<T> const & x, nullopt_t) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator !=	include/range/v3/view/span.hpp	/^        auto operator!=(span<U, M> const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::span	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<T,U>)
operator !=	include/range/v3/view/split.hpp	/^            friend constexpr auto operator!=(split_inner_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (bool)(requires forward_range<Base>)
operator !=	include/range/v3/view/split.hpp	/^            friend constexpr auto operator!=(split_outer_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (bool)(requires forward_range<Base>)
operator !=	include/range/v3/view/split.hpp	/^            friend constexpr bool operator!=(default_sentinel_t,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator !=	include/range/v3/view/split.hpp	/^            friend constexpr bool operator!=(split_inner_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator !=	include/range/v3/view/split.hpp	/^            friend constexpr bool operator!=(split_outer_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator !=	include/range/v3/view/take.hpp	/^            friend constexpr bool operator!=(CI const & y, sentinel const & x)$/;"	f	struct:ranges::take_view	typeref:typename:bool
operator !=	include/range/v3/view/take.hpp	/^            friend constexpr bool operator!=(sentinel const & x, CI const & y)$/;"	f	struct:ranges::take_view	typeref:typename:bool
operator %	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator%(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator %=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator%=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator %=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator%=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator &	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator&(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator &	include/range/v3/view/any_view.hpp	/^    constexpr category operator&(category lhs, category rhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category
operator &&	include/concepts/concepts.hpp	/^            constexpr and_<not_, That> operator&&(That) const noexcept$/;"	f	struct:concepts::detail::not_	typeref:typename:and_<not_,That>
operator &&	include/concepts/concepts.hpp	/^            constexpr detail::and_<and_, That> operator&&(That) const noexcept$/;"	f	struct:concepts::detail::and_	typeref:typename:detail::and_<and_,That>
operator &=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator&=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator &=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator&=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator &=	include/range/v3/view/any_view.hpp	/^    constexpr category & operator&=(category & lhs, category rhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category &
operator ()	include/concepts/concepts.hpp	/^            constexpr std::true_type operator()(Nil) const noexcept$/;"	f	struct:concepts::detail::CPP_true_t	typeref:typename:std::true_type
operator ()	include/concepts/concepts.hpp	/^            constexpr std::true_type operator()(xNil) const noexcept$/;"	f	struct:concepts::detail::CPP_true_t	typeref:typename:std::true_type
operator ()	include/concepts/swap.hpp	/^            operator()(T &&t, U &&u) const$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:CPP_CXX14_CONSTEXPR meta::if_c<is_adl_swappable_v<T,U>>
operator ()	include/concepts/swap.hpp	/^            operator()(T &a, T &b) const$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:CPP_CXX14_CONSTEXPR meta::if_c<!is_adl_swappable_v<T &> && detail::is_movable_v<T>>
operator ()	include/concepts/swap.hpp	/^            operator()(T (&t)[N], U (&u)[N]) const$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:CPP_CXX14_CONSTEXPR meta::if_c<!is_adl_swappable_v<T (&)[N],U (&)[N]> && is_swappable_with<T &,U &>::value>
operator ()	include/concepts/swap.hpp	/^            operator()(std::pair<F0, S0> &&left, std::pair<F1, S1> &&right) const$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:CPP_CXX14_CONSTEXPR meta::if_c<is_swappable_with<F0,F1>::value && is_swappable_with<S0,S1>::value>
operator ()	include/concepts/swap.hpp	/^            operator()(std::tuple<Ts...> &&left, std::tuple<Us...> &&right) const$/;"	f	struct:concepts::adl_swap_detail::swap_fn	typeref:typename:CPP_CXX14_CONSTEXPR meta::if_c<meta::and_c<is_swappable_with<Ts,Us>::value...>::value>
operator ()	include/git.hpp	/^  lr::LR<T> operator()(Args &&... args) const {$/;"	f	struct:git::make2	typeref:typename:lr::LR<T>
operator ()	include/git.hpp	/^  lr::LR<UPtr<T>> operator()(Args &&... args) const {$/;"	f	struct:git::make	typeref:typename:lr::LR<UPtr<T>>
operator ()	include/git.hpp	/^  template <typename Pith> LR<git_oid> operator()(Pith &&pith) const {$/;"	f	struct:git::TreeBark	typeref:typename:LR<git_oid>
operator ()	include/git_.hpp	/^  LR<TreeSha> operator()(const Repo &) const {$/;"	f	struct:abo::Bark	typeref:typename:LR<TreeSha>
operator ()	include/range/v3/action/action.hpp	/^            auto operator()(Rng & rng, Rest &&... rest) const$/;"	f	struct:ranges::actions::old_action_	typeref:typename:CPP_ret (invoke_result_t<Action const &,Rng &,Rest...>)(requires range<Rng> && invocable<Action const &,Rng &,Rest...>)
operator ()	include/range/v3/action/action.hpp	/^            constexpr old_action_<Fun> operator()(Fun fun) const$/;"	f	struct:ranges::actions::make_action_fn_	typeref:typename:old_action_<Fun>
operator ()	include/range/v3/action/action.hpp	/^        constexpr actions::action_closure<Fun> operator()(Fun fun) const$/;"	f	struct:ranges::make_action_closure_fn	typeref:typename:actions::action_closure<Fun>
operator ()	include/range/v3/action/adjacent_remove_if.hpp	/^            auto operator()(Rng && rng, Pred pred, Proj proj = {}) const$/;"	f	struct:ranges::actions::adjacent_remove_if_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng,iterator_t<Rng>,sentinel_t<Rng>> && indirect_relation<Pred,projected<iterator_t<Rng>,Proj>> && permutable<iterator_t<Rng>>)
operator ()	include/range/v3/action/drop.hpp	/^            auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::actions::drop_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,iterator_t<Rng>,iterator_t<Rng>>)
operator ()	include/range/v3/action/drop_while.hpp	/^            auto operator()(Rng && rng, Fun fun) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::drop_while_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && indirect_unary_predicate<Fun,iterator_t<Rng>> && erasable_range<Rng &,iterator_t<Rng>,iterator_t<Rng>>)
operator ()	include/range/v3/action/erase.hpp	/^            auto operator()(Rng && rng, I first, S last) const$/;"	f	struct:ranges::adl_erase_detail::erase_fn	typeref:typename:CPP_ret (decltype (erase ((Rng &&)rng,first,last)))(requires range<Rng> && forward_iterator<I> && sentinel_for<S,I>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, I i, S j) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,I,S>)(requires range<Rng> && sentinel_for<S,I> && (!range<S>))
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, I p, N n, T && t) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,I,N,T>)(requires range<Rng> && input_iterator<I> && integral<N> && (!range<T>)&& constructible_from<range_value_t<Rng>,T>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, I p, Rng2 && rng2) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,I,Rng2>)(requires range<Rng> && input_iterator<I> && range<Rng2>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, I p, T && t) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,I,T>)(requires range<Rng> && input_iterator<I> && (!range<T>)&& constructible_from<range_value_t<Rng>,T>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, I p, std::initializer_list<T> rng2) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,I,std::initializer_list<T> &>)(requires range<Rng> && input_iterator<I>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, P p, I i, S j) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,P,I,S>)(requires range<Rng> && input_iterator<P> && sentinel_for<S,I> && (!range<S>))
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, Rng2 && rng2) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,Rng2>)(requires range<Rng> && range<Rng2>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, T && t) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,T>)(requires range<Rng> && (!range<T>)&& constructible_from<range_value_t<Rng>,T>)
operator ()	include/range/v3/action/insert.hpp	/^            auto operator()(Rng && rng, std::initializer_list<T> rng2) const$/;"	f	struct:ranges::adl_insert_detail::insert_fn	typeref:typename:CPP_ret (insert_result_t<Rng,std::initializer_list<T> &>)(requires range<Rng>)
operator ()	include/range/v3/action/join.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(join_action_value_t_<Rng>)( \/\/$/;"	f	struct:ranges::actions::join_fn	typeref:typename:CPP_ret (join_action_value_t_<Rng>)(requires input_range<Rng> && input_range<range_value_t<Rng>> && semiregular<join_action_value_t_<Rng>>)
operator ()	include/range/v3/action/push_back.hpp	/^                auto operator()(Rng && rng) const$/;"	f	struct:ranges::adl_push_back_detail::push_back_fn::lamduh	typeref:typename:invoke_result_t<push_back_fn,Rng,T (&)[N]>
operator ()	include/range/v3/action/push_back.hpp	/^            auto operator()(Rng && rng, T && t) const \/\/$/;"	f	struct:ranges::adl_push_back_detail::push_back_fn	typeref:typename:CPP_ret (Rng)(requires input_range<Rng> && can_push_back_<Rng,T> && (range<T>||constructible_from<range_value_t<Rng>,T>))
operator ()	include/range/v3/action/push_back.hpp	/^            auto operator()(Rng && rng, std::initializer_list<T> t) const \/\/$/;"	f	struct:ranges::adl_push_back_detail::push_back_fn	typeref:typename:CPP_ret (Rng)(requires input_range<Rng> && can_push_back_<Rng,std::initializer_list<T>> && constructible_from<range_value_t<Rng>,T const &>)
operator ()	include/range/v3/action/push_back.hpp	/^            constexpr auto operator()(T && val) const$/;"	f	struct:ranges::adl_push_back_detail::push_back_fn	typeref:typename:auto
operator ()	include/range/v3/action/push_back.hpp	/^            constexpr auto operator()(T (&val)[N]) const$/;"	f	struct:ranges::adl_push_back_detail::push_back_fn	typeref:typename:auto
operator ()	include/range/v3/action/push_back.hpp	/^            constexpr auto operator()(std::initializer_list<T> val) const$/;"	f	struct:ranges::adl_push_back_detail::push_back_fn	typeref:typename:auto
operator ()	include/range/v3/action/push_front.hpp	/^                auto operator()(Rng && rng) const$/;"	f	struct:ranges::adl_push_front_detail::push_front_fn::lamduh	typeref:typename:invoke_result_t<push_front_fn,Rng,T (&)[N]>
operator ()	include/range/v3/action/push_front.hpp	/^            auto operator()(Rng && rng, T && t) const \/\/$/;"	f	struct:ranges::adl_push_front_detail::push_front_fn	typeref:typename:CPP_ret (Rng)(requires input_range<Rng> && can_push_front_<Rng,T> && (range<T>||constructible_from<range_value_t<Rng>,T>))
operator ()	include/range/v3/action/push_front.hpp	/^            auto operator()(Rng && rng, std::initializer_list<T> t) const \/\/$/;"	f	struct:ranges::adl_push_front_detail::push_front_fn	typeref:typename:CPP_ret (Rng)(requires input_range<Rng> && can_push_front_<Rng,std::initializer_list<T>> && constructible_from<range_value_t<Rng>,T const &>)
operator ()	include/range/v3/action/push_front.hpp	/^            constexpr auto operator()(T && val) const$/;"	f	struct:ranges::adl_push_front_detail::push_front_fn	typeref:typename:auto
operator ()	include/range/v3/action/push_front.hpp	/^            constexpr auto operator()(T (&val)[N]) const$/;"	f	struct:ranges::adl_push_front_detail::push_front_fn	typeref:typename:auto
operator ()	include/range/v3/action/push_front.hpp	/^            constexpr auto operator()(std::initializer_list<T> val) const$/;"	f	struct:ranges::adl_push_front_detail::push_front_fn	typeref:typename:auto
operator ()	include/range/v3/action/remove.hpp	/^            auto operator()(Rng && rng, V const & value, P proj = {}) const$/;"	f	struct:ranges::actions::remove_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && permutable<iterator_t<Rng>> && erasable_range<Rng,iterator_t<Rng>,sentinel_t<Rng>> && indirect_relation<equal_to,projected<iterator_t<Rng>,P>,V const * >)
operator ()	include/range/v3/action/remove.hpp	/^            constexpr auto operator()(V && value) const$/;"	f	struct:ranges::actions::remove_fn	typeref:typename:auto
operator ()	include/range/v3/action/remove_if.hpp	/^            auto operator()(Rng && rng, C pred, P proj = P{}) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::remove_if_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,iterator_t<Rng>,iterator_t<Rng>> && permutable<iterator_t<Rng>> && indirect_unary_predicate<C,projected<iterator_t<Rng>,P>>)
operator ()	include/range/v3/action/reverse.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::reverse_fn	typeref:typename:CPP_ret (Rng)(requires bidirectional_range<Rng> && permutable<iterator_t<Rng>>)
operator ()	include/range/v3/action/shuffle.hpp	/^                auto operator()(Rng && rng) const$/;"	f	struct:ranges::actions::shuffle_fn::lamduh	typeref:typename:invoke_result_t<shuffle_fn,Rng,Gen &>
operator ()	include/range/v3/action/shuffle.hpp	/^            auto operator()(Rng && rng, Gen && gen) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::shuffle_fn	typeref:typename:CPP_ret (Rng)(requires random_access_range<Rng> && permutable<iterator_t<Rng>> && uniform_random_bit_generator<std::remove_reference_t<Gen>> && convertible_to<invoke_result_t<Gen &>,range_difference_t<Rng>>)
operator ()	include/range/v3/action/slice.hpp	/^            auto operator()(Rng && rng, detail::from_end_<diff_t<Rng>> from,$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:CPP_ret (Rng)(requires bidirectional_range<Rng> && erasable_range<Rng &,I,I>)
operator ()	include/range/v3/action/slice.hpp	/^            auto operator()(Rng && rng, diff_t<Rng> from, diff_t<Rng> to) const$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,I,I>)
operator ()	include/range/v3/action/slice.hpp	/^            auto operator()(Rng && rng, diff_t<Rng> from, end_fn const &) const$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,I,I>)
operator ()	include/range/v3/action/slice.hpp	/^            auto operator()(Rng && rng, diff_t<Rng> from,$/;"	f	struct:ranges::actions::slice_fn	typeref:typename:CPP_ret (Rng)(requires bidirectional_range<Rng> && erasable_range<Rng &,I,I>)
operator ()	include/range/v3/action/sort.hpp	/^            auto operator()(Rng && rng, C pred = {}, P proj = {}) const$/;"	f	struct:ranges::actions::sort_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && sortable<iterator_t<Rng>,C,P>)
operator ()	include/range/v3/action/split.hpp	/^                constexpr auto operator()(Rng && rng)$/;"	f	struct:ranges::actions::split_fn::lamduh	typeref:typename:decltype (split_fn{}(std::declval<Rng> (),val_))
operator ()	include/range/v3/action/split.hpp	/^            auto operator()(Rng && rng, Pattern && pattern) const$/;"	f	struct:ranges::actions::split_fn	typeref:typename:CPP_ret (std::vector<split_value_t<Rng>>)(requires input_range<Rng> && viewable_range<Pattern> && forward_range<Pattern> && indirectly_comparable<iterator_t<Rng>,iterator_t<Pattern>,ranges::equal_to> && (forward_range<Rng>||detail::tiny_range<Pattern>))
operator ()	include/range/v3/action/split.hpp	/^            auto operator()(Rng && rng, range_value_t<Rng> val) const$/;"	f	struct:ranges::actions::split_fn	typeref:typename:CPP_ret (std::vector<split_value_t<Rng>>)(requires input_range<Rng> && indirectly_comparable<iterator_t<Rng>,range_value_t<Rng> const *,ranges::equal_to>)
operator ()	include/range/v3/action/split.hpp	/^            constexpr auto operator()(T && t) const$/;"	f	struct:ranges::actions::split_fn	typeref:typename:auto
operator ()	include/range/v3/action/split.hpp	/^            constexpr auto operator()(T (&val)[N]) const$/;"	f	struct:ranges::actions::split_fn	typeref:typename:auto
operator ()	include/range/v3/action/split_when.hpp	/^            auto operator()(Rng && rng, Fun fun) const                        \/\/$/;"	f	struct:ranges::actions::split_when_fn	typeref:typename:CPP_ret (std::vector<split_value_t<Rng>>)(requires forward_range<Rng> && invocable<Fun &,iterator_t<Rng>,sentinel_t<Rng>> && invocable<Fun &,iterator_t<Rng>,iterator_t<Rng>> && copy_constructible<Fun> && convertible_to<invoke_result_t<Fun &,iterator_t<Rng>,sentinel_t<Rng>>,std::pair<bool,iterator_t<Rng>>>)
operator ()	include/range/v3/action/split_when.hpp	/^            auto operator()(Rng && rng, Fun fun) const$/;"	f	struct:ranges::actions::split_when_fn	typeref:typename:CPP_ret (std::vector<split_value_t<Rng>>)(requires forward_range<Rng> && predicate<Fun const &,range_reference_t<Rng>> && copy_constructible<Fun>)
operator ()	include/range/v3/action/split_when.hpp	/^            constexpr auto operator()(Fun fun) const$/;"	f	struct:ranges::actions::split_when_fn	typeref:typename:auto
operator ()	include/range/v3/action/stable_sort.hpp	/^            auto operator()(Rng && rng, C pred = C{}, P proj = P{}) const$/;"	f	struct:ranges::actions::stable_sort_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && sortable<iterator_t<Rng>,C,P>)
operator ()	include/range/v3/action/stride.hpp	/^            auto operator()(Rng && rng, range_difference_t<Rng> const step) const$/;"	f	struct:ranges::actions::stride_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,iterator_t<Rng>,sentinel_t<Rng>> && permutable<iterator_t<Rng>>)
operator ()	include/range/v3/action/take.hpp	/^            auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::actions::take_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,iterator_t<Rng>,sentinel_t<Rng>>)
operator ()	include/range/v3/action/take_while.hpp	/^            auto operator()(Rng && rng, Fun fun) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::take_while_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,iterator_t<Rng>,sentinel_t<Rng>> && indirect_unary_predicate<Fun,iterator_t<Rng>>)
operator ()	include/range/v3/action/transform.hpp	/^            auto operator()(Rng && rng, F fun, P proj = P{}) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::transform_fn	typeref:typename:CPP_ret (Rng)(requires input_range<Rng> && copy_constructible<F> && writable<iterator_t<Rng>,indirect_result_t<F &,projected<iterator_t<Rng>,P>>>)
operator ()	include/range/v3/action/unique.hpp	/^            auto operator()(Rng && rng, C pred = C{}, P proj = P{}) const$/;"	f	struct:ranges::actions::unique_fn	typeref:typename:CPP_ret (Rng)(requires forward_range<Rng> && erasable_range<Rng &,iterator_t<Rng>,sentinel_t<Rng>> && sortable<iterator_t<Rng>,C,P>)
operator ()	include/range/v3/action/unstable_remove_if.hpp	/^            auto operator()(Rng && rng, C pred, P proj = P{}) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::actions::unstable_remove_if_fn	typeref:typename:CPP_ret (Rng)(requires bidirectional_range<Rng> && common_range<Rng> && permutable<iterator_t<Rng>> && indirect_unary_predicate<C,projected<iterator_t<Rng>,P>> && erasable_range<Rng,iterator_t<Rng>,iterator_t<Rng>>)
operator ()	include/range/v3/algorithm/aux_/equal_range_n.hpp	/^            auto operator()(I first, iter_difference_t<I> dist, V const & val,$/;"	f	struct:ranges::aux::equal_range_n_fn	typeref:typename:CPP_ret (subrange<I>)(requires forward_iterator<I> && indirect_strict_weak_order<R,V const *,projected<I,P>>)
operator ()	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^            auto operator()(I first, iter_difference_t<I> d, V const & val, C pred = C{},$/;"	f	struct:ranges::aux::lower_bound_n_fn	typeref:typename:CPP_ret (I)(requires forward_iterator<I> && indirect_strict_weak_order<C,V const *,projected<I,P>>)
operator ()	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^            bool operator()(T && t) const$/;"	f	struct:ranges::detail::lower_bound_predicate	typeref:typename:bool
operator ()	include/range/v3/algorithm/aux_/merge_n.hpp	/^            auto operator()(I0 begin0, iter_difference_t<I0> n0, I1 begin1,$/;"	f	struct:ranges::aux::merge_n_fn	typeref:typename:CPP_ret (merge_n_result<I0,I1,O>)(requires mergeable<I0,I1,O,C,P0,P1>)
operator ()	include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp	/^            auto operator()(I begin0, iter_difference_t<I> n0, I begin1,$/;"	f	struct:ranges::aux::merge_n_with_buffer_fn	typeref:typename:CPP_ret (I)(requires same_as<iter_common_reference_t<I>,iter_common_reference_t<B>> && indirectly_copyable<I,B> && mergeable<B,I,I,C,P,P>)
operator ()	include/range/v3/algorithm/aux_/partition_point_n.hpp	/^            auto operator()(I first, iter_difference_t<I> d, C pred,$/;"	f	struct:ranges::aux::partition_point_n_fn	typeref:typename:CPP_ret (I)(requires forward_iterator<I> && indirect_unary_predicate<C,projected<I,P>>)
operator ()	include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp	/^            auto operator()(I first, iter_difference_t<I> n, B buff, C r = C{},$/;"	f	struct:ranges::aux::sort_n_with_buffer_fn	typeref:typename:CPP_ret (I)(requires same_as<iter_common_reference_t<I>,iter_common_reference_t<B>> && indirectly_copyable<I,B> && mergeable<B,I,I,C,P,P>)
operator ()	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^            auto operator()(I first, iter_difference_t<I> d, V const & val, C pred = C{},$/;"	f	struct:ranges::aux::upper_bound_n_fn	typeref:typename:CPP_ret (I)(requires forward_iterator<I> && indirect_strict_weak_order<C,V const *,projected<I,P>>)
operator ()	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^            bool operator()(T && t) const$/;"	f	struct:ranges::detail::upper_bound_predicate	typeref:typename:bool
operator ()	include/range/v3/algorithm/heap_algorithm.hpp	/^            auto operator()(I const begin_, iter_difference_t<I> const n_, C pred = C{},$/;"	f	struct:ranges::detail::is_heap_until_n_fn	typeref:typename:CPP_ret (I)(requires random_access_iterator<I> && indirect_strict_weak_order<C,projected<I,P>>)
operator ()	include/range/v3/algorithm/heap_algorithm.hpp	/^            auto operator()(I first, iter_difference_t<I> len, C pred = C{},$/;"	f	struct:ranges::detail::pop_heap_n_fn	typeref:typename:CPP_ret (void)(requires random_access_iterator<I> && sortable<I,C,P>)
operator ()	include/range/v3/algorithm/heap_algorithm.hpp	/^            auto operator()(I first, iter_difference_t<I> n, C pred = C{},$/;"	f	struct:ranges::detail::is_heap_n_fn	typeref:typename:CPP_ret (bool)(requires random_access_iterator<I> && indirect_strict_weak_order<C,projected<I,P>>)
operator ()	include/range/v3/algorithm/heap_algorithm.hpp	/^            void operator()(I first, iter_difference_t<I> len, C pred = C{},$/;"	f	struct:ranges::detail::sift_up_n_fn	typeref:typename:void
operator ()	include/range/v3/algorithm/heap_algorithm.hpp	/^            void operator()(I first, iter_difference_t<I> len, I start, C pred = C{},$/;"	f	struct:ranges::detail::sift_down_n_fn	typeref:typename:void
operator ()	include/range/v3/algorithm/inplace_merge.hpp	/^            auto operator()(I first, I middle, I last, iter_difference_t<I> len1,$/;"	f	struct:ranges::detail::inplace_merge_no_buffer_fn	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I> && sortable<I,C,P>)
operator ()	include/range/v3/algorithm/inplace_merge.hpp	/^            auto operator()(I first, I middle, I last, iter_difference_t<I> len1,$/;"	f	struct:ranges::detail::merge_adaptive_fn	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I> && sortable<I,C,P>)
operator ()	include/range/v3/detail/variant.hpp	/^            [[noreturn]] meta::if_c<M != N> operator()(indexed_element<U, M>) const$/;"	f	struct:ranges::detail::get_fn	typeref:typename:[[noreturn]]meta::if_c<M!=N>
operator ()	include/range/v3/detail/variant.hpp	/^            [[noreturn]] meta::if_c<N != M> operator()($/;"	f	struct:ranges::detail::construct_fn	typeref:typename:[[noreturn]]meta::if_c<N!=M>
operator ()	include/range/v3/detail/variant.hpp	/^            decltype(auto) operator()(T && t) const noexcept$/;"	f	struct:ranges::detail::get_datum_fn	typeref:typename:decltype (auto)
operator ()	include/range/v3/detail/variant.hpp	/^            decltype(auto) operator()(T && t) const noexcept$/;"	f	struct:ranges::detail::indexed_element_fn	typeref:typename:decltype (auto)
operator ()	include/range/v3/detail/variant.hpp	/^            meta::if_<meta::not_<std::is_object<U>>> operator()($/;"	f	struct:ranges::detail::construct_fn	typeref:typename:meta::if_<meta::not_<std::is_object<U>>>
operator ()	include/range/v3/detail/variant.hpp	/^            meta::if_<std::is_object<U>> operator()($/;"	f	struct:ranges::detail::construct_fn	typeref:typename:meta::if_<std::is_object<U>>
operator ()	include/range/v3/detail/variant.hpp	/^            void operator()(T const & t) const noexcept$/;"	f	struct:ranges::detail::delete_fn	typeref:typename:void
operator ()	include/range/v3/detail/variant.hpp	/^            void operator()(indexed_element<U &&, N> t) const noexcept$/;"	f	struct:ranges::detail::get_fn	typeref:typename:void
operator ()	include/range/v3/detail/variant.hpp	/^            void operator()(indexed_element<U, N> t) const noexcept$/;"	f	struct:ranges::detail::get_fn	typeref:typename:void
operator ()	include/range/v3/detail/variant.hpp	/^            void operator()(indexed_element<void, N>) const noexcept$/;"	f	struct:ranges::detail::get_fn	typeref:typename:void
operator ()	include/range/v3/detail/with_braced_init_args.hpp	/^            constexpr auto operator()(Rng0 && rng0, std::initializer_list<V1> && rng1,$/;"	f	struct:ranges::detail::with_braced_init_args	typeref:typename:invoke_result_t<ImplFn const &,Rng0,std::initializer_list<V1>,Args...>
operator ()	include/range/v3/detail/with_braced_init_args.hpp	/^            constexpr auto operator()(std::initializer_list<V0> && rng0,$/;"	f	struct:ranges::detail::with_braced_init_args	typeref:typename:invoke_result_t<ImplFn const &,std::initializer_list<V0>,Args...>
operator ()	include/range/v3/detail/with_braced_init_args.hpp	/^            constexpr auto operator()(std::initializer_list<V0> && rng0,$/;"	f	struct:ranges::detail::with_braced_init_args	typeref:typename:invoke_result_t<ImplFn const &,std::initializer_list<V0>,std::initializer_list<V1>,Args...>
operator ()	include/range/v3/experimental/utility/generator.hpp	/^            void operator()()$/;"	f	struct:ranges::experimental::coroutine_owner	typeref:typename:void
operator ()	include/range/v3/experimental/view/shared.hpp	/^                auto operator()(Rng && rng) const                       \/\/$/;"	f	struct:ranges::experimental::views::shared_fn	typeref:typename:CPP_ret (shared_view<detail::decay_t<Rng>>)(requires range<Rng> && (!viewable_range<Rng>)&& constructible_from<detail::decay_t<Rng>,Rng>)
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr T & operator()(T & t) const$/;"	f	struct:ranges::coerce	typeref:typename:T &
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr T const & operator()(T const & t) const$/;"	f	struct:ranges::coerce	typeref:typename:T const &
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr T operator()(T && t) const$/;"	f	struct:ranges::coerce	typeref:typename:T
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t * (U &&) u)$/;"	f	struct:ranges::multiplies	typeref:typename:decltype ((T &&)t * (U &&)u)
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t + (U &&) u)$/;"	f	struct:ranges::plus	typeref:typename:decltype ((T &&)t+(U &&)u)
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t - (U &&) u)$/;"	f	struct:ranges::minus	typeref:typename:decltype ((T &&)t-(U &&)u)
operator ()	include/range/v3/functional/arithmetic.hpp	/^        constexpr auto operator()(T && t, U && u) const -> decltype((T &&) t | (U &&) u)$/;"	f	struct:ranges::bitwise_or	typeref:typename:decltype ((T &&)t|(U &&)u)
operator ()	include/range/v3/functional/bind.hpp	/^        auto operator()(F && f) const -> CPP_ret(F)( \/\/$/;"	f	struct:ranges::protect_fn	typeref:typename:CPP_ret (F)(requires (!std::is_bind_expression<uncvref_t<F>>::value))
operator ()	include/range/v3/functional/bind.hpp	/^        auto operator()(F && f) const -> CPP_ret(protector<uncvref_t<F>>)( \/\/$/;"	f	struct:ranges::protect_fn	typeref:typename:CPP_ret (protector<uncvref_t<F>>)(requires std::is_bind_expression<uncvref_t<F>>::value)
operator ()	include/range/v3/functional/bind_back.hpp	/^                constexpr auto operator()(CallArgs &&... cargs) &$/;"	f	struct:ranges::detail::bind_back_fn_	typeref:typename:auto
operator ()	include/range/v3/functional/bind_back.hpp	/^                constexpr auto operator()(CallArgs &&... cargs) &&$/;"	f	struct:ranges::detail::bind_back_fn_	typeref:typename:auto
operator ()	include/range/v3/functional/bind_back.hpp	/^            constexpr auto operator()(CallArgs &&... cargs) const & noexcept($/;"	f	struct:ranges::detail::bind_back_fn_	typeref:typename:auto
operator ()	include/range/v3/functional/bind_back.hpp	/^        constexpr auto operator()(Fn && fn, Arg1 && arg1, Args &&... args) const$/;"	f	struct:ranges::bind_back_fn	typeref:typename:detail::bind_back_fn<Fn,Arg1,Args...>
operator ()	include/range/v3/functional/comparisons.hpp	/^        constexpr auto operator()(T && t, U && u) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::equal_to	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<T,U>)
operator ()	include/range/v3/functional/comparisons.hpp	/^        constexpr auto operator()(T && t, U && u) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::greater	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator ()	include/range/v3/functional/comparisons.hpp	/^        constexpr auto operator()(T && t, U && u) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::greater_equal	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator ()	include/range/v3/functional/comparisons.hpp	/^        constexpr auto operator()(T && t, U && u) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::less	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator ()	include/range/v3/functional/comparisons.hpp	/^        constexpr auto operator()(T && t, U && u) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::less_equal	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator ()	include/range/v3/functional/comparisons.hpp	/^        constexpr auto operator()(T && t, U && u) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::not_equal_to	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<T,U>)
operator ()	include/range/v3/functional/compose.hpp	/^        constexpr composed<Second, First> operator()(Second second, First first) const$/;"	f	struct:ranges::compose_fn	typeref:typename:composed<Second,First>
operator ()	include/range/v3/functional/identity.hpp	/^        constexpr T && operator()(T && t) const noexcept$/;"	f	struct:ranges::identity	typeref:typename:T &&
operator ()	include/range/v3/functional/indirect.hpp	/^        [[noreturn]] auto operator()(copy_tag, Its...) const$/;"	f	struct:ranges::indirected	typeref:typename:invoke_result_t<Fn &,iter_reference_t<Its>...>
operator ()	include/range/v3/functional/indirect.hpp	/^        constexpr indirected<Fn> operator()(Fn fn) const$/;"	f	struct:ranges::indirect_fn	typeref:typename:indirected<Fn>
operator ()	include/range/v3/functional/not_fn.hpp	/^        constexpr auto operator()(Args &&... args) & -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::logical_negate	typeref:typename:auto
operator ()	include/range/v3/functional/not_fn.hpp	/^        constexpr auto operator()(Args &&... args) && -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::logical_negate	typeref:typename:auto
operator ()	include/range/v3/functional/not_fn.hpp	/^        constexpr auto operator()(Args &&... args) const & -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::logical_negate	typeref:typename:auto
operator ()	include/range/v3/functional/not_fn.hpp	/^        constexpr auto operator()(Pred && pred) const$/;"	f	struct:ranges::not_fn_fn	typeref:typename:CPP_ret (logical_negate<detail::decay_t<Pred>>)(requires move_constructible<detail::decay_t<Pred>> && constructible_from<detail::decay_t<Pred>,Pred>)
operator ()	include/range/v3/functional/on.hpp	/^        constexpr transformed<Fn1, Fn2> operator()(Fn1 fn1, Fn2 fn2) const$/;"	f	struct:ranges::on_fn	typeref:typename:transformed<Fn1,Fn2>
operator ()	include/range/v3/functional/overload.hpp	/^        constexpr Fn operator()(Fn fn) const$/;"	f	struct:ranges::overload_fn	typeref:typename:Fn
operator ()	include/range/v3/functional/overload.hpp	/^        constexpr overloaded<Fns...> operator()(Fns... fns) const$/;"	f	struct:ranges::overload_fn	typeref:typename:overloaded<Fns...>
operator ()	include/range/v3/functional/pipeable.hpp	/^        constexpr auto operator()(Fun fun) const$/;"	f	struct:ranges::make_pipeable_fn	typeref:typename:auto
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        T & operator()(ref_view<T> t) const noexcept$/;"	f	struct:ranges::unwrap_reference_fn	typeref:typename:T &
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        T & operator()(std::reference_wrapper<T> t) const noexcept$/;"	f	struct:ranges::unwrap_reference_fn	typeref:typename:T &
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        T && operator()(T && t) const noexcept$/;"	f	struct:ranges::unwrap_reference_fn	typeref:typename:T &&
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        auto operator()(T & t) const -> CPP_ret(reference_wrapper<T>)( \/\/$/;"	f	struct:ranges::ref_fn	typeref:typename:CPP_ret (reference_wrapper<T>)(requires (!is_reference_wrapper_v<T>))
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        reference_wrapper<T> operator()(reference_wrapper<T> t) const$/;"	f	struct:ranges::ref_fn	typeref:typename:reference_wrapper<T>
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        reference_wrapper<T> operator()(std::reference_wrapper<T> t) const$/;"	f	struct:ranges::ref_fn	typeref:typename:reference_wrapper<T>
operator ()	include/range/v3/functional/reference_wrapper.hpp	/^        typename reference_wrapper<T>::reference operator()(reference_wrapper<T> t) const$/;"	f	struct:ranges::unwrap_reference_fn	typeref:typename:reference_wrapper<T>::reference
operator ()	include/range/v3/iterator/access.hpp	/^            constexpr detail::enable_if_t<is_adl_indirectly_swappable_v<T, U>> operator()($/;"	f	struct:ranges::_iter_swap_::fn	typeref:typename:detail::enable_if_t<is_adl_indirectly_swappable_v<T,U>>
operator ()	include/range/v3/iterator/access.hpp	/^            operator()(I0 && a, I1 && b) const noexcept(noexcept(ranges::swap(*a, *b)))$/;"	f	struct:ranges::_iter_swap_::fn	typeref:typename:detail::enable_if_t<!is_adl_indirectly_swappable_v<I0,I1> && is_swappable_with<iter_reference_t<I0>,iter_reference_t<I1>>::value>
operator ()	include/range/v3/iterator/access.hpp	/^            operator()(I0 && a, I1 && b) const$/;"	f	struct:ranges::_iter_swap_::fn
operator ()	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr Cur & operator()(basic_iterator<Cur> & it) const noexcept$/;"	f	struct:get_cursor_fn	typeref:typename:Cur &
operator ()	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr Cur const & operator()(basic_iterator<Cur> const & it) const noexcept$/;"	f	struct:get_cursor_fn	typeref:typename:Cur const &
operator ()	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr Cur operator()(basic_iterator<Cur> && it) const$/;"	f	struct:get_cursor_fn	typeref:typename:Cur
operator ()	include/range/v3/iterator/common_iterator.hpp	/^            void operator()(indexed_element<T, N> t) const$/;"	f	struct:ranges::common_iterator::emplace_fn	typeref:typename:void
operator ()	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto advance_fn::operator()(counted_iterator<I> & i,$/;"	f	class:ranges::advance_fn	typeref:typename:CPP_ret (void)(requires input_or_output_iterator<I>)
operator ()	include/range/v3/iterator/insert_iterators.hpp	/^        constexpr back_insert_iterator<Container> operator()(Container & x) const$/;"	f	struct:ranges::back_inserter_fn	typeref:typename:back_insert_iterator<Container>
operator ()	include/range/v3/iterator/insert_iterators.hpp	/^        constexpr front_insert_iterator<Cont> operator()(Cont & cont) const$/;"	f	struct:ranges::front_inserter_fn	typeref:typename:front_insert_iterator<Cont>
operator ()	include/range/v3/iterator/insert_iterators.hpp	/^        constexpr insert_iterator<Cont> operator()(Cont & cont,$/;"	f	struct:ranges::inserter_fn	typeref:typename:insert_iterator<Cont>
operator ()	include/range/v3/iterator/move_iterators.hpp	/^        constexpr auto operator()(I i) const -> CPP_ret(move_iterator<I>)( \/\/$/;"	f	struct:ranges::make_move_sentinel_fn	typeref:typename:CPP_ret (move_iterator<I>)(requires input_iterator<I>)
operator ()	include/range/v3/iterator/move_iterators.hpp	/^        constexpr auto operator()(I it) const -> CPP_ret(move_iterator<I>)( \/\/$/;"	f	struct:ranges::make_move_iterator_fn	typeref:typename:CPP_ret (move_iterator<I>)(requires input_iterator<I>)
operator ()	include/range/v3/iterator/move_iterators.hpp	/^        constexpr auto operator()(S s) const -> CPP_ret(move_sentinel<S>)( \/\/$/;"	f	struct:ranges::make_move_sentinel_fn	typeref:typename:CPP_ret (move_sentinel<S>)(requires semiregular<S> && (!input_iterator<S>))
operator ()	include/range/v3/iterator/move_iterators.hpp	/^        constexpr move_into_iterator<I> operator()(I it) const$/;"	f	struct:ranges::move_into_fn	typeref:typename:move_into_iterator<I>
operator ()	include/range/v3/iterator/operations.hpp	/^            constexpr auto operator()(I i) const -> decltype(uncounted((I &&) i))$/;"	f	struct:ranges::adl_uncounted_recounted_detail::uncounted_fn	typeref:typename:decltype (uncounted ((I &&)i))
operator ()	include/range/v3/iterator/operations.hpp	/^            constexpr auto operator()(I i, J j, iter_difference_t<J> n) const$/;"	f	struct:ranges::adl_uncounted_recounted_detail::recounted_fn	typeref:typename:decltype (recounted ((I &&)i,(J &&)j,n))
operator ()	include/range/v3/iterator/operations.hpp	/^        auto operator()(Rng && rng) const$/;"	f	struct:ranges::enumerate_fn	typeref:typename:CPP_ret (std::pair<range_difference_t<Rng>,iterator_t<Rng>>)(requires range<Rng>)
operator ()	include/range/v3/iterator/operations.hpp	/^        auto operator()(Rng && rng, range_difference_t<Rng> n) const -> CPP_ret(int)( \/\/$/;"	f	struct:ranges::distance_compare_fn	typeref:typename:CPP_ret (int)(requires range<Rng>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I & i, S bound) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::advance_fn	typeref:typename:CPP_ret (void)(requires sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I & i, iter_difference_t<I> n) const$/;"	f	struct:ranges::advance_fn	typeref:typename:CPP_ret (void)(requires input_or_output_iterator<I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I & i, iter_difference_t<I> n, S bound) const$/;"	f	struct:ranges::advance_fn	typeref:typename:CPP_ret (iter_difference_t<I>)(requires sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I const & first, S last) const$/;"	f	struct:ranges::iter_size_fn	typeref:typename:CPP_ret (meta::_t<std::make_unsigned<iter_difference_t<I>>>)(requires sized_sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I first, S last) const$/;"	f	struct:ranges::iter_distance_fn	typeref:typename:CPP_ret (iter_difference_t<I>)(requires input_or_output_iterator<I> && sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I first, S last) const$/;"	f	struct:ranges::iter_enumerate_fn	typeref:typename:CPP_ret (std::pair<iter_difference_t<I>,I>)(requires sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I first, S last, iter_difference_t<I> n) const$/;"	f	struct:ranges::iter_distance_compare_fn	typeref:typename:CPP_ret (int)(requires input_iterator<I> && sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it) const$/;"	f	struct:ranges::next_fn	typeref:typename:CPP_ret (I)(requires input_or_output_iterator<I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it) const$/;"	f	struct:ranges::prev_fn	typeref:typename:CPP_ret (I)(requires bidirectional_iterator<I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it, S s) const$/;"	f	struct:ranges::next_fn	typeref:typename:CPP_ret (I)(requires sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it, iter_difference_t<I> n) const$/;"	f	struct:ranges::next_fn	typeref:typename:CPP_ret (I)(requires input_or_output_iterator<I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it, iter_difference_t<I> n) const$/;"	f	struct:ranges::prev_fn	typeref:typename:CPP_ret (I)(requires bidirectional_iterator<I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it, iter_difference_t<I> n, I bound) const$/;"	f	struct:ranges::prev_fn	typeref:typename:CPP_ret (I)(requires bidirectional_iterator<I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(I it, iter_difference_t<I> n, S bound) const$/;"	f	struct:ranges::next_fn	typeref:typename:CPP_ret (I)(requires sentinel_for<S,I>)
operator ()	include/range/v3/iterator/operations.hpp	/^        constexpr auto operator()(Rng && rng) const$/;"	f	struct:ranges::distance_fn	typeref:typename:CPP_ret (range_difference_t<Rng>)(requires range<Rng>)
operator ()	include/range/v3/iterator/reverse_iterator.hpp	/^        constexpr auto operator()(I i) const -> CPP_ret(reverse_iterator<I>)( \/\/$/;"	f	struct:ranges::make_reverse_iterator_fn	typeref:typename:CPP_ret (reverse_iterator<I>)(requires bidirectional_iterator<I>)
operator ()	include/range/v3/iterator/stream_iterators.hpp	/^        auto operator()(std::basic_ostream<Char, Traits> & s, Delim && d) const$/;"	f	struct:ranges::make_ostream_joiner_fn	typeref:typename:CPP_ret (ostream_joiner<detail::decay_t<Delim>,Char,Traits>)(requires semiregular<detail::decay_t<Delim>>)
operator ()	include/range/v3/iterator_range.hpp	/^        constexpr auto operator()(I first, S last) const$/;"	f	struct:ranges::make_iterator_range_fn	typeref:typename:CPP_ret (iterator_range<I,S>)(requires sentinel_for<S,I>)
operator ()	include/range/v3/iterator_range.hpp	/^        constexpr auto operator()(I first, S last, detail::iter_size_t<I> sz) const$/;"	f	struct:ranges::make_iterator_range_fn	typeref:typename:CPP_ret (sized_iterator_range<I,S>)(requires sentinel_for<S,I>)
operator ()	include/range/v3/numeric/accumulate.hpp	/^        auto operator()(I first, S last, T init, Op op = Op{},$/;"	f	struct:ranges::accumulate_fn	typeref:typename:CPP_ret (T)(requires sentinel_for<S,I> && input_iterator<I> && indirectly_binary_invocable_<Op,T *,projected<I,P>> && assignable_from<T &,indirect_result_t<Op &,T *,projected<I,P>>>)
operator ()	include/range/v3/numeric/accumulate.hpp	/^        auto operator()(Rng && rng, T init, Op op = Op{},$/;"	f	struct:ranges::accumulate_fn	typeref:typename:CPP_ret (T)(requires input_range<Rng> && indirectly_binary_invocable_<Op,T *,projected<iterator_t<Rng>,P>> && assignable_from<T &,indirect_result_t<Op &,T *,projected<iterator_t<Rng>,P>>>)
operator ()	include/range/v3/numeric/adjacent_difference.hpp	/^        auto operator()(I first, S last, O result, BOp bop = BOp{}, P proj = P{}) const$/;"	f	struct:ranges::adjacent_difference_fn	typeref:typename:CPP_ret (adjacent_difference_result<I,O>)(requires sentinel_for<S,I> && differenceable<I,O,BOp,P>)
operator ()	include/range/v3/numeric/adjacent_difference.hpp	/^        auto operator()(I first, S last, O result, S2 end_result, BOp bop = BOp{},$/;"	f	struct:ranges::adjacent_difference_fn	typeref:typename:CPP_ret (adjacent_difference_result<I,O>)(requires sentinel_for<S,I> && sentinel_for<S2,O> && differenceable<I,O,BOp,P>)
operator ()	include/range/v3/numeric/adjacent_difference.hpp	/^        auto operator()(Rng && rng, ORef && result, BOp bop = BOp{}, P proj = P{}) const$/;"	f	struct:ranges::adjacent_difference_fn	typeref:typename:CPP_ret (adjacent_difference_result<safe_iterator_t<Rng>,O>)(requires range<Rng> && differenceable<I,O,BOp,P>)
operator ()	include/range/v3/numeric/adjacent_difference.hpp	/^        auto operator()(Rng && rng, ORng && result, BOp bop = BOp{}, P proj = P{}) const$/;"	f	struct:ranges::adjacent_difference_fn	typeref:typename:CPP_ret (adjacent_difference_result<safe_iterator_t<Rng>,safe_iterator_t<ORng>>)(requires range<Rng> && range<ORng> && differenceable<I,O,BOp,P>)
operator ()	include/range/v3/numeric/inner_product.hpp	/^        auto operator()(I1 begin1, S1 end1, I2 begin2, S2 end2, T init,$/;"	f	struct:ranges::inner_product_fn	typeref:typename:CPP_ret (T)(requires sentinel_for<S1,I1> && sentinel_for<S2,I2> && inner_product_constraints<I1,I2,T,BOp1,BOp2,P1,P2>)
operator ()	include/range/v3/numeric/inner_product.hpp	/^        auto operator()(I1 begin1, S1 end1, I2 begin2, T init, BOp1 bop1 = BOp1{},$/;"	f	struct:ranges::inner_product_fn	typeref:typename:CPP_ret (T)(requires sentinel_for<S1,I1> && inner_product_constraints<I1,I2,T,BOp1,BOp2,P1,P2>)
operator ()	include/range/v3/numeric/inner_product.hpp	/^        auto operator()(Rng1 && rng1, I2Ref && begin2, T init, BOp1 bop1 = BOp1{},$/;"	f	struct:ranges::inner_product_fn	typeref:typename:CPP_ret (T)(requires range<Rng1> && inner_product_constraints<I1,I2,T,BOp1,BOp2,P1,P2>)
operator ()	include/range/v3/numeric/inner_product.hpp	/^        auto operator()(Rng1 && rng1, Rng2 && rng2, T init, BOp1 bop1 = BOp1{},$/;"	f	struct:ranges::inner_product_fn	typeref:typename:CPP_ret (T)(requires range<Rng1> && range<Rng2> && inner_product_constraints<I1,I2,T,BOp1,BOp2,P1,P2>)
operator ()	include/range/v3/numeric/iota.hpp	/^        auto operator()(O first, S last, T val) const -> CPP_ret(O)( \/\/$/;"	f	struct:ranges::iota_fn	typeref:typename:CPP_ret (O)(requires output_iterator<O,T const &> && sentinel_for<S,O> && weakly_incrementable<T>)
operator ()	include/range/v3/numeric/iota.hpp	/^        auto operator()(Rng && rng, T val) const -> CPP_ret(safe_iterator_t<Rng>)( \/\/$/;"	f	struct:ranges::iota_fn	typeref:typename:CPP_ret (safe_iterator_t<Rng>)(requires output_range<Rng,T const &> && weakly_incrementable<T>)
operator ()	include/range/v3/numeric/partial_sum.hpp	/^            constexpr T & operator()(T && t) const noexcept$/;"	f	struct:ranges::detail::as_lvalue_fn	typeref:typename:T &
operator ()	include/range/v3/numeric/partial_sum.hpp	/^        auto operator()(I first, S last, O result, BOp bop = BOp{}, P proj = P{}) const$/;"	f	struct:ranges::partial_sum_fn	typeref:typename:CPP_ret (partial_sum_result<I,O>)(requires sentinel_for<S,I> && partial_sum_constraints<I,O,BOp,P>)
operator ()	include/range/v3/numeric/partial_sum.hpp	/^        auto operator()(I first, S1 last, O result, S2 end_result, BOp bop = BOp{},$/;"	f	struct:ranges::partial_sum_fn	typeref:typename:CPP_ret (partial_sum_result<I,O>)(requires sentinel_for<S1,I> && sentinel_for<S2,O> && partial_sum_constraints<I,O,BOp,P>)
operator ()	include/range/v3/numeric/partial_sum.hpp	/^        auto operator()(Rng && rng, ORef && result, BOp bop = BOp{}, P proj = P{}) const$/;"	f	struct:ranges::partial_sum_fn	typeref:typename:CPP_ret (partial_sum_result<safe_iterator_t<Rng>,O>)(requires range<Rng> && partial_sum_constraints<I,O,BOp,P>)
operator ()	include/range/v3/numeric/partial_sum.hpp	/^        auto operator()(Rng && rng, ORng && result, BOp bop = BOp{}, P proj = P{}) const$/;"	f	struct:ranges::partial_sum_fn	typeref:typename:CPP_ret (partial_sum_result<safe_iterator_t<Rng>,safe_iterator_t<ORng>>)(requires range<Rng> && range<ORng> && partial_sum_constraints<I,O,BOp,P>)
operator ()	include/range/v3/range/access.hpp	/^                constexpr auto operator()(R && r) const noexcept(noexcept(r.begin()))$/;"	f	struct:ranges::_begin_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^                constexpr auto operator()(R && r) const noexcept(noexcept(r.end()))$/;"	f	struct:ranges::_end_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^                constexpr auto operator()(R && r) const noexcept(noexcept(r.rbegin()))$/;"	f	struct:ranges::_rbegin_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^                constexpr auto operator()(R && r) const noexcept(noexcept(r.rend()))$/;"	f	struct:ranges::_rend_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr R * operator()(R (&array)[N]) const noexcept$/;"	f	struct:ranges::_begin_::fn	typeref:typename:R *
operator ()	include/range/v3/range/access.hpp	/^            constexpr R * operator()(R (&array)[N]) const noexcept$/;"	f	struct:ranges::_end_::fn	typeref:typename:R *
operator ()	include/range/v3/range/access.hpp	/^            constexpr _begin_::_t<detail::as_const_t<R>> operator()(R && r) const$/;"	f	struct:ranges::_cbegin_::fn	typeref:typename:_begin_::_t<detail::as_const_t<R>>
operator ()	include/range/v3/range/access.hpp	/^            constexpr _end_::_t<detail::as_const_t<R>> operator()(R && r) const$/;"	f	struct:ranges::_cend_::fn	typeref:typename:_end_::_t<detail::as_const_t<R>>
operator ()	include/range/v3/range/access.hpp	/^            constexpr _rbegin_::_t<detail::as_const_t<R>> operator()(R && r) const$/;"	f	struct:ranges::_crbegin_::fn	typeref:typename:_rbegin_::_t<detail::as_const_t<R>>
operator ()	include/range/v3/range/access.hpp	/^            constexpr _rend_::_t<detail::as_const_t<R>> operator()(R && r) const$/;"	f	struct:ranges::_crend_::fn	typeref:typename:_rend_::_t<detail::as_const_t<R>>
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(R && r) const noexcept(noexcept(begin((R &&) r)))$/;"	f	struct:ranges::_begin_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(R && r) const noexcept(noexcept(end((R &&) r)))$/;"	f	struct:ranges::_end_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(R && r) const noexcept(noexcept(rbegin((R &&) r)))$/;"	f	struct:ranges::_rbegin_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(R && r) const noexcept(noexcept(rend((R &&) r)))$/;"	f	struct:ranges::_rend_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(R && r) const$/;"	f	struct:ranges::_rbegin_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(R && r) const$/;"	f	struct:ranges::_rend_::fn::impl_	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(std::basic_string_view<CharT, Traits> r) const$/;"	f	struct:ranges::_begin_::fn	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            constexpr auto operator()(std::basic_string_view<CharT, Traits> r) const$/;"	f	struct:ranges::_end_::fn	typeref:typename:auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(ranges::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_begin_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(ranges::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_end_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(ranges::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_rbegin_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(ranges::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_rend_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(std::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_begin_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(std::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_end_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(std::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_rbegin_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/access.hpp	/^            operator()(std::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_rend_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/conversion.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(container_t<Rng>)(           \/\/$/;"	f	struct:ranges::detail::to_container::fn	typeref:typename:CPP_ret (container_t<Rng>)(requires input_range<Rng> && (bool (!defer::convertible_to_container_container<Rng,container_t<Rng>> && defer::convertible_to_container<Rng,container_t<Rng>>)))
operator ()	include/range/v3/range/conversion.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(container_t<Rng>)( \/\/$/;"	f	struct:ranges::detail::to_container::fn	typeref:typename:CPP_ret (container_t<Rng>)(requires input_range<Rng> && convertible_to_container_container<Rng,container_t<Rng>>)
operator ()	include/range/v3/range/dangling.hpp	/^        constexpr T && operator()(T && t) const noexcept$/;"	f	struct:ranges::_sanitize_fn	typeref:typename:T &&
operator ()	include/range/v3/range/operations.hpp	/^        constexpr auto operator()(Rng && rng) const -> CPP_ret(range_reference_t<Rng>)( \/\/$/;"	f	struct:ranges::back_fn	typeref:typename:CPP_ret (range_reference_t<Rng>)(requires common_range<Rng> && bidirectional_range<Rng> && forwarding_range_<Rng>)
operator ()	include/range/v3/range/operations.hpp	/^        constexpr auto operator()(Rng && rng) const -> CPP_ret(range_reference_t<Rng>)( \/\/$/;"	f	struct:ranges::front_fn	typeref:typename:CPP_ret (range_reference_t<Rng>)(requires forward_range<Rng> && forwarding_range_<Rng>)
operator ()	include/range/v3/range/operations.hpp	/^        constexpr auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::at_fn	typeref:typename:CPP_ret (range_reference_t<Rng>)(requires random_access_range<Rng> && sized_range<Rng> && forwarding_range_<Rng>)
operator ()	include/range/v3/range/operations.hpp	/^        constexpr auto operator()(Rng && rng,$/;"	f	struct:ranges::index_fn	typeref:typename:CPP_ret (range_reference_t<Rng>)(requires random_access_range<Rng> && integral<Int> && forwarding_range_<Rng>)
operator ()	include/range/v3/range/primitives.hpp	/^            constexpr _data_::_t<R const &> operator()(R const & r) const$/;"	f	struct:ranges::_cdata_::fn	typeref:typename:_data_::_t<R const &>
operator ()	include/range/v3/range/primitives.hpp	/^            constexpr _data_::_t<R const> operator()(R const && r) const$/;"	f	struct:ranges::_cdata_::fn	typeref:typename:_data_::_t<R const>
operator ()	include/range/v3/range/primitives.hpp	/^            constexpr auto operator()(R && r) const$/;"	f	struct:ranges::_data_::fn	typeref:typename:auto
operator ()	include/range/v3/range/primitives.hpp	/^            constexpr auto operator()(R && r) const$/;"	f	struct:ranges::_empty_::fn	typeref:typename:auto
operator ()	include/range/v3/range/primitives.hpp	/^            constexpr auto operator()(R && r) const$/;"	f	struct:ranges::_size_::fn	typeref:typename:auto
operator ()	include/range/v3/range/primitives.hpp	/^            constexpr charT * operator()($/;"	f	struct:ranges::_data_::fn	typeref:typename:charT *
operator ()	include/range/v3/range/primitives.hpp	/^            operator()(ranges::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_empty_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/primitives.hpp	/^            operator()(ranges::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_size_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/primitives.hpp	/^            operator()(std::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_empty_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/range/primitives.hpp	/^            operator()(std::reference_wrapper<T> ref) const$/;"	f	struct:ranges::_size_::fn	typeref:typename:RANGES_DEPRECATED ("Using a reference_wrapper as a Range is deprecated. Use views::ref ""instead.")auto
operator ()	include/range/v3/utility/common_tuple.hpp	/^            int operator()(T & t, U && u) const$/;"	f	struct:ranges::common_tuple::element_assign_	typeref:typename:int
operator ()	include/range/v3/utility/common_tuple.hpp	/^        common_pair<F, S> operator()(First && f, Second && s) const noexcept($/;"	f	struct:ranges::make_common_pair_fn	typeref:typename:common_pair<F,S>
operator ()	include/range/v3/utility/common_tuple.hpp	/^        common_tuple<bind_element_t<Args>...> operator()(Args &&... args) const noexcept($/;"	f	struct:ranges::make_common_tuple_fn	typeref:typename:common_tuple<bind_element_t<Args>...>
operator ()	include/range/v3/utility/copy.hpp	/^            constexpr auto operator()(T && t) const -> CPP_ret(detail::decay_t<T>)( \/\/$/;"	f	struct:ranges::aux::copy_fn	typeref:typename:CPP_ret (detail::decay_t<T>)(requires constructible_from<detail::decay_t<T>,T>)
operator ()	include/range/v3/utility/memory.hpp	/^            void operator()(T * p) const$/;"	f	struct:ranges::detail::return_temporary_buffer	typeref:typename:void
operator ()	include/range/v3/utility/move.hpp	/^            constexpr auto operator()(T && t) const noexcept$/;"	f	struct:ranges::aux::move_fn	typeref:typename:auto
operator ()	include/range/v3/utility/random.hpp	/^            result_type operator()()$/;"	f	class:ranges::detail::sync_URNG	typeref:typename:result_type
operator ()	include/range/v3/utility/tuple_algorithm.hpp	/^        constexpr Fun operator()(Tup && tup, Fun fun) const$/;"	f	struct:ranges::tuple_for_each_fn	typeref:typename:Fun
operator ()	include/range/v3/view/addressof.hpp	/^                constexpr V * operator()(V & value) const noexcept$/;"	f	struct:ranges::views::addressof_fn::take_address	typeref:typename:V *
operator ()	include/range/v3/view/adjacent_filter.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::adjacent_filter_fn	typeref:typename:auto
operator ()	include/range/v3/view/adjacent_filter.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const$/;"	f	struct:ranges::views::adjacent_filter_base_fn	typeref:typename:CPP_ret (adjacent_filter_view<all_t<Rng>,Pred>)(requires detail::adjacent_filter_constraints<Rng,Pred>)
operator ()	include/range/v3/view/adjacent_remove_if.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::adjacent_remove_if_fn	typeref:typename:auto
operator ()	include/range/v3/view/adjacent_remove_if.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const -> CPP_ret($/;"	f	struct:ranges::views::adjacent_remove_if_base_fn	typeref:typename:CPP_ret (adjacent_remove_if_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && forward_range<Rng> && indirect_binary_predicate_<Pred,iterator_t<Rng>,iterator_t<Rng>>)
operator ()	include/range/v3/view/all.hpp	/^            constexpr auto operator()(std::reference_wrapper<T> r) const$/;"	f	struct:ranges::views::all_fn	typeref:typename:CPP_ret (ref_view<T>)(requires range<T &>)
operator ()	include/range/v3/view/c_str.hpp	/^            auto operator()(Char (&sz)[N]) const -> CPP_ret(ranges::subrange<Char *>)( \/\/$/;"	f	struct:ranges::views::c_str_fn	typeref:typename:CPP_ret (ranges::subrange<Char * >)(requires detail::is_char_type<Char>::value)
operator ()	include/range/v3/view/c_str.hpp	/^            auto operator()(Char * sz) const volatile$/;"	f	struct:ranges::views::c_str_fn	typeref:typename:auto
operator ()	include/range/v3/view/cache1.hpp	/^            constexpr auto operator()(Rng && rng) const \/\/$/;"	f	struct:ranges::views::cache1_fn	typeref:typename:CPP_ret (cache1_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng> && constructible_from<range_value_t<Rng>,range_reference_t<Rng>>)
operator ()	include/range/v3/view/cartesian_product.hpp	/^            auto operator()(Size s, Rng && rng) const$/;"	f	struct:ranges::detail::cartesian_size_fn	typeref:typename:CPP_ret (common_type_t<Size,range_size_t<Rng>>)(requires integer_like_<Size> && sized_range<Rng> && common_with<Size,range_size_t<Rng>>)
operator ()	include/range/v3/view/cartesian_product.hpp	/^            constexpr auto operator()(Rngs &&... rngs) const$/;"	f	struct:ranges::views::cartesian_product_fn	typeref:typename:CPP_ret (cartesian_product_view<all_t<Rngs>...>)(requires (sizeof...(Rngs)!=0)&& concepts::and_v<(forward_range<Rngs> && viewable_range<Rngs>)...>)
operator ()	include/range/v3/view/cartesian_product.hpp	/^            constexpr empty_view<std::tuple<>> operator()() const noexcept$/;"	f	struct:ranges::views::cartesian_product_fn	typeref:typename:empty_view<std::tuple<>>
operator ()	include/range/v3/view/chunk.hpp	/^            constexpr auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::views::chunk_base_fn	typeref:typename:CPP_ret (chunk_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng>)
operator ()	include/range/v3/view/common.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(all_t<Rng>)( \/\/$/;"	f	struct:ranges::views::cpp20_common_fn	typeref:typename:CPP_ret (all_t<Rng>)(requires viewable_range<Rng> && common_range<Rng>)
operator ()	include/range/v3/view/common.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(common_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::common_fn	typeref:typename:CPP_ret (common_view<all_t<Rng>>)(requires viewable_range<Rng>)
operator ()	include/range/v3/view/common.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(common_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::cpp20_common_fn	typeref:typename:CPP_ret (common_view<all_t<Rng>>)(requires viewable_range<Rng> && (!common_range<Rng>))
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, 0> it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor::advance_rev_fun	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, 0> it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor::prev_fun	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, N> it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor::advance_fwd_fun	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, N> it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor::advance_rev_fun	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, N> it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor::next_fun	typeref:typename:CPP_ret (void)(requires input_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, N> it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor::prev_fun	typeref:typename:CPP_ret (void)(requires (N!=0)&& bidirectional_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^                auto operator()(indexed_element<I, cranges - 1> it) const$/;"	f	struct:ranges::concat_view::cursor::advance_fwd_fun	typeref:typename:CPP_ret (void)(requires random_access_iterator<I>)
operator ()	include/range/v3/view/concat.hpp	/^            auto operator()(Rng && rng) const \/\/$/;"	f	struct:ranges::views::concat_fn	typeref:typename:CPP_ret (all_t<Rng>)(requires viewable_range<Rng> && input_range<Rng>)
operator ()	include/range/v3/view/concat.hpp	/^            auto operator()(Rngs &&... rngs) const$/;"	f	struct:ranges::views::concat_fn	typeref:typename:CPP_ret (concat_view<all_t<Rngs>...>)(requires and_v<(viewable_range<Rngs> && input_range<Rngs>)...>)
operator ()	include/range/v3/view/const.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(const_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::const_fn	typeref:typename:CPP_ret (const_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng>)
operator ()	include/range/v3/view/counted.hpp	/^            auto operator()(I it, iter_difference_t<I> n) const$/;"	f	struct:ranges::views::counted_fn	typeref:typename:CPP_ret (counted_view<I>)(requires input_or_output_iterator<I> && (!random_access_iterator<I>))
operator ()	include/range/v3/view/counted.hpp	/^            auto operator()(I it, iter_difference_t<I> n) const$/;"	f	struct:ranges::views::counted_fn	typeref:typename:CPP_ret (subrange<I>)(requires random_access_iterator<I>)
operator ()	include/range/v3/view/counted.hpp	/^            auto operator()(I it, iter_difference_t<I> n) const$/;"	f	struct:ranges::views::cpp20_counted_fn	typeref:typename:CPP_ret (subrange<I>)(requires random_access_iterator<I>)
operator ()	include/range/v3/view/counted.hpp	/^            auto operator()(I it, iter_difference_t<I> n) const$/;"	f	struct:ranges::views::cpp20_counted_fn	typeref:typename:CPP_ret (subrange<counted_iterator<I>,default_sentinel_t>)(requires input_or_output_iterator<I> && (!random_access_iterator<I>))
operator ()	include/range/v3/view/cycle.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(cycled_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::cycle_fn	typeref:typename:CPP_ret (cycled_view<all_t<Rng>>)(requires viewable_range<Rng> && forward_range<Rng>)
operator ()	include/range/v3/view/delimit.hpp	/^            constexpr auto operator()(I_ && begin_, Val value) const$/;"	f	struct:ranges::views::delimit_base_fn	typeref:typename:CPP_ret (delimit_view<subrange<I,unreachable_sentinel_t>,Val>)(requires (!range<I_> && convertible_to<I_,I> && input_iterator<I> && semiregular<Val> && equality_comparable_with<Val,iter_reference_t<I>>))
operator ()	include/range/v3/view/delimit.hpp	/^            constexpr auto operator()(Rng && rng, Val value) const \/\/$/;"	f	struct:ranges::views::delimit_base_fn	typeref:typename:CPP_ret (delimit_view<all_t<Rng>,Val>)(requires viewable_range<Rng> && input_range<Rng> && semiregular<Val> && equality_comparable_with<Val,range_reference_t<Rng>>)
operator ()	include/range/v3/view/delimit.hpp	/^            constexpr auto operator()(Val value) const$/;"	f	struct:ranges::views::delimit_fn	typeref:typename:auto
operator ()	include/range/v3/view/drop_last.hpp	/^            constexpr auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::views::drop_last_base_fn	typeref:typename:CPP_ret (drop_last_view<all_t<Rng>>)(requires sized_range<Rng>||forward_range<Rng>)
operator ()	include/range/v3/view/drop_while.hpp	/^            auto operator()(Rng && rng, Pred pred) const$/;"	f	struct:ranges::views::drop_while_base_fn	typeref:typename:CPP_ret (drop_while_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred,iterator_t<Rng>>)
operator ()	include/range/v3/view/drop_while.hpp	/^            auto operator()(Rng && rng, Pred pred, Proj proj) const$/;"	f	struct:ranges::views::drop_while_base_fn	typeref:typename:CPP_ret (drop_while_view<all_t<Rng>,composed<Pred,Proj>>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<composed<Pred,Proj>,iterator_t<Rng>>)
operator ()	include/range/v3/view/drop_while.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::drop_while_fn	typeref:typename:auto
operator ()	include/range/v3/view/empty.hpp	/^        empty_view operator()() const$/;"	f	struct:ranges::empty_view
operator ()	include/range/v3/view/exclusive_scan.hpp	/^            constexpr auto operator()(Rng && rng, T init, Fun fun = Fun{}) const$/;"	f	struct:ranges::views::exclusive_scan_base_fn	typeref:typename:CPP_ret (exclusive_scan_view<all_t<Rng>,T,Fun>)(requires exclusive_scan_constraints<Rng,T,Fun>)
operator ()	include/range/v3/view/exclusive_scan.hpp	/^            constexpr auto operator()(T init, Fun fun = {}) const$/;"	f	struct:ranges::views::exclusive_scan_fn	typeref:typename:auto
operator ()	include/range/v3/view/filter.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::cpp20_filter_fn	typeref:typename:auto
operator ()	include/range/v3/view/filter.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::filter_fn	typeref:typename:auto
operator ()	include/range/v3/view/filter.hpp	/^            constexpr auto operator()(Pred pred, Proj proj) const$/;"	f	struct:ranges::views::filter_fn	typeref:typename:auto
operator ()	include/range/v3/view/filter.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const$/;"	f	struct:ranges::views::cpp20_filter_base_fn	typeref:typename:CPP_ret (filter_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred,iterator_t<Rng>>)
operator ()	include/range/v3/view/filter.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred, Proj proj) const$/;"	f	struct:ranges::views::filter_base_fn	typeref:typename:CPP_ret (filter_view<all_t<Rng>,composed<Pred,Proj>>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred,projected<iterator_t<Rng>,Proj>>)
operator ()	include/range/v3/view/for_each.hpp	/^            constexpr auto operator()(Fun fun) const$/;"	f	struct:ranges::views::for_each_fn	typeref:typename:auto
operator ()	include/range/v3/view/for_each.hpp	/^        auto operator()(Rng rng) const -> CPP_ret(Rng)( \/\/$/;"	f	struct:ranges::yield_from_fn	typeref:typename:CPP_ret (Rng)(requires view_<Rng>)
operator ()	include/range/v3/view/for_each.hpp	/^        auto operator()(V v) const -> CPP_ret(single_view<V>)( \/\/$/;"	f	struct:ranges::yield_fn	typeref:typename:CPP_ret (single_view<V>)(requires copy_constructible<V>)
operator ()	include/range/v3/view/for_each.hpp	/^        auto operator()(bool b, F f) const -> CPP_ret(generate_n_view<F>)( \/\/$/;"	f	struct:ranges::lazy_yield_if_fn	typeref:typename:CPP_ret (generate_n_view<F>)(requires invocable<F &>)
operator ()	include/range/v3/view/for_each.hpp	/^        repeat_n_view<V> operator()(bool b, V v) const$/;"	f	struct:ranges::yield_if_fn	typeref:typename:repeat_n_view<V>
operator ()	include/range/v3/view/generate.hpp	/^            auto operator()(G g) const -> CPP_ret(generate_view<G>)( \/\/$/;"	f	struct:ranges::views::generate_fn	typeref:typename:CPP_ret (generate_view<G>)(requires invocable<G &> && copy_constructible<G> && std::is_object<detail::decay_t<invoke_result_t<G &>>>::value && constructible_from<detail::decay_t<invoke_result_t<G &>>,invoke_result_t<G &>> && assignable_from<detail::decay_t<invoke_result_t<G &>> &,invoke_result_t<G &>>)
operator ()	include/range/v3/view/generate_n.hpp	/^            auto operator()(G g, std::size_t n) const -> CPP_ret(generate_n_view<G>)( \/\/$/;"	f	struct:ranges::views::generate_n_fn	typeref:typename:CPP_ret (generate_n_view<G>)(requires invocable<G &> && copy_constructible<G> && std::is_object<detail::decay_t<invoke_result_t<G &>>>::value && constructible_from<detail::decay_t<invoke_result_t<G &>>,invoke_result_t<G &>> && assignable_from<detail::decay_t<invoke_result_t<G &>> &,invoke_result_t<G &>>)
operator ()	include/range/v3/view/getlines.hpp	/^        getlines_view operator()(std::istream & sin, char delim = '\\n') const$/;"	f	struct:ranges::getlines_fn	typeref:typename:getlines_view
operator ()	include/range/v3/view/group_by.hpp	/^                bool operator()(range_reference_t<CRng> r) const$/;"	f	struct:ranges::group_by_view::cursor::pred	typeref:typename:bool
operator ()	include/range/v3/view/group_by.hpp	/^            constexpr auto operator()(Fun fun) const$/;"	f	struct:ranges::views::group_by_fn	typeref:typename:auto
operator ()	include/range/v3/view/group_by.hpp	/^            constexpr auto operator()(Rng && rng, Fun fun) const$/;"	f	struct:ranges::views::group_by_base_fn	typeref:typename:CPP_ret (group_by_view<all_t<Rng>,Fun>)(requires viewable_range<Rng> && forward_range<Rng> && indirect_relation<Fun,iterator_t<Rng>>)
operator ()	include/range/v3/view/indices.hpp	/^            auto operator()(Val from, Val to) const -> CPP_ret(closed_iota_view<Val>)( \/\/$/;"	f	struct:ranges::views::closed_indices_fn	typeref:typename:CPP_ret (closed_iota_view<Val>)(requires integral<Val>)
operator ()	include/range/v3/view/indices.hpp	/^            auto operator()(Val from, Val to) const -> CPP_ret(iota_view<Val, Val>)( \/\/$/;"	f	struct:ranges::views::indices_fn	typeref:typename:CPP_ret (iota_view<Val,Val>)(requires integral<Val>)
operator ()	include/range/v3/view/indices.hpp	/^            auto operator()(Val to) const -> CPP_ret(closed_iota_view<Val>)( \/\/$/;"	f	struct:ranges::views::closed_indices_fn	typeref:typename:CPP_ret (closed_iota_view<Val>)(requires integral<Val>)
operator ()	include/range/v3/view/indices.hpp	/^            auto operator()(Val to) const -> CPP_ret(iota_view<Val, Val>)( \/\/$/;"	f	struct:ranges::views::indices_fn	typeref:typename:CPP_ret (iota_view<Val,Val>)(requires integral<Val>)
operator ()	include/range/v3/view/intersperse.hpp	/^            constexpr auto operator()(Rng && rng, range_value_t<Rng> val) const$/;"	f	struct:ranges::views::intersperse_base_fn	typeref:typename:CPP_ret (intersperse_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng> && convertible_to<range_reference_t<Rng>,range_value_t<Rng>> && semiregular<range_value_t<Rng>>)
operator ()	include/range/v3/view/iota.hpp	/^            auto operator()(From from, To to) const -> CPP_ret(iota_view<From, To>)( \/\/$/;"	f	struct:ranges::views::iota_fn	typeref:typename:CPP_ret (iota_view<From,To>)(requires weakly_incrementable<From> && semiregular<To> && detail::weakly_equality_comparable_with_<From,To> && (!integral<From>||!integral<To>||std::is_signed<From>::value==std::is_signed<To>::value))
operator ()	include/range/v3/view/iota.hpp	/^            auto operator()(From from, To to) const$/;"	f	struct:ranges::views::closed_iota_fn	typeref:typename:CPP_ret (closed_iota_view<From,To>)(requires weakly_incrementable<From> && semiregular<To> && detail::weakly_equality_comparable_with_<From,To> && (!integral<From>||!integral<To>||std::is_signed<From>::value==std::is_signed<To>::value))
operator ()	include/range/v3/view/iota.hpp	/^            auto operator()(From value) const -> CPP_ret(iota_view<From>)( \/\/$/;"	f	struct:ranges::views::iota_fn	typeref:typename:CPP_ret (iota_view<From>)(requires weakly_incrementable<From>)
operator ()	include/range/v3/view/iota.hpp	/^            constexpr auto operator()(Val from, Val to) const$/;"	f	struct:ranges::views::ints_fn	typeref:typename:CPP_ret (iota_view<Val,Val>)(requires integral<Val>)
operator ()	include/range/v3/view/iota.hpp	/^            constexpr auto operator()(Val value, unreachable_sentinel_t) const$/;"	f	struct:ranges::views::ints_fn	typeref:typename:CPP_ret (iota_view<Val>)(requires integral<Val>)
operator ()	include/range/v3/view/iota.hpp	/^            operator()(Val value) const -> CPP_ret(iota_view<Val>)( \/\/$/;"	f	struct:ranges::views::ints_fn	typeref:typename:CPP_ret (iota_view<Val>)(requires integral<Val>)
operator ()	include/range/v3/view/join.hpp	/^                auto operator()(Rng && rng) const$/;"	f	struct:ranges::views::join_fn::lamduh	typeref:typename:invoke_result_t<join_fn,Rng,T (&)[N]>
operator ()	include/range/v3/view/join.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(join_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::cpp20_join_fn	typeref:typename:CPP_ret (join_view<all_t<Rng>>)(requires joinable_range<Rng>)
operator ()	include/range/v3/view/join.hpp	/^            auto operator()(Rng && rng, ValRng && val) const$/;"	f	struct:ranges::views::join_base_fn	typeref:typename:CPP_ret (join_with_view<all_t<Rng>,all_t<ValRng>>)(requires joinable_with_range<Rng,ValRng>)
operator ()	include/range/v3/view/join.hpp	/^            auto operator()(Rng && rng, inner_value_t<Rng> v) const$/;"	f	struct:ranges::views::join_base_fn	typeref:typename:CPP_ret (join_with_view<all_t<Rng>,single_view<inner_value_t<Rng>>>)(requires joinable_with_range<Rng,single_view<inner_value_t<Rng>>>)
operator ()	include/range/v3/view/join.hpp	/^            constexpr auto operator()(T (&val)[N]) const$/;"	f	struct:ranges::views::join_fn	typeref:typename:auto
operator ()	include/range/v3/view/join.hpp	/^            constexpr auto operator()(join_view * this_, std::true_type) const$/;"	f	struct:ranges::join_view::end_cursor_fn	typeref:typename:auto
operator ()	include/range/v3/view/join.hpp	/^            constexpr auto operator()(join_view *, std::false_type) const$/;"	f	struct:ranges::join_view::end_cursor_fn	typeref:typename:auto
operator ()	include/range/v3/view/join.hpp	/^            constexpr auto operator()(join_view const * this_, std::true_type) const$/;"	f	struct:ranges::join_view::cend_cursor_fn	typeref:typename:auto
operator ()	include/range/v3/view/join.hpp	/^            constexpr auto operator()(join_view const *, std::false_type) const$/;"	f	struct:ranges::join_view::cend_cursor_fn	typeref:typename:auto
operator ()	include/range/v3/view/join.hpp	/^            constexpr view_closure<lamduh<T, N>> operator()(T (&val)[N]) const$/;"	f	struct:ranges::views::join_fn	typeref:typename:view_closure<lamduh<T,N>>
operator ()	include/range/v3/view/map.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(keys_range_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::keys_fn	typeref:typename:CPP_ret (keys_range_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng> && detail::kv_pair_like_<range_reference_t<Rng>>)
operator ()	include/range/v3/view/map.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(values_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::values_fn	typeref:typename:CPP_ret (values_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng> && detail::kv_pair_like_<range_reference_t<Rng>>)
operator ()	include/range/v3/view/move.hpp	/^            auto operator()(Rng && rng) const -> CPP_ret(move_view<all_t<Rng>>)( \/\/$/;"	f	struct:ranges::views::move_fn	typeref:typename:CPP_ret (move_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng>)
operator ()	include/range/v3/view/partial_sum.hpp	/^            constexpr auto operator()(Rng && rng, Fun fun = {}) const$/;"	f	struct:ranges::views::partial_sum_base_fn	typeref:typename:CPP_ret (partial_sum_view<all_t<Rng>,Fun>)(requires detail::partial_sum_view_constraints<all_t<Rng>,Fun>)
operator ()	include/range/v3/view/partial_sum.hpp	/^            operator()() const$/;"	f	struct:ranges::views::partial_sum_fn	typeref:typename:RANGES_DEPRECATED ("Use \\"ranges::views::partial_sum\\" instead of ""\\"ranges::views::partial_sum()\\".")auto
operator ()	include/range/v3/view/ref.hpp	/^            constexpr auto operator()(Rng & rng) const noexcept$/;"	f	struct:ranges::views::ref_fn	typeref:typename:auto
operator ()	include/range/v3/view/remove.hpp	/^                auto operator()(T && other) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::views::remove_base_fn::pred_	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<T,Value const &>)
operator ()	include/range/v3/view/remove.hpp	/^            constexpr auto operator()(Value value) const$/;"	f	struct:ranges::views::remove_fn	typeref:typename:auto
operator ()	include/range/v3/view/remove_if.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::remove_if_fn	typeref:typename:auto
operator ()	include/range/v3/view/remove_if.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const$/;"	f	struct:ranges::views::remove_if_base_fn	typeref:typename:CPP_ret (remove_if_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred,iterator_t<Rng>>)
operator ()	include/range/v3/view/remove_if.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred, Proj proj) const$/;"	f	struct:ranges::views::remove_if_base_fn	typeref:typename:CPP_ret (remove_if_view<all_t<Rng>,composed<Pred,Proj>>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred,projected<iterator_t<Rng>,Proj>>)
operator ()	include/range/v3/view/repeat.hpp	/^            auto operator()(Val value) const -> CPP_ret(repeat_view<Val>)( \/\/$/;"	f	struct:ranges::views::repeat_fn	typeref:typename:CPP_ret (repeat_view<Val>)(requires copy_constructible<Val>)
operator ()	include/range/v3/view/repeat_n.hpp	/^            auto operator()(Val value, std::ptrdiff_t n) const$/;"	f	struct:ranges::views::repeat_n_fn	typeref:typename:CPP_ret (repeat_n_view<Val>)(requires copy_constructible<Val>)
operator ()	include/range/v3/view/replace.hpp	/^            constexpr auto operator()(Rng && rng, Val1 && old_value,$/;"	f	struct:ranges::views::replace_base_fn	typeref:typename:CPP_ret (replace_view<all_t<Rng>,detail::decay_t<Val1>,detail::decay_t<Val2>>)(requires viewable_range<Rng> && input_range<Rng> && same_as<detail::decay_t<unwrap_reference_t<Val1>>,detail::decay_t<unwrap_reference_t<Val2>>> && equality_comparable_with<detail::decay_t<unwrap_reference_t<Val1>>,range_value_t<Rng>> && common_with<detail::decay_t<unwrap_reference_t<Val2 const &>>,range_value_t<Rng>> && common_reference_with<unwrap_reference_t<Val2 const &>,range_reference_t<Rng>> && common_reference_with<unwrap_reference_t<Val2 const &>,range_rvalue_reference_t<Rng>>)
operator ()	include/range/v3/view/replace.hpp	/^            operator()(I const & i) const$/;"	f	struct:ranges::detail::replacer_fn	typeref:typename:common_reference_t<unwrap_reference_t<Val2 const &>,iter_reference_t<I>>
operator ()	include/range/v3/view/replace.hpp	/^            operator()(copy_tag, I const &) const$/;"	f	struct:ranges::detail::replacer_fn	typeref:typename:[[noreturn]]common_type_t<decay_t<unwrap_reference_t<Val2 const &>>,iter_value_t<I>> &
operator ()	include/range/v3/view/replace.hpp	/^            operator()(move_tag, I const & i) const$/;"	f	struct:ranges::detail::replacer_fn	typeref:typename:common_reference_t<unwrap_reference_t<Val2 const &>,iter_rvalue_reference_t<I>>
operator ()	include/range/v3/view/replace_if.hpp	/^            auto operator()(I const & i) const$/;"	f	struct:ranges::detail::replacer_if_fn	typeref:typename:CPP_ret (common_reference_t<unwrap_reference_t<Val const &>,iter_reference_t<I>>)(requires invocable<Pred const &,iter_reference_t<I>>)
operator ()	include/range/v3/view/replace_if.hpp	/^            auto operator()(I const & i)$/;"	f	struct:ranges::detail::replacer_if_fn	typeref:typename:CPP_ret (common_reference_t<unwrap_reference_t<Val const &>,iter_reference_t<I>>)(requires (!invocable<Pred const &,iter_reference_t<I>>))
operator ()	include/range/v3/view/replace_if.hpp	/^            auto operator()(move_tag, I const & i) const$/;"	f	struct:ranges::detail::replacer_if_fn	typeref:typename:CPP_ret (common_reference_t<unwrap_reference_t<Val const &>,iter_rvalue_reference_t<I>>)(requires invocable<Pred const &,iter_rvalue_reference_t<I>>)
operator ()	include/range/v3/view/replace_if.hpp	/^            auto operator()(move_tag, I const & i)$/;"	f	struct:ranges::detail::replacer_if_fn	typeref:typename:CPP_ret (common_reference_t<unwrap_reference_t<Val const &>,iter_rvalue_reference_t<I>>)(requires (!invocable<Pred const &,iter_rvalue_reference_t<I>>))
operator ()	include/range/v3/view/replace_if.hpp	/^            constexpr auto operator()(Pred pred, Val new_value) const$/;"	f	struct:ranges::views::replace_if_fn	typeref:typename:auto
operator ()	include/range/v3/view/replace_if.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred, Val new_value) const$/;"	f	struct:ranges::views::replace_if_base_fn	typeref:typename:CPP_ret (replace_if_view<all_t<Rng>,Pred,Val>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred,iterator_t<Rng>> && common_with<detail::decay_t<unwrap_reference_t<Val const &>>,range_value_t<Rng>> && common_reference_with<unwrap_reference_t<Val const &>,range_reference_t<Rng>> && common_reference_with<unwrap_reference_t<Val const &>,range_rvalue_reference_t<Rng>>)
operator ()	include/range/v3/view/replace_if.hpp	/^            operator()(copy_tag, I const &) const$/;"	f	struct:ranges::detail::replacer_if_fn	typeref:typename:[[noreturn]]common_type_t<decay_t<unwrap_reference_t<Val const &>>,iter_value_t<I>> &
operator ()	include/range/v3/view/reverse.hpp	/^            constexpr auto operator()(Rng && rng) const$/;"	f	struct:ranges::views::reverse_fn	typeref:typename:CPP_ret (reverse_view<all_t<Rng>>)(requires viewable_range<Rng> && bidirectional_range<Rng>)
operator ()	include/range/v3/view/sample.hpp	/^                auto operator()(Rng && rng) const$/;"	f	struct:ranges::views::sample_fn::lamduh	typeref:typename:invoke_result_t<sample_base_fn,Rng,range_difference_t<Rng>,URNG &>
operator ()	include/range/v3/view/sample.hpp	/^            auto operator()(Rng && rng, range_difference_t<Rng> sample_size,$/;"	f	struct:ranges::views::sample_base_fn	typeref:typename:CPP_ret (sample_view<all_t<Rng>,URNG>)(requires viewable_range<Rng> && input_range<Rng> && uniform_random_bit_generator<URNG> && convertible_to<invoke_result_t<URNG &>,range_difference_t<Rng>> && (sized_range<Rng>||sized_sentinel_for<sentinel_t<Rng>,iterator_t<Rng>>||forward_range<Rng>))
operator ()	include/range/v3/view/set_algorithm.hpp	/^            auto operator()(Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{},$/;"	f	struct:ranges::views::set_difference_base_fn	typeref:typename:CPP_ret (set_difference_view<all_t<Rng1>,all_t<Rng2>,C,P1,P2>)(requires viewable_range<Rng1> && input_range<Rng1> && viewable_range<Rng2> && input_range<Rng2> && indirect_relation<C,projected<iterator_t<Rng1>,P1>,projected<iterator_t<Rng2>,P2>>)
operator ()	include/range/v3/view/set_algorithm.hpp	/^            auto operator()(Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{},$/;"	f	struct:ranges::views::set_intersection_base_fn	typeref:typename:CPP_ret (set_intersection_view<all_t<Rng1>,all_t<Rng2>,C,P1,P2>)(requires viewable_range<Rng1> && input_range<Rng1> && viewable_range<Rng2> && input_range<Rng2> && indirect_relation<C,projected<iterator_t<Rng1>,P1>,projected<iterator_t<Rng2>,P2>>)
operator ()	include/range/v3/view/set_algorithm.hpp	/^            auto operator()(Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{},$/;"	f	struct:ranges::views::set_symmetric_difference_base_fn	typeref:typename:CPP_ret (set_symmetric_difference_view<all_t<Rng1>,all_t<Rng2>,C,P1,P2>)(requires viewable_range<Rng1> && input_range<Rng1> && viewable_range<Rng2> && input_range<Rng2> && common_with<range_value_t<Rng1>,range_value_t<Rng2>> && common_reference_with<range_reference_t<Rng1>,range_reference_t<Rng2>> && common_reference_with<range_rvalue_reference_t<Rng1>,range_rvalue_reference_t<Rng2>> && indirect_relation<C,projected<iterator_t<Rng1>,P1>,projected<iterator_t<Rng2>,P2>>)
operator ()	include/range/v3/view/set_algorithm.hpp	/^            auto operator()(Rng1 && rng1, Rng2 && rng2, C pred = C{}, P1 proj1 = P1{},$/;"	f	struct:ranges::views::set_union_base_fn	typeref:typename:CPP_ret (set_union_view<all_t<Rng1>,all_t<Rng2>,C,P1,P2>)(requires viewable_range<Rng1> && input_range<Rng1> && viewable_range<Rng2> && input_range<Rng2> && common_with<range_value_t<Rng1>,range_value_t<Rng2>> && common_reference_with<range_reference_t<Rng1>,range_reference_t<Rng2>> && common_reference_with<range_rvalue_reference_t<Rng1>,range_rvalue_reference_t<Rng2>> && indirect_relation<C,projected<iterator_t<Rng1>,P1>,projected<iterator_t<Rng2>,P2>>)
operator ()	include/range/v3/view/single.hpp	/^            auto operator()(Val value) const -> CPP_ret(single_view<Val>)( \/\/$/;"	f	struct:ranges::views::single_fn	typeref:typename:CPP_ret (single_view<Val>)(requires copy_constructible<Val>)
operator ()	include/range/v3/view/sliding.hpp	/^            constexpr auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::views::sliding_base_fn	typeref:typename:CPP_ret (sliding_view<all_t<Rng>>)(requires viewable_range<Rng> && forward_range<Rng>)
operator ()	include/range/v3/view/split.hpp	/^            constexpr auto operator()(Rng && rng, Pattern && pattern) const$/;"	f	struct:ranges::views::split_base_fn	typeref:typename:CPP_ret (split_view<all_t<Rng>,all_t<Pattern>>)(requires viewable_range<Rng> && input_range<Rng> && viewable_range<Pattern> && forward_range<Pattern> && indirectly_comparable<iterator_t<Rng>,iterator_t<Pattern>,ranges::equal_to> && (forward_range<Rng>||detail::tiny_range<Pattern>))
operator ()	include/range/v3/view/split.hpp	/^            constexpr auto operator()(Rng && rng, range_value_t<Rng> val) const$/;"	f	struct:ranges::views::split_base_fn	typeref:typename:CPP_ret (split_view<all_t<Rng>,single_view<range_value_t<Rng>>>)(requires viewable_range<Rng> && input_range<Rng> && indirectly_comparable<iterator_t<Rng>,range_value_t<Rng> const *,ranges::equal_to>)
operator ()	include/range/v3/view/split.hpp	/^            constexpr auto operator()(T t) const$/;"	f	struct:ranges::views::split_fn	typeref:typename:auto
operator ()	include/range/v3/view/split_when.hpp	/^                auto operator()(I cur, S last) const -> CPP_ret(std::pair<bool, I>)( \/\/$/;"	f	struct:ranges::views::split_when_base_fn::predicate_pred_	typeref:typename:CPP_ret (std::pair<bool,I>)(requires sentinel_for<S,I>)
operator ()	include/range/v3/view/split_when.hpp	/^                bool operator()(iterator_t<CRng> cur) const$/;"	f	struct:ranges::split_when_view::cursor::search_pred	typeref:typename:bool
operator ()	include/range/v3/view/split_when.hpp	/^            auto operator()(Rng && rng, Fun fun) const        \/\/$/;"	f	struct:ranges::views::split_when_base_fn	typeref:typename:CPP_ret (split_when_view<all_t<Rng>,Fun>)(requires viewable_range<Rng> && forward_range<Rng> && invocable<Fun &,iterator_t<Rng>,sentinel_t<Rng>> && invocable<Fun &,iterator_t<Rng>,iterator_t<Rng>> && copy_constructible<Fun> && convertible_to<invoke_result_t<Fun &,iterator_t<Rng>,sentinel_t<Rng>>,std::pair<bool,iterator_t<Rng>>>)
operator ()	include/range/v3/view/split_when.hpp	/^            auto operator()(Rng && rng, Fun fun) const$/;"	f	struct:ranges::views::split_when_base_fn	typeref:typename:CPP_ret (split_when_view<all_t<Rng>,predicate_pred_<Fun>>)(requires viewable_range<Rng> && forward_range<Rng> && predicate<Fun const &,range_reference_t<Rng>> && copy_constructible<Fun>)
operator ()	include/range/v3/view/split_when.hpp	/^            constexpr auto operator()(T && t) const$/;"	f	struct:ranges::views::split_when_fn	typeref:typename:auto
operator ()	include/range/v3/view/stride.hpp	/^            constexpr auto operator()(Rng && rng, range_difference_t<Rng> step) const$/;"	f	struct:ranges::views::stride_base_fn	typeref:typename:CPP_ret (stride_view<all_t<Rng>>)(requires viewable_range<Rng> && input_range<Rng>)
operator ()	include/range/v3/view/subrange.hpp	/^        constexpr auto operator()(I i, S s) const -> subrange<I, S>$/;"	f	struct:ranges::make_subrange_fn	typeref:typename:subrange<I,S>
operator ()	include/range/v3/view/subrange.hpp	/^        constexpr auto operator()(I i, S s, detail::iter_size_t<I> n) const$/;"	f	struct:ranges::make_subrange_fn	typeref:typename:CPP_ret (subrange<I,S,subrange_kind::sized>)(requires input_or_output_iterator<I> && sentinel_for<S,I>)
operator ()	include/range/v3/view/subrange.hpp	/^        constexpr auto operator()(R && r) const -> CPP_ret($/;"	f	struct:ranges::make_subrange_fn	typeref:typename:CPP_ret (subrange<iterator_t<R>,sentinel_t<R>,(sized_range<R>||sized_sentinel_for<sentinel_t<R>,iterator_t<R>>)?subrange_kind::sized:subrange_kind::unsized>)(requires forwarding_range_<R>)
operator ()	include/range/v3/view/subrange.hpp	/^        constexpr auto operator()(R && r, detail::iter_size_t<iterator_t<R>> n) const$/;"	f	struct:ranges::make_subrange_fn	typeref:typename:CPP_ret (subrange<iterator_t<R>,sentinel_t<R>,subrange_kind::sized>)(requires forwarding_range_<R>)
operator ()	include/range/v3/view/tail.hpp	/^            auto operator()(Rng && rng) const$/;"	f	struct:ranges::views::tail_fn	typeref:typename:CPP_ret (meta::if_c<range_cardinality<Rng>::value==0,all_t<Rng>,tail_view<all_t<Rng>>>)(requires viewable_range<Rng> && input_range<Rng>)
operator ()	include/range/v3/view/take.hpp	/^            auto operator()(Rng && rng, range_difference_t<Rng> n) const$/;"	f	struct:ranges::views::take_base_fn	typeref:typename:CPP_ret (take_view<all_t<Rng>>)(requires viewable_range<Rng>)
operator ()	include/range/v3/view/take_while.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::iter_take_while_fn	typeref:typename:auto
operator ()	include/range/v3/view/take_while.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::take_while_fn	typeref:typename:auto
operator ()	include/range/v3/view/take_while.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const$/;"	f	struct:ranges::views::iter_take_while_base_fn	typeref:typename:CPP_ret (iter_take_while_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && input_range<Rng> && predicate<Pred &,iterator_t<Rng>> && copy_constructible<Pred>)
operator ()	include/range/v3/view/take_while.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const$/;"	f	struct:ranges::views::take_while_base_fn	typeref:typename:CPP_ret (take_while_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<Pred &,iterator_t<Rng>>)
operator ()	include/range/v3/view/take_while.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred, Proj proj) const$/;"	f	struct:ranges::views::take_while_base_fn	typeref:typename:CPP_ret (take_while_view<all_t<Rng>,composed<Pred,Proj>>)(requires viewable_range<Rng> && input_range<Rng> && indirect_unary_predicate<composed<Pred,Proj> &,iterator_t<Rng>>)
operator ()	include/range/v3/view/tokenize.hpp	/^            auto operator()(Regex && rex, std::vector<int> subs,$/;"	f	struct:ranges::views::tokenize_fn	typeref:typename:auto
operator ()	include/range/v3/view/tokenize.hpp	/^            auto operator()(Rng && rng, Regex && rex, int sub = 0,$/;"	f	struct:ranges::views::tokenize_base_fn	typeref:typename:CPP_ret (tokenize_view<all_t<Rng>,detail::decay_t<Regex>,int>)(requires bidirectional_range<Rng> && common_range<Rng> && same_as<range_value_t<Rng>,typename detail::decay_t<Regex>::value_type>)
operator ()	include/range/v3/view/tokenize.hpp	/^            auto operator()(Rng && rng, Regex && rex, std::initializer_list<int> subs,$/;"	f	struct:ranges::views::tokenize_base_fn	typeref:typename:CPP_ret (tokenize_view<all_t<Rng>,detail::decay_t<Regex>,std::initializer_list<int>>)(requires bidirectional_range<Rng> && common_range<Rng> && same_as<range_value_t<Rng>,typename detail::decay_t<Regex>::value_type>)
operator ()	include/range/v3/view/tokenize.hpp	/^            auto operator()(Rng && rng, Regex && rex, std::vector<int> subs,$/;"	f	struct:ranges::views::tokenize_base_fn	typeref:typename:CPP_ret (tokenize_view<all_t<Rng>,detail::decay_t<Regex>,std::vector<int>>)(requires bidirectional_range<Rng> && common_range<Rng> && same_as<range_value_t<Rng>,typename detail::decay_t<Regex>::value_type>)
operator ()	include/range/v3/view/tokenize.hpp	/^            constexpr auto operator()(Regex && rex, int sub = 0,$/;"	f	struct:ranges::views::tokenize_fn	typeref:typename:auto
operator ()	include/range/v3/view/tokenize.hpp	/^            constexpr auto operator()(Regex && rex, std::initializer_list<int> subs,$/;"	f	struct:ranges::views::tokenize_fn	typeref:typename:auto
operator ()	include/range/v3/view/transform.hpp	/^            constexpr auto operator()(Fun fun) const$/;"	f	struct:ranges::views::iter_transform_fn	typeref:typename:auto
operator ()	include/range/v3/view/transform.hpp	/^            constexpr auto operator()(Fun fun) const$/;"	f	struct:ranges::views::transform_fn	typeref:typename:auto
operator ()	include/range/v3/view/transform.hpp	/^            constexpr auto operator()(Rng && rng, Fun fun) const$/;"	f	struct:ranges::views::iter_transform_base_fn	typeref:typename:CPP_ret (iter_transform_view<all_t<Rng>,Fun>)(requires viewable_range<Rng> && input_range<Rng> && copy_constructible<Fun> && detail::iter_transform_1_readable<Fun,Rng>)
operator ()	include/range/v3/view/transform.hpp	/^            constexpr auto operator()(Rng && rng, Fun fun) const$/;"	f	struct:ranges::views::transform_base_fn	typeref:typename:CPP_ret (transform_view<all_t<Rng>,Fun>)(requires transformable_range<Rng,Fun>)
operator ()	include/range/v3/view/transform.hpp	/^            constexpr auto operator()(Rng1 && rng1, Rng2 && rng2, Fun fun) const$/;"	f	struct:ranges::views::iter_transform_base_fn	typeref:typename:CPP_ret (iter_transform2_view<all_t<Rng1>,all_t<Rng2>,Fun>)(requires viewable_range<Rng1> && input_range<Rng1> && viewable_range<Rng2> && input_range<Rng2> && copy_constructible<Fun> && common_with<range_difference_t<Rng1>,range_difference_t<Rng1>> && detail::iter_transform_2_readable<Fun,Rng1,Rng2>)
operator ()	include/range/v3/view/transform.hpp	/^            constexpr auto operator()(Rng1 && rng1, Rng2 && rng2, Fun fun) const$/;"	f	struct:ranges::views::transform_base_fn	typeref:typename:CPP_ret (transform2_view<all_t<Rng1>,all_t<Rng2>,Fun>)(requires transformable_ranges<Rng1,Rng2,Fun>)
operator ()	include/range/v3/view/trim.hpp	/^            constexpr auto operator()(Pred pred) const$/;"	f	struct:ranges::views::trim_fn	typeref:typename:auto
operator ()	include/range/v3/view/trim.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred) const \/\/$/;"	f	struct:ranges::views::trim_base_fn	typeref:typename:CPP_ret (trim_view<all_t<Rng>,Pred>)(requires viewable_range<Rng> && bidirectional_range<Rng> && indirect_unary_predicate<Pred,iterator_t<Rng>> && common_range<Rng>)
operator ()	include/range/v3/view/trim.hpp	/^            constexpr auto operator()(Rng && rng, Pred pred, Proj proj) const$/;"	f	struct:ranges::views::trim_base_fn	typeref:typename:CPP_ret (trim_view<all_t<Rng>,composed<Pred,Proj>>)(requires viewable_range<Rng> && bidirectional_range<Rng> && indirect_unary_predicate<composed<Pred,Proj>,iterator_t<Rng>> && common_range<Rng>)
operator ()	include/range/v3/view/unbounded.hpp	/^            constexpr auto operator()(I it) const -> CPP_ret(unbounded_view<I>)( \/\/$/;"	f	struct:ranges::views::unbounded_fn	typeref:typename:CPP_ret (unbounded_view<I>)(requires input_iterator<I>)
operator ()	include/range/v3/view/unique.hpp	/^            constexpr auto operator()(Rng && rng, C pred = {}) const$/;"	f	struct:ranges::views::unique_base_fn	typeref:typename:CPP_ret (adjacent_filter_view<all_t<Rng>,logical_negate<C>>)(requires viewable_range<Rng> && forward_range<Rng> && indirect_relation<C,iterator_t<Rng>>)
operator ()	include/range/v3/view/view.hpp	/^            constexpr auto operator()(Rng && rng, Rest &&... rest) const -> CPP_ret($/;"	f	struct:ranges::views::old_view_	typeref:typename:CPP_ret (invoke_result_t<ViewFn const &,Rng,Rest...>)(requires viewable_range<Rng> && invocable<ViewFn const &,Rng,Rest...>)
operator ()	include/range/v3/view/view.hpp	/^            constexpr old_view_<Fun> operator()(Fun fun) const$/;"	f	struct:ranges::views::make_view_fn_	typeref:typename:old_view_<Fun>
operator ()	include/range/v3/view/view.hpp	/^        constexpr views::view_closure<Fun> operator()(Fun fun) const$/;"	f	struct:ranges::make_view_closure_fn	typeref:typename:views::view_closure<Fun>
operator ()	include/range/v3/view/zip.hpp	/^            [[noreturn]] auto operator()(copy_tag, It1, It2) const$/;"	f	struct:ranges::detail::indirect_zip_fn_	typeref:typename:CPP_ret (std::pair<iter_value_t<It1>,iter_value_t<It2>>)(requires readable<It1> && readable<It2>)
operator ()	include/range/v3/view/zip.hpp	/^            [[noreturn]] auto operator()(copy_tag, Its...) const$/;"	f	struct:ranges::detail::indirect_zip_fn_	typeref:typename:CPP_ret (std::tuple<iter_value_t<Its>...>)(requires and_v<readable<Its>...> && (sizeof...(Its)!=2))
operator ()	include/range/v3/view/zip.hpp	/^            auto operator()(It1 const & it1, It2 const & it2) const noexcept($/;"	f	struct:ranges::detail::indirect_zip_fn_	typeref:typename:auto
operator ()	include/range/v3/view/zip.hpp	/^            auto operator()(Its const &... its) const$/;"	f	struct:ranges::detail::indirect_zip_fn_	typeref:typename:auto
operator ()	include/range/v3/view/zip.hpp	/^            auto operator()(Rngs &&... rngs) const -> CPP_ret($/;"	f	struct:ranges::views::zip_fn	typeref:typename:CPP_ret (zip_view<all_t<Rngs>...>)(requires and_v<viewable_range<Rngs>...> && and_v<input_range<Rngs>...> && (sizeof...(Rngs)!=0))
operator ()	include/range/v3/view/zip.hpp	/^            auto operator()(move_tag, It1 const & it1, It2 const & it2) const$/;"	f	struct:ranges::detail::indirect_zip_fn_	typeref:typename:auto
operator ()	include/range/v3/view/zip.hpp	/^            auto operator()(move_tag, Its const &... its) const$/;"	f	struct:ranges::detail::indirect_zip_fn_	typeref:typename:auto
operator ()	include/range/v3/view/zip.hpp	/^            constexpr empty_view<std::tuple<>> operator()() const noexcept$/;"	f	struct:ranges::views::zip_fn	typeref:typename:empty_view<std::tuple<>>
operator ()	include/range/v3/view/zip_with.hpp	/^            auto operator()(Fun fun, Rngs &&... rngs) const -> CPP_ret($/;"	f	struct:ranges::views::iter_zip_with_fn	typeref:typename:CPP_ret (iter_zip_with_view<Fun,all_t<Rngs>...>)(requires and_v<viewable_range<Rngs>...> && zippable_with<Fun,Rngs...> && (sizeof...(Rngs)!=0))
operator ()	include/range/v3/view/zip_with.hpp	/^            auto operator()(Fun fun, Rngs &&... rngs) const$/;"	f	struct:ranges::views::zip_with_fn	typeref:typename:CPP_ret (zip_with_view<Fun,all_t<Rngs>...>)(requires and_v<viewable_range<Rngs>...> && and_v<input_range<Rngs>...> && copy_constructible<Fun> && invocable<Fun &,range_reference_t<Rngs>...> && (sizeof...(Rngs)!=0))
operator ()	include/range/v3/view/zip_with.hpp	/^            auto operator()(I & i, Diff n) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::_advance_	typeref:typename:CPP_ret (void)(requires input_or_output_iterator<I> && integer_like_<Diff>)
operator ()	include/range/v3/view/zip_with.hpp	/^            bool operator()(T const & t, U const & u) const$/;"	f	struct:ranges::detail::equal_to_	typeref:typename:bool
operator ()	include/range/v3/view/zip_with.hpp	/^            constexpr auto operator()(Fun) const noexcept$/;"	f	struct:ranges::views::iter_zip_with_fn	typeref:typename:auto
operator ()	include/range/v3/view/zip_with.hpp	/^            constexpr auto operator()(Fun) const noexcept$/;"	f	struct:ranges::views::zip_with_fn	typeref:typename:auto
operator ()	include/range/v3/view/zip_with.hpp	/^            constexpr auto operator()(T const & t, T const & u) const -> decltype(u - t)$/;"	f	struct:ranges::detail::distance_to_	typeref:typename:decltype (u-t)
operator ()	include/range/v3/view/zip_with.hpp	/^            constexpr auto operator()(T const & t, U const & u) const$/;"	f	struct:ranges::detail::_max_	typeref:typename:decltype (true?u:t)
operator ()	include/range/v3/view/zip_with.hpp	/^            constexpr auto operator()(T const & t, U const & u) const$/;"	f	struct:ranges::detail::_min_	typeref:typename:decltype (true?t:u)
operator ()	include/range/v3/view/zip_with.hpp	/^            void operator()(T & t) const$/;"	f	struct:ranges::detail::dec_	typeref:typename:void
operator ()	include/range/v3/view/zip_with.hpp	/^            void operator()(T & t) const$/;"	f	struct:ranges::detail::inc_	typeref:typename:void
operator ()	include/union.hpp	/^  constexpr auto operator()(O &&o) const -> decltype(pith(std::declval<O>())) {$/;"	f	struct:abo::union_fn	typeref:typename:decltype (pith (std::declval<O> ()))
operator *	include/ntskills.hpp	/^  T operator*(T const &other) const {$/;"	f	struct:nt::Multiplicable	typeref:typename:T
operator *	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr Value const & operator*() const noexcept$/;"	f	struct:ranges::postfix_increment_proxy	typeref:typename:Value const &
operator *	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator*() const$/;"	f	struct:basic_iterator	typeref:typename:CPP_member auto
operator *	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator*() noexcept -> CPP_ret(basic_iterator &)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_member auto
operator *	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator*() noexcept(noexcept(iter_reference_t{$/;"	f	struct:basic_iterator	typeref:typename:CPP_member auto
operator *	include/range/v3/iterator/common_iterator.hpp	/^        auto operator*() const$/;"	f	struct:ranges::common_iterator	typeref:typename:CPP_member auto
operator *	include/range/v3/iterator/common_iterator.hpp	/^        iter_reference_t<I> operator*() noexcept($/;"	f	struct:ranges::common_iterator	typeref:typename:iter_reference_t<I>
operator *	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator*() const$/;"	f	struct:ranges::counted_iterator	typeref:typename:auto
operator *	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr iter_reference_t<I> operator*() noexcept($/;"	f	struct:ranges::counted_iterator	typeref:typename:iter_reference_t<I>
operator *	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator*(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator *	include/range/v3/iterator/insert_iterators.hpp	/^        back_insert_iterator & operator*()$/;"	f	struct:ranges::back_insert_iterator	typeref:typename:back_insert_iterator &
operator *	include/range/v3/iterator/insert_iterators.hpp	/^        front_insert_iterator & operator*()$/;"	f	struct:ranges::front_insert_iterator	typeref:typename:front_insert_iterator &
operator *	include/range/v3/iterator/insert_iterators.hpp	/^        insert_iterator & operator*()$/;"	f	struct:ranges::insert_iterator	typeref:typename:insert_iterator &
operator *	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_iterator & operator*()$/;"	f	struct:ranges::ostream_iterator	typeref:typename:ostream_iterator &
operator *	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_joiner & operator*() noexcept$/;"	f	struct:ranges::ostream_joiner	typeref:typename:ostream_joiner &
operator *	include/range/v3/iterator/stream_iterators.hpp	/^        ostreambuf_iterator & operator*()$/;"	f	struct:ranges::ostreambuf_iterator	typeref:typename:ostreambuf_iterator &
operator *	include/range/v3/range/conversion.hpp	/^            reference operator*() const$/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:reference
operator *	include/range/v3/utility/memory.hpp	/^        raw_storage_iterator & operator*() noexcept$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:raw_storage_iterator &
operator *	include/range/v3/utility/optional.hpp	/^                constexpr T & operator*() & noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T &
operator *	include/range/v3/utility/optional.hpp	/^                constexpr T & operator*() const noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T &
operator *	include/range/v3/utility/optional.hpp	/^                constexpr T && operator*() && noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T &&
operator *	include/range/v3/utility/optional.hpp	/^                constexpr T const & operator*() const & noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T const &
operator *	include/range/v3/utility/optional.hpp	/^                constexpr T const && operator*() const && noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T const &&
operator *	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) operator*() const$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:decltype (auto)
operator *	include/range/v3/view/split.hpp	/^            constexpr value_type operator*() const$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:value_type
operator *=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator*=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator *=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator*=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator +	include/lr.hpp	/^  L operator+(const L &other) { return L(this->message + other.message); }$/;"	f	struct:lr::L	typeref:typename:L
operator +	include/newtype.hpp	/^  T operator+(T const &other) const {$/;"	f	struct:abo::nt::Addable	typeref:typename:T
operator +	include/ntskills.hpp	/^  T operator+(T const &other) const {$/;"	f	struct:nt::Addable	typeref:typename:T
operator +	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator+(basic_iterator<Cur> left,$/;"	f	typeref:typename:CPP_ret (basic_iterator<Cur>)(requires detail::random_access_cursor<Cur>)
operator +	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator+(typename basic_iterator<Cur>::difference_type n,$/;"	f	typeref:typename:CPP_ret (basic_iterator<Cur>)(requires detail::random_access_cursor<Cur>)
operator +	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator+(difference_type n) const -> CPP_ret(counted_iterator)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator)(requires random_access_iterator<I>)
operator +	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator+(iter_difference_t<I> n, counted_iterator<I> const & x)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (counted_iterator<I>)(requires random_access_iterator<I>)
operator +	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator+(diffmax_t a) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator +	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator+(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator +	include/range/v3/iterator/move_iterators.hpp	/^        auto operator+(difference_type n) const -> CPP_ret(move_iterator)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator)(requires random_access_iterator<I>)
operator +	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator+(iter_difference_t<I> n,$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (move_iterator)(requires random_access_iterator<I>)
operator +	include/range/v3/range/conversion.hpp	/^            friend auto operator+(to_container_iterator i, difference_type n) \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (to_container_iterator)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator ++	example/calendar.cpp	/^        date &operator++(date &d)$/;"	f	namespace:boost::gregorian	typeref:typename:date &
operator ++	example/calendar.cpp	/^        date operator++(date &d, int)$/;"	f	namespace:boost::gregorian	typeref:typename:date
operator ++	include/ntskills.hpp	/^  T &operator++() {$/;"	f	struct:nt::PreIncrementable	typeref:typename:T &
operator ++	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator++() -> CPP_ret(basic_iterator &)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (basic_iterator &)(requires detail::has_cursor_next<Cur>)
operator ++	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator++() noexcept -> CPP_ret(basic_iterator &)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_member auto
operator ++	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator++(int)$/;"	f	struct:basic_iterator	typeref:typename:CPP_member auto
operator ++	include/range/v3/iterator/common_iterator.hpp	/^        auto operator++(int) -> CPP_ret(common_iterator)( \/\/$/;"	f	struct:ranges::common_iterator	typeref:typename:CPP_ret (common_iterator)(requires forward_iterator<I>)
operator ++	include/range/v3/iterator/common_iterator.hpp	/^        auto operator++(int) -> CPP_ret(decltype(std::declval<I &>()++))( \/\/$/;"	f	struct:ranges::common_iterator	typeref:typename:CPP_ret (decltype (std::declval<I &> ()++))(requires (!forward_iterator<I>))
operator ++	include/range/v3/iterator/common_iterator.hpp	/^        auto operator++(int) -> CPP_ret(decltype(std::declval<I2 &>()++))( \/\/$/;"	f	struct:ranges::common_iterator	typeref:typename:CPP_ret (decltype (std::declval<I2 &> ()++))(requires (!forward_iterator<I2>))
operator ++	include/range/v3/iterator/common_iterator.hpp	/^        common_iterator & operator++()$/;"	f	struct:ranges::common_iterator	typeref:typename:common_iterator &
operator ++	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator++(int) -> CPP_ret(counted_iterator)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator)(requires forward_iterator<I>)
operator ++	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator++(int) -> CPP_ret(decltype(std::declval<I2 &>()++))( \/\/$/;"	f	struct:ranges::counted_iterator
operator ++	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr counted_iterator & operator++()$/;"	f	struct:ranges::counted_iterator	typeref:typename:counted_iterator &
operator ++	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator++(diffmax_t & a) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator ++	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator++(diffmax_t & a, int) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator ++	include/range/v3/iterator/insert_iterators.hpp	/^        back_insert_iterator & operator++()$/;"	f	struct:ranges::back_insert_iterator	typeref:typename:back_insert_iterator &
operator ++	include/range/v3/iterator/insert_iterators.hpp	/^        back_insert_iterator operator++(int)$/;"	f	struct:ranges::back_insert_iterator	typeref:typename:back_insert_iterator
operator ++	include/range/v3/iterator/insert_iterators.hpp	/^        front_insert_iterator & operator++()$/;"	f	struct:ranges::front_insert_iterator	typeref:typename:front_insert_iterator &
operator ++	include/range/v3/iterator/insert_iterators.hpp	/^        front_insert_iterator operator++(int)$/;"	f	struct:ranges::front_insert_iterator	typeref:typename:front_insert_iterator
operator ++	include/range/v3/iterator/insert_iterators.hpp	/^        insert_iterator & operator++()$/;"	f	struct:ranges::insert_iterator	typeref:typename:insert_iterator &
operator ++	include/range/v3/iterator/insert_iterators.hpp	/^        insert_iterator & operator++(int)$/;"	f	struct:ranges::insert_iterator	typeref:typename:insert_iterator &
operator ++	include/range/v3/iterator/move_iterators.hpp	/^        auto operator++(int) -> CPP_ret(move_iterator)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator)(requires forward_iterator<I>)
operator ++	include/range/v3/iterator/move_iterators.hpp	/^        auto operator++(int) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (void)(requires (!forward_iterator<I>))
operator ++	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_iterator & operator++()$/;"	f	struct:ranges::ostream_iterator	typeref:typename:ostream_iterator &
operator ++	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_iterator & operator++(int)$/;"	f	struct:ranges::ostream_iterator	typeref:typename:ostream_iterator &
operator ++	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_joiner & operator++() noexcept$/;"	f	struct:ranges::ostream_joiner	typeref:typename:ostream_joiner &
operator ++	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_joiner & operator++(int) noexcept$/;"	f	struct:ranges::ostream_joiner	typeref:typename:ostream_joiner &
operator ++	include/range/v3/iterator/stream_iterators.hpp	/^        ostreambuf_iterator & operator++()$/;"	f	struct:ranges::ostreambuf_iterator	typeref:typename:ostreambuf_iterator &
operator ++	include/range/v3/iterator/stream_iterators.hpp	/^        ostreambuf_iterator & operator++(int)$/;"	f	struct:ranges::ostreambuf_iterator	typeref:typename:ostreambuf_iterator &
operator ++	include/range/v3/range/conversion.hpp	/^            to_container_iterator & operator++()$/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:to_container_iterator &
operator ++	include/range/v3/range/conversion.hpp	/^            to_container_iterator operator++(int)$/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:to_container_iterator
operator ++	include/range/v3/utility/memory.hpp	/^        auto operator++(int) -> CPP_ret(raw_storage_iterator)( \/\/$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:CPP_ret (raw_storage_iterator)(requires forward_iterator<O>)
operator ++	include/range/v3/utility/memory.hpp	/^        auto operator++(int) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:CPP_ret (void)(requires (!forward_iterator<O>))
operator ++	include/range/v3/utility/memory.hpp	/^        raw_storage_iterator & operator++()$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:raw_storage_iterator &
operator ++	include/range/v3/utility/memory.hpp	/^        void operator++(int)$/;"	f	struct:ranges::iterator_wrapper	typeref:typename:void
operator ++	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) operator++(int)$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:decltype (auto)
operator ++	include/range/v3/view/split.hpp	/^            constexpr decltype(auto) operator++(int)$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:decltype (auto)
operator ++	include/range/v3/view/split.hpp	/^            constexpr split_inner_iterator & operator++()$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:split_inner_iterator &
operator ++	include/range/v3/view/split.hpp	/^            constexpr split_outer_iterator & operator++()$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:split_outer_iterator &
operator +=	include/ntskills.hpp	/^  T &operator+=(T const &other) {$/;"	f	struct:nt::Incrementable	typeref:typename:T &
operator +=	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator+=(difference_type n) -> CPP_ret(basic_iterator &)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (basic_iterator &)(requires detail::random_access_cursor<Cur>)
operator +=	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator+=(difference_type n) -> CPP_ret(counted_iterator &)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator &)(requires random_access_iterator<I>)
operator +=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator+=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator +=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator+=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator +=	include/range/v3/iterator/move_iterators.hpp	/^        auto operator+=(difference_type n) -> CPP_ret(move_iterator &)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator &)(requires random_access_iterator<I>)
operator +=	include/range/v3/range/conversion.hpp	/^            auto operator+=(difference_type n) -> CPP_ret(to_container_iterator &)($/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:CPP_ret (to_container_iterator &)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator -	include/ntskills.hpp	/^  T operator-() const { return T(-this->underlying().get()); }$/;"	f	struct:nt::Negatable	typeref:typename:T
operator -	include/ntskills.hpp	/^  T operator-(T const &other) const {$/;"	f	struct:nt::Subtractable	typeref:typename:T
operator -	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator-(S const & left, basic_iterator<Cur> const & right)$/;"	f	typeref:typename:CPP_ret (typename basic_iterator<Cur>::difference_type)(requires detail::sized_sentinel_for_cursor<S,Cur>)
operator -	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator-(basic_iterator<Cur2> const & left,$/;"	f	typeref:typename:CPP_ret (typename basic_iterator<Cur>::difference_type)(requires detail::sized_sentinel_for_cursor<Cur2,Cur>)
operator -	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator-(basic_iterator<Cur> const & left, S const & right)$/;"	f	typeref:typename:CPP_ret (typename basic_iterator<Cur>::difference_type)(requires detail::sized_sentinel_for_cursor<S,Cur>)
operator -	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator-(basic_iterator<Cur> left,$/;"	f	typeref:typename:CPP_ret (basic_iterator<Cur>)(requires detail::random_access_cursor<Cur>)
operator -	include/range/v3/iterator/common_iterator.hpp	/^    auto operator-(common_iterator<I1, S1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (iter_difference_t<I2>)(requires sized_sentinel_for<I1,I2> && sized_sentinel_for<S1,I2> && sized_sentinel_for<S2,I1>)
operator -	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator-(difference_type n) const -> CPP_ret(counted_iterator)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator)(requires random_access_iterator<I>)
operator -	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator-(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (iter_difference_t<I2>)(requires common_with<I1,I2>)
operator -	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr iter_difference_t<I> operator-(counted_iterator<I> const & x,$/;"	f	namespace:ranges	typeref:typename:iter_difference_t<I>
operator -	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr iter_difference_t<I> operator-(default_sentinel_t,$/;"	f	namespace:ranges	typeref:typename:iter_difference_t<I>
operator -	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator-(diffmax_t a) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator -	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator-(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator -	include/range/v3/iterator/move_iterators.hpp	/^        auto operator-(difference_type n) const -> CPP_ret(move_iterator)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator)(requires random_access_iterator<I>)
operator -	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator-(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (iter_difference_t<I2>)(requires sized_sentinel_for<I,I2>)
operator -	include/range/v3/range/access.hpp	/^            auto operator-(Int dist) const$/;"	f	struct:ranges::_end_::fn	typeref:typename:CPP_ret (detail::from_end_<iter_diff_t<Int>>)(requires detail::integer_like_<Int>)
operator -	include/range/v3/range/conversion.hpp	/^            friend auto operator-(difference_type n, to_container_iterator i) \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (to_container_iterator)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator -	include/range/v3/range/conversion.hpp	/^            friend auto operator-(to_container_iterator const & i,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (difference_type)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator -	include/range/v3/range/conversion.hpp	/^            friend auto operator-(to_container_iterator i, difference_type n) \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (to_container_iterator)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator --	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator--() -> CPP_ret(basic_iterator &)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (basic_iterator &)(requires detail::bidirectional_cursor<Cur>)
operator --	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator--(int) -> CPP_ret(basic_iterator)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (basic_iterator)(requires detail::bidirectional_cursor<Cur>)
operator --	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator--() -> CPP_ret(counted_iterator &)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator &)(requires bidirectional_iterator<I>)
operator --	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator--(int) -> CPP_ret(counted_iterator)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator)(requires bidirectional_iterator<I>)
operator --	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator--(diffmax_t & a) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator --	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator--(diffmax_t & a, int) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator --	include/range/v3/iterator/move_iterators.hpp	/^        auto operator--() -> CPP_ret(move_iterator &)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator &)(requires forward_iterator<I>)
operator --	include/range/v3/iterator/move_iterators.hpp	/^        auto operator--(int) -> CPP_ret(move_iterator)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator)(requires bidirectional_iterator<I>)
operator --	include/range/v3/range/conversion.hpp	/^            auto operator--() -> CPP_ret(to_container_iterator &)($/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:CPP_ret (to_container_iterator &)(requires derived_from<iterator_category,std::bidirectional_iterator_tag>)
operator --	include/range/v3/range/conversion.hpp	/^            auto operator--(int) -> CPP_ret(to_container_iterator &)($/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:CPP_ret (to_container_iterator &)(requires derived_from<iterator_category,std::bidirectional_iterator_tag>)
operator -=	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator-=(difference_type n) -> CPP_ret(basic_iterator &)( \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (basic_iterator &)(requires detail::random_access_cursor<Cur>)
operator -=	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator-=(difference_type n) -> CPP_ret(counted_iterator &)( \/\/$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator &)(requires random_access_iterator<I>)
operator -=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator-=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator -=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator-=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator -=	include/range/v3/iterator/move_iterators.hpp	/^        auto operator-=(difference_type n) -> CPP_ret(move_iterator &)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator &)(requires random_access_iterator<I>)
operator -=	include/range/v3/range/conversion.hpp	/^            auto operator-=(difference_type n) -> CPP_ret(to_container_iterator &)($/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:CPP_ret (to_container_iterator &)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator ->	include/ntskills.hpp	/^  T *operator->() { return std::addressof(this->underlying().get()); }$/;"	f	typeref:struct:MethodCallable T *
operator ->	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator-> () const$/;"	f	struct:basic_iterator	typeref:typename:auto
operator ->	include/range/v3/iterator/common_iterator.hpp	/^            const iter_value_t<I> * operator->() const noexcept$/;"	f	struct:ranges::common_iterator::arrow_proxy_	typeref:typename:const iter_value_t<I> *
operator ->	include/range/v3/iterator/common_iterator.hpp	/^        auto operator-> () const$/;"	f	struct:ranges::common_iterator	typeref:typename:auto
operator ->	include/range/v3/utility/optional.hpp	/^                constexpr T * operator->() const noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T *
operator ->	include/range/v3/utility/optional.hpp	/^                constexpr T * operator->() noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T *
operator ->	include/range/v3/utility/optional.hpp	/^                constexpr T const * operator->() const noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T const *
operator /	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator\/(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator /=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator\/=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator /=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator\/=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator <	include/ntskills.hpp	/^  bool operator<(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator <	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator<(basic_iterator<Left> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sized_sentinel_for_cursor<Right,Left>)
operator <	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator<(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires common_with<I1,I2>)
operator <	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr bool operator<(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator <	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator<(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires totally_ordered_with<I,I2>)
operator <	include/range/v3/utility/common_tuple.hpp	/^    auto operator<(common_pair<F1, S1> const & a, common_pair<F2, S2> const & b)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<F1,F2> && totally_ordered_with<S1,S2>)
operator <	include/range/v3/utility/common_tuple.hpp	/^    auto operator<(common_pair<F1, S1> const & a, std::pair<F2, S2> const & b)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<F1,F2> && totally_ordered_with<S1,S2>)
operator <	include/range/v3/utility/common_tuple.hpp	/^    auto operator<(std::pair<F1, S1> const & a, common_pair<F2, S2> const & b)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<F1,F2> && totally_ordered_with<S1,S2>)
operator <	include/range/v3/utility/optional.hpp	/^            constexpr auto operator<(T const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator <	include/range/v3/utility/optional.hpp	/^            constexpr auto operator<(optional<T> const & x, U const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator <	include/range/v3/utility/optional.hpp	/^            constexpr auto operator<(optional<T> const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator <	include/range/v3/utility/optional.hpp	/^            constexpr bool operator<(nullopt_t, optional<T> const & x) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator <	include/range/v3/utility/optional.hpp	/^            constexpr bool operator<(optional<T> const &, nullopt_t) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator <	include/range/v3/view/span.hpp	/^        auto operator<(span<U, M> const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::span	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator <<	example/comprehensions.cpp	/^  friend std::ostream &operator<<(std::ostream &sout, timer const &t) {$/;"	f	typeref:typename:std::ostream &	file:
operator <<	include/ntskills.hpp	/^std::ostream &operator<<(std::ostream &os,$/;"	f	namespace:nt	typeref:typename:std::ostream &
operator <<	include/range/v3/iterator/diffmax_t.hpp	/^            friend auto operator<<(Ostream & sout, diffmax_t a)$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (std::ostream &)(requires derived_from<Ostream,std::basic_ostream<typename Ostream::char_type,typename Ostream::traits_type>>)
operator <<	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator<<(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator <<	include/range/v3/view/interface.hpp	/^        friend auto operator<<(std::ostream & sout, Derived & rng)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (std::ostream &)(requires True && (!range<D<True> const>)&& input_range<D<True>>)
operator <<	include/range/v3/view/interface.hpp	/^        friend auto operator<<(std::ostream & sout, Derived && rng)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (std::ostream &)(requires True && (!range<D<True> const>)&& input_range<D<True>>)
operator <<	include/range/v3/view/interface.hpp	/^        friend auto operator<<(std::ostream & sout, Derived const & rng)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (std::ostream &)(requires True && input_range<D<True> const>)
operator <<=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator<<=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator <<=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator<<=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator <=	include/ntskills.hpp	/^  bool operator<=(T const &other) const { return !(*this > other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator <=	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator<=(basic_iterator<Left> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sized_sentinel_for_cursor<Right,Left>)
operator <=	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator<=(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires common_with<I1,I2>)
operator <=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr bool operator<=(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator <=	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator<=(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires totally_ordered_with<I,I2>)
operator <=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator<=(T const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator <=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator<=(optional<T> const & x, U const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator <=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator<=(optional<T> const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator <=	include/range/v3/utility/optional.hpp	/^            constexpr bool operator<=(nullopt_t, optional<T> const &) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator <=	include/range/v3/utility/optional.hpp	/^            constexpr bool operator<=(optional<T> const & x, nullopt_t) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator <=	include/range/v3/view/span.hpp	/^        auto operator<=(span<U, M> const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::span	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator =	include/nt.hpp	/^    template <typename U> NamedType operator=(U &&value) const {$/;"	f	struct:nt::NamedType::argument	typeref:typename:NamedType
operator =	include/range/v3/detail/variant.hpp	/^        auto operator=(variant<Args...> that) -> CPP_ret(variant &)( \/\/$/;"	f	struct:ranges::variant	typeref:typename:CPP_ret (variant &)(requires (!same_as<variant<Args...>,variant>)&& (all_convertible_to<Args...> (0)))
operator =	include/range/v3/detail/variant.hpp	/^        variant & operator=(variant && that)$/;"	f	struct:ranges::variant	typeref:typename:variant &
operator =	include/range/v3/detail/variant.hpp	/^        variant & operator=(variant const & that)$/;"	f	struct:ranges::variant	typeref:typename:variant &
operator =	include/range/v3/experimental/utility/generator.hpp	/^            coroutine_owner & operator=(coroutine_owner that) noexcept$/;"	f	struct:ranges::experimental::coroutine_owner	typeref:typename:coroutine_owner &
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(T && t) -> CPP_ret(basic_proxy_reference_ &)( \/\/$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ &)(requires writable_cursor<Cur,T>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(T && t) const$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ const &)(requires writable_cursor<Cur,T>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference<OtherCur> && that) const$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ const &)(requires readable_cursor<OtherCur> && writable_cursor<Cur,cursor_reference_t<OtherCur>>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference<OtherCur> && that)$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ &)(requires readable_cursor<OtherCur> && writable_cursor<Cur,cursor_reference_t<OtherCur>>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference<OtherCur> const & that) const$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ const &)(requires readable_cursor<OtherCur> && writable_cursor<Cur,cursor_reference_t<OtherCur>>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference<OtherCur> const & that)$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ &)(requires readable_cursor<OtherCur> && writable_cursor<Cur,cursor_reference_t<OtherCur>>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference_ && that) const$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ const &)(requires readable_cursor<Cur>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference_ && that)$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ &)(requires readable_cursor<Cur>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference_ const & that) const$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ const &)(requires readable_cursor<Cur>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr auto operator=(basic_proxy_reference_ const & that)$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:CPP_ret (basic_proxy_reference_ &)(requires readable_cursor<Cur>)
operator =	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator=(basic_iterator<OtherCur> that)$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (basic_iterator &)(requires (!same_as<OtherCur,Cur>)&& convertible_to<OtherCur,Cur>)
operator =	include/range/v3/iterator/common_iterator.hpp	/^        auto operator=(common_iterator<I2, S2> const & that)$/;"	f	struct:ranges::common_iterator	typeref:typename:CPP_ret (common_iterator &)(requires convertible_to<I2,I> && convertible_to<S2,S>)
operator =	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator=(counted_iterator<I2> const & i)$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (counted_iterator &)(requires convertible_to<I2,I>)
operator =	include/range/v3/iterator/insert_iterators.hpp	/^        back_insert_iterator & operator=(typename Container::value_type && value)$/;"	f	struct:ranges::back_insert_iterator	typeref:typename:back_insert_iterator &
operator =	include/range/v3/iterator/insert_iterators.hpp	/^        back_insert_iterator & operator=(typename Container::value_type const & value)$/;"	f	struct:ranges::back_insert_iterator	typeref:typename:back_insert_iterator &
operator =	include/range/v3/iterator/insert_iterators.hpp	/^        front_insert_iterator & operator=(typename Container::value_type && value)$/;"	f	struct:ranges::front_insert_iterator	typeref:typename:front_insert_iterator &
operator =	include/range/v3/iterator/insert_iterators.hpp	/^        front_insert_iterator & operator=(typename Container::value_type const & value)$/;"	f	struct:ranges::front_insert_iterator	typeref:typename:front_insert_iterator &
operator =	include/range/v3/iterator/insert_iterators.hpp	/^        insert_iterator & operator=(typename Container::value_type && value)$/;"	f	struct:ranges::insert_iterator	typeref:typename:insert_iterator &
operator =	include/range/v3/iterator/insert_iterators.hpp	/^        insert_iterator & operator=(typename Container::value_type const & value)$/;"	f	struct:ranges::insert_iterator	typeref:typename:insert_iterator &
operator =	include/range/v3/iterator/move_iterators.hpp	/^        auto operator=(move_iterator<O> const & i) -> CPP_ret(move_iterator &)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (move_iterator &)(requires convertible_to<O,I>)
operator =	include/range/v3/iterator/move_iterators.hpp	/^        auto operator=(move_sentinel<OS> const & that) -> CPP_ret(move_sentinel &)( \/\/$/;"	f	struct:ranges::move_sentinel	typeref:typename:CPP_ret (move_sentinel &)(requires convertible_to<OS,S>)
operator =	include/range/v3/iterator/stream_iterators.hpp	/^        auto operator=(U && value) -> CPP_ret(ostream_iterator &)( \/\/$/;"	f	struct:ranges::ostream_iterator	typeref:typename:CPP_ret (ostream_iterator &)(requires convertible_to<U,value_t<U> const &>)
operator =	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_joiner & operator=(T const & value)$/;"	f	struct:ranges::ostream_joiner	typeref:typename:ostream_joiner &
operator =	include/range/v3/iterator/stream_iterators.hpp	/^        ostreambuf_iterator & operator=(Char c)$/;"	f	struct:ranges::ostreambuf_iterator	typeref:typename:ostreambuf_iterator &
operator =	include/range/v3/iterator_range.hpp	/^        auto operator=(iterator_range<X, Y> rng) -> CPP_ret(iterator_range &)( \/\/$/;"	f	struct:ranges::iterator_range	typeref:typename:CPP_ret (iterator_range &)(requires assignable_from<I &,X> && assignable_from<S &,Y>)
operator =	include/range/v3/iterator_range.hpp	/^        auto operator=(sized_iterator_range<X, Y> rng)$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:CPP_ret (sized_iterator_range &)(requires assignable_from<I &,X> && assignable_from<S &,Y>)
operator =	include/range/v3/utility/any.hpp	/^        any & operator=(any const & that)$/;"	f	struct:ranges::any	typeref:typename:any &
operator =	include/range/v3/utility/any.hpp	/^        auto operator=(TRef && t) -> CPP_ret(any &)( \/\/$/;"	f	struct:ranges::any	typeref:typename:CPP_ret (any &)(requires copyable<T> && (!same_as<T,any>))
operator =	include/range/v3/utility/box.hpp	/^        constant & operator=(T const &)$/;"	f	struct:ranges::constant	typeref:typename:constant &
operator =	include/range/v3/utility/box.hpp	/^        constant const & operator=(T const &) const$/;"	f	struct:ranges::constant	typeref:typename:constant const &
operator =	include/range/v3/utility/box.hpp	/^        mutable_ const & operator=(T && t) const$/;"	f	struct:ranges::mutable_	typeref:typename:mutable_ const &
operator =	include/range/v3/utility/box.hpp	/^        mutable_ const & operator=(T const & t) const$/;"	f	struct:ranges::mutable_	typeref:typename:mutable_ const &
operator =	include/range/v3/utility/common_tuple.hpp	/^            operator=(args_<N, Us...>)$/;"	f	struct:ranges::detail::args_	typeref:typename:meta::if_c<argsignable<args_,args_<N,Us...>>,args_ &>
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::pair<F2, S2> & that) const$/;"	f	struct:ranges::common_pair	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::pair<F2, S2> & that) noexcept($/;"	f	struct:ranges::common_pair	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::pair<F2, S2> && that) const noexcept($/;"	f	struct:ranges::common_pair	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::pair<F2, S2> && that) noexcept($/;"	f	struct:ranges::common_pair	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::pair<F2, S2> const & that) const$/;"	f	struct:ranges::common_pair	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::pair<F2, S2> const & that) noexcept($/;"	f	struct:ranges::common_pair	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::tuple<Us...> & that) const noexcept($/;"	f	struct:ranges::common_tuple	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::tuple<Us...> & that) noexcept($/;"	f	struct:ranges::common_tuple	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::tuple<Us...> && that) const noexcept($/;"	f	struct:ranges::common_tuple	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::tuple<Us...> && that) noexcept($/;"	f	struct:ranges::common_tuple	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::tuple<Us...> const & that) const$/;"	f	struct:ranges::common_tuple	typeref:typename:auto
operator =	include/range/v3/utility/common_tuple.hpp	/^        auto operator=(std::tuple<Us...> const & that) noexcept($/;"	f	struct:ranges::common_tuple	typeref:typename:auto
operator =	include/range/v3/utility/memory.hpp	/^        auto operator=(Val && val) -> CPP_ret(raw_storage_iterator &)( \/\/$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:CPP_ret (raw_storage_iterator &)(requires move_constructible<Val>)
operator =	include/range/v3/utility/memory.hpp	/^        auto operator=(Val const & val) -> CPP_ret(raw_storage_iterator &)( \/\/$/;"	f	struct:ranges::raw_storage_iterator	typeref:typename:CPP_ret (raw_storage_iterator &)(requires copy_constructible<Val>)
operator =	include/range/v3/utility/memory.hpp	/^        iterator_wrapper & operator=(iterator_wrapper const & that)$/;"	f	struct:ranges::iterator_wrapper	typeref:typename:iterator_wrapper &
operator =	include/range/v3/utility/optional.hpp	/^                optional_copy_assign & operator=(optional_copy_assign const & that) \/\/$/;"	f	struct:ranges::detail::optional_adl::optional_copy_assign	typeref:typename:optional_copy_assign &
operator =	include/range/v3/utility/optional.hpp	/^                optional_move_assign & operator=(optional_move_assign && that) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_move_assign	typeref:typename:optional_move_assign &
operator =	include/range/v3/utility/optional.hpp	/^            constexpr non_propagating_cache & operator=($/;"	f	struct:ranges::detail::non_propagating_cache	typeref:typename:non_propagating_cache &
operator =	include/range/v3/utility/optional.hpp	/^        constexpr auto operator=(U && u) noexcept($/;"	f	struct:ranges::optional	typeref:typename:auto
operator =	include/range/v3/utility/optional.hpp	/^        constexpr auto operator=(optional<U> && that) -> CPP_ret(optional &)( \/\/$/;"	f	struct:ranges::optional	typeref:typename:CPP_ret (optional &)(requires optional_should_convert_assign<U,T> && constructible_from<T,U> && assignable_from<T &,U>)
operator =	include/range/v3/utility/optional.hpp	/^        constexpr auto operator=(optional<U> const & that) -> CPP_ret(optional &)( \/\/$/;"	f	struct:ranges::optional	typeref:typename:CPP_ret (optional &)(requires optional_should_convert_assign<U,T> && constructible_from<T,const U &> && assignable_from<T &,const U &>)
operator =	include/range/v3/utility/optional.hpp	/^        constexpr optional & operator=(nullopt_t) noexcept$/;"	f	struct:ranges::optional	typeref:typename:optional &
operator =	include/range/v3/utility/semiregular_box.hpp	/^        semiregular_box & operator=(semiregular_box && that) noexcept($/;"	f	struct:ranges::semiregular_box	typeref:typename:semiregular_box &
operator =	include/range/v3/utility/semiregular_box.hpp	/^        semiregular_box & operator=(semiregular_box const & that) noexcept($/;"	f	struct:ranges::semiregular_box	typeref:typename:semiregular_box &
operator =	include/range/v3/utility/tagged_pair.hpp	/^        constexpr auto operator=(U && u) noexcept(noexcept($/;"	f	class:ranges::tagged	typeref:typename:auto
operator =	include/range/v3/utility/tagged_pair.hpp	/^        constexpr auto operator=(tagged<Other, Tags...> && that) noexcept($/;"	f	class:ranges::tagged	typeref:typename:auto
operator =	include/range/v3/utility/tagged_pair.hpp	/^        constexpr auto operator=(tagged<Other, Tags...> const & that) noexcept($/;"	f	class:ranges::tagged	typeref:typename:auto
operator =	include/range/v3/utility/variant.hpp	/^            auto operator=(R && r) -> CPP_ret(indexed_datum &)( \/\/$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_ret (indexed_datum &)(requires input_range<R> && assignable_from<T &,range_reference_t<R>>)
operator =	include/range/v3/utility/variant.hpp	/^            auto operator=(indexed_datum && that) -> CPP_ret(indexed_datum &)( \/\/$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_ret (indexed_datum &)(requires assignable_from<T &,T>)
operator =	include/range/v3/utility/variant.hpp	/^            auto operator=(indexed_datum const & that) -> CPP_ret(indexed_datum &)( \/\/$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:CPP_ret (indexed_datum &)(requires assignable_from<T &,T const &>)
operator =	include/range/v3/view/chunk.hpp	/^            constexpr zero & operator=(T const &) noexcept$/;"	f	struct:ranges::detail::zero	typeref:typename:zero &
operator =	include/range/v3/view/chunk.hpp	/^            constexpr zero const & operator=(T const &) const noexcept$/;"	f	struct:ranges::detail::zero	typeref:typename:zero const &
operator =	test/p.cpp	/^  S &operator=(S &&) noexcept {$/;"	f	struct:S	typeref:typename:S &	file:
operator =	test/p.cpp	/^  S &operator=(const S &) noexcept {$/;"	f	struct:S	typeref:typename:S &	file:
operator ==	include/ntskills.hpp	/^  bool operator==(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator ==	include/range/v3/detail/variant.hpp	/^    auto operator==(variant<Ts...> const & lhs, variant<Us...> const & rhs)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires and_v<equality_comparable_with<Ts,Us>...>)
operator ==	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator==(basic_proxy_reference_<Cur, IsReadable> const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (bool)(requires readable_cursor<Cur> && equality_comparable<cursor_value_t<Cur>>)
operator ==	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator==(cursor_value_t<Cur> const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (bool)(requires readable_cursor<Cur> && equality_comparable<cursor_value_t<Cur>>)
operator ==	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator==(S const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sentinel_for_cursor<S,Cur>)
operator ==	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator==(basic_iterator<Cur> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sentinel_for_cursor<Cur2,Cur>)
operator ==	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator==(basic_iterator<Cur> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sentinel_for_cursor<S,Cur>)
operator ==	include/range/v3/iterator/common_iterator.hpp	/^    auto operator==(common_iterator<I1, S1> const & x, common_iterator<I2, S2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires sentinel_for<S1,I2> && sentinel_for<S2,I1> && (!equality_comparable_with<I1,I2>))
operator ==	include/range/v3/iterator/common_iterator.hpp	/^    auto operator==(common_iterator<I1, S1> const & x, common_iterator<I2, S2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires sentinel_for<S1,I2> && sentinel_for<S2,I1> && equality_comparable_with<I1,I2>)
operator ==	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator==(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires common_with<I1,I2>)
operator ==	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr bool operator==(counted_iterator<I> const & x, default_sentinel_t)$/;"	f	namespace:ranges	typeref:typename:bool
operator ==	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr bool operator==(default_sentinel_t, counted_iterator<I> const & x)$/;"	f	namespace:ranges	typeref:typename:bool
operator ==	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr bool operator==(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator ==	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator==(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires equality_comparable_with<I,I2>)
operator ==	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator==(move_iterator<I> const & i, move_sentinel const & s)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires sentinel_for<S,I>)
operator ==	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator==(move_sentinel const & s, move_iterator<I> const & i)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires sentinel_for<S,I>)
operator ==	include/range/v3/iterator/unreachable_sentinel.hpp	/^        friend constexpr auto operator==(I const &, unreachable_sentinel_t) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator ==	include/range/v3/iterator/unreachable_sentinel.hpp	/^        friend constexpr auto operator==(unreachable_sentinel_t, I const &) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator ==	include/range/v3/range/conversion.hpp	/^            friend bool operator==(to_container_iterator const & a,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator ==	include/range/v3/utility/common_tuple.hpp	/^    auto operator==(common_pair<F1, S1> const & a, common_pair<F2, S2> const & b)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<F1,F2> && equality_comparable_with<S1,S2>)
operator ==	include/range/v3/utility/common_tuple.hpp	/^    auto operator==(common_pair<F1, S1> const & a, std::pair<F2, S2> const & b)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<F1,F2> && equality_comparable_with<S1,S2>)
operator ==	include/range/v3/utility/common_tuple.hpp	/^    auto operator==(std::pair<F1, S1> const & a, common_pair<F2, S2> const & b)$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<F1,F2> && equality_comparable_with<S1,S2>)
operator ==	include/range/v3/utility/infinity.hpp	/^        friend constexpr auto operator==(Integer, infinity) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator ==	include/range/v3/utility/infinity.hpp	/^        friend constexpr auto operator==(infinity, Integer) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
operator ==	include/range/v3/utility/infinity.hpp	/^        friend constexpr bool operator==(infinity, infinity)$/;"	f	namespace:ranges	typeref:typename:bool
operator ==	include/range/v3/utility/optional.hpp	/^            constexpr auto operator==(T const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator ==	include/range/v3/utility/optional.hpp	/^            constexpr auto operator==(optional<T> const & x, U const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator ==	include/range/v3/utility/optional.hpp	/^            constexpr auto operator==(optional<T> const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator ==	include/range/v3/utility/optional.hpp	/^            constexpr bool operator==(nullopt_t, optional<T> const & x) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator ==	include/range/v3/utility/optional.hpp	/^            constexpr bool operator==(optional<T> const & x, nullopt_t) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator ==	include/range/v3/view/span.hpp	/^        auto operator==(span<U, M> const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::span	typeref:typename:CPP_ret (bool)(requires equality_comparable_with<T,U>)
operator ==	include/range/v3/view/split.hpp	/^            friend constexpr auto operator==(split_inner_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (bool)(requires forward_range<Base>)
operator ==	include/range/v3/view/split.hpp	/^            friend constexpr auto operator==(split_outer_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (bool)(requires forward_range<Base>)
operator ==	include/range/v3/view/split.hpp	/^            friend constexpr bool operator==(default_sentinel_t,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator ==	include/range/v3/view/split.hpp	/^            friend constexpr bool operator==(split_inner_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator ==	include/range/v3/view/split.hpp	/^            friend constexpr bool operator==(split_outer_iterator const & x,$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator ==	include/range/v3/view/take.hpp	/^            friend constexpr bool operator==(CI const & y, sentinel const & x)$/;"	f	struct:ranges::take_view	typeref:typename:bool
operator ==	include/range/v3/view/take.hpp	/^            friend constexpr bool operator==(sentinel const & x, CI const & y)$/;"	f	struct:ranges::take_view	typeref:typename:bool
operator >	include/ntskills.hpp	/^  bool operator>(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator >	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator>(basic_iterator<Left> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sized_sentinel_for_cursor<Right,Left>)
operator >	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator>(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires common_with<I1,I2>)
operator >	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr bool operator>(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator >	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator>(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires totally_ordered_with<I,I2>)
operator >	include/range/v3/utility/optional.hpp	/^            constexpr auto operator>(T const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator >	include/range/v3/utility/optional.hpp	/^            constexpr auto operator>(optional<T> const & x, U const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator >	include/range/v3/utility/optional.hpp	/^            constexpr auto operator>(optional<T> const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator >	include/range/v3/utility/optional.hpp	/^            constexpr bool operator>(nullopt_t, optional<T> const &) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator >	include/range/v3/utility/optional.hpp	/^            constexpr bool operator>(optional<T> const & x, nullopt_t) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator >	include/range/v3/view/span.hpp	/^        auto operator>(span<U, M> const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::span	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator >=	include/ntskills.hpp	/^  bool operator>=(T const &other) const { return !(*this < other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator >=	include/range/v3/iterator/basic_iterator.hpp	/^    constexpr auto operator>=(basic_iterator<Left> const & left,$/;"	f	typeref:typename:CPP_ret (bool)(requires detail::sized_sentinel_for_cursor<Right,Left>)
operator >=	include/range/v3/iterator/counted_iterator.hpp	/^    constexpr auto operator>=(counted_iterator<I1> const & x,$/;"	f	namespace:ranges	typeref:typename:CPP_ret (bool)(requires common_with<I1,I2>)
operator >=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr bool operator>=(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
operator >=	include/range/v3/iterator/move_iterators.hpp	/^        friend auto operator>=(move_iterator const & x, move_iterator<I2> const & y)$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (bool)(requires totally_ordered_with<I,I2>)
operator >=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator>=(T const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator >=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator>=(optional<T> const & x, U const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator >=	include/range/v3/utility/optional.hpp	/^            constexpr auto operator>=(optional<T> const & x, optional<U> const & y) \/\/$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:auto
operator >=	include/range/v3/utility/optional.hpp	/^            constexpr bool operator>=(nullopt_t, optional<T> const & x) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator >=	include/range/v3/utility/optional.hpp	/^            constexpr bool operator>=(optional<T> const &, nullopt_t) noexcept$/;"	f	namespace:ranges::detail::optional_adl	typeref:typename:bool
operator >=	include/range/v3/view/span.hpp	/^        auto operator>=(span<U, M> const & that) const -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::span	typeref:typename:CPP_ret (bool)(requires totally_ordered_with<T,U>)
operator >>	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator>>(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator >>=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator>>=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator >>=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator>>=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator Destination	include/ntskills.hpp	/^    operator Destination() const { return this->underlying().get(); }$/;"	f	struct:nt::ImplicitlyConvertibleTo::templ
operator Head	include/range/v3/iterator/basic_iterator.hpp	/^            operator Head() const$/;"	f	struct:ranges::detail::proxy_reference_conversion
operator T	include/range/v3/utility/box.hpp	/^        constexpr operator T() const$/;"	f	struct:ranges::constant
operator T	include/range/v3/view/chunk.hpp	/^            constexpr operator T() const$/;"	f	struct:ranges::detail::zero
operator T&	include/ntskills.hpp	/^  operator T &() { return this->underlying().get(); }$/;"	f	namespace:nt	typeref:struct:FunctionCallable
operator T&	include/range/v3/utility/box.hpp	/^        constexpr operator T &() const &$/;"	f	struct:ranges::mutable_
operator T&	include/range/v3/utility/semiregular_box.hpp	/^        constexpr operator T &() & noexcept$/;"	f	struct:ranges::semiregular_box
operator T&&	include/range/v3/utility/semiregular_box.hpp	/^        constexpr operator T &&() && noexcept$/;"	f	struct:ranges::semiregular_box
operator []	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto operator[](difference_type n) const$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (const_reference_t)(requires detail::random_access_cursor<Cur>)
operator []	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto operator[](difference_type n) const$/;"	f	struct:ranges::counted_iterator	typeref:typename:CPP_ret (iter_reference_t<I>)(requires random_access_iterator<I>)
operator []	include/range/v3/iterator/move_iterators.hpp	/^        auto operator[](difference_type n) const -> CPP_ret(reference)( \/\/$/;"	f	struct:ranges::move_iterator	typeref:typename:CPP_ret (reference)(requires random_access_iterator<I>)
operator []	include/range/v3/range/conversion.hpp	/^            auto operator[](difference_type n) const -> CPP_ret(reference)($/;"	f	struct:ranges::detail::to_container_iterator	typeref:typename:CPP_ret (reference)(requires derived_from<iterator_category,std::random_access_iterator_tag>)
operator []	include/range/v3/view/interface.hpp	/^        constexpr auto operator[](range_difference_t<D<True>> n) const$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True> const>)(requires True && random_access_range<D<True> const>)
operator []	include/range/v3/view/interface.hpp	/^        constexpr auto operator[](range_difference_t<D<True>> n)$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (range_reference_t<D<True>>)(requires True && random_access_range<D<True>>)
operator []	include/range/v3/view/span.hpp	/^        constexpr reference operator[](index_type idx) const noexcept$/;"	f	struct:ranges::span	typeref:typename:reference
operator ^	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator^(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator ^	include/range/v3/view/any_view.hpp	/^    constexpr category operator^(category lhs, category rhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category
operator ^=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator^=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator ^=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator^=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator ^=	include/range/v3/view/any_view.hpp	/^    constexpr category & operator^=(category & lhs, category rhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category &
operator ref	include/nt.hpp	/^  operator ref() { return ref(value_); }$/;"	f	class:nt::NamedType
operator reference	include/range/v3/functional/reference_wrapper.hpp	/^        constexpr operator reference() const noexcept$/;"	f	struct:ranges::reference_wrapper
operator |	include/lr.hpp	/^template <typename A, typename F> decltype(auto) operator|(A &&a, F &&f) {$/;"	f	namespace:lr	typeref:typename:decltype (auto)
operator |	include/range/v3/action/action.hpp	/^            friend constexpr auto operator|(action_closure<ActionFn> act, Pipeable pipe)$/;"	f	namespace:ranges::actions	typeref:typename:CPP_broken_friend_ret (action_closure<composed<Pipeable,ActionFn>>)(requires (is_pipeable_v<Pipeable>))
operator |	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t operator|(diffmax_t a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t
operator |	include/range/v3/range/conversion.hpp	/^            friend auto operator|(Rng && rng, fn<ToContainer> (*)(to_container))$/;"	f	namespace:ranges::detail	typeref:typename:CPP_broken_friend_ret (container_t<ToContainer,Rng>)(requires invocable<fn<ToContainer>,Rng>)
operator |	include/range/v3/utility/copy.hpp	/^            friend constexpr auto operator|(T && t, copy_fn)$/;"	f	namespace:ranges::aux	typeref:typename:CPP_broken_friend_ret (detail::decay_t<T>)(requires constructible_from<detail::decay_t<T>,T>)
operator |	include/range/v3/utility/move.hpp	/^            friend constexpr decltype(auto) operator|(T && t, move_fn move) noexcept$/;"	f	namespace:ranges::aux	typeref:typename:decltype (auto)
operator |	include/range/v3/view/any_view.hpp	/^    constexpr category operator|(category lhs, category rhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category
operator |	include/range/v3/view/view.hpp	/^            friend constexpr auto operator|(view_closure<ViewFn> vw, Pipeable pipe)$/;"	f	namespace:ranges::views	typeref:typename:CPP_broken_friend_ret (view_closure<composed<Pipeable,ViewFn>>)(requires (is_pipeable_v<Pipeable>))
operator |=	include/range/v3/action/action.hpp	/^            friend constexpr auto operator|=(Rng & rng, action_closure<ActionFn> act) \/\/$/;"	f	namespace:ranges::actions	typeref:typename:CPP_broken_friend_ret (Rng &)(requires range<Rng> && invocable<ActionFn,Rng &>)
operator |=	include/range/v3/functional/pipeable.hpp	/^        friend auto operator|=(Arg & arg, Pipe pipe) \/\/$/;"	f	namespace:ranges	typeref:typename:CPP_broken_friend_ret (Arg &)(requires (is_pipeable_v<Pipe>)&& (!is_pipeable_v<Arg>)&& invocable<Pipe,Arg &>)
operator |=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr auto operator|=(T & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:auto
operator |=	include/range/v3/iterator/diffmax_t.hpp	/^            friend constexpr diffmax_t & operator|=(diffmax_t & a, diffmax_t b) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:diffmax_t &
operator |=	include/range/v3/view/any_view.hpp	/^    constexpr category & operator|=(category & lhs, category rhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category &
operator ~	include/range/v3/view/any_view.hpp	/^    constexpr category operator~(category lhs) noexcept$/;"	f	namespace:ranges	typeref:typename:category
operator_arrow_	include/range/v3/iterator/common_iterator.hpp	/^        static J operator_arrow_(J const & j, int) noexcept(noexcept(J(j)))$/;"	f	struct:ranges::common_iterator	typeref:typename:J
operator_arrow_	include/range/v3/iterator/common_iterator.hpp	/^        static T * operator_arrow_(T * p, int) noexcept$/;"	f	struct:ranges::common_iterator	typeref:typename:T *
operator_arrow_	include/range/v3/iterator/common_iterator.hpp	/^        static auto operator_arrow_(J const & j, ...) noexcept(noexcept(V(V(*j))))$/;"	f	struct:ranges::common_iterator	typeref:typename:auto
operator_arrow_	include/range/v3/iterator/common_iterator.hpp	/^        static auto operator_arrow_(J const & j, long) noexcept$/;"	f	struct:ranges::common_iterator	typeref:typename:auto
optional	include/range/v3/utility/optional.hpp	/^        constexpr optional() noexcept$/;"	f	struct:ranges::optional
optional	include/range/v3/utility/optional.hpp	/^        constexpr optional(nullopt_t) noexcept$/;"	f	struct:ranges::optional
optional	include/range/v3/utility/optional.hpp	/^    struct optional : detail::optional_adl::move_assign_layer<T>$/;"	s	namespace:ranges
optional_adl	include/range/v3/utility/optional.hpp	/^        namespace optional_adl$/;"	n	namespace:ranges::detail
optional_base	include/range/v3/utility/optional.hpp	/^            struct optional_base : private optional_storage<T>$/;"	s	namespace:ranges::detail::optional_adl
optional_base	include/range/v3/utility/optional.hpp	/^            struct optional_base<T &>$/;"	s	namespace:ranges::detail::optional_adl
optional_copy	include/range/v3/utility/optional.hpp	/^                optional_copy(optional_copy const & that) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_copy
optional_copy	include/range/v3/utility/optional.hpp	/^            struct optional_copy : optional_base<T>$/;"	s	namespace:ranges::detail::optional_adl
optional_copy_assign	include/range/v3/utility/optional.hpp	/^            struct optional_copy_assign : move_construct_layer<T>$/;"	s	namespace:ranges::detail::optional_adl
optional_move	include/range/v3/utility/optional.hpp	/^                optional_move(optional_move && that) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_move
optional_move	include/range/v3/utility/optional.hpp	/^            struct optional_move : copy_construct_layer<T>$/;"	s	namespace:ranges::detail::optional_adl
optional_move_assign	include/range/v3/utility/optional.hpp	/^            struct optional_move_assign : copy_assign_layer<T>$/;"	s	namespace:ranges::detail::optional_adl
optional_storage	include/range/v3/utility/optional.hpp	/^                constexpr optional_storage() noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_storage
optional_storage	include/range/v3/utility/optional.hpp	/^                constexpr optional_storage(tag, std::false_type) noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_storage
optional_storage	include/range/v3/utility/optional.hpp	/^                constexpr optional_storage(tag, std::true_type) noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_storage
optional_storage	include/range/v3/utility/optional.hpp	/^            struct optional_storage$/;"	s	namespace:ranges::detail::optional_adl
optional_storage	include/range/v3/utility/optional.hpp	/^            struct optional_storage<T, false>$/;"	s	namespace:ranges::detail::optional_adl
or_v	include/concepts/concepts.hpp	/^    CPP_INLINE_VAR constexpr bool or_v = (Bs ||...);$/;"	v	namespace:concepts	typeref:typename:CPP_INLINE_VAR bool
or_v	include/concepts/concepts.hpp	/^    CPP_INLINE_VAR constexpr bool or_v =$/;"	v	namespace:concepts	typeref:typename:CPP_INLINE_VAR bool
ordered_less	include/range/v3/functional/comparisons.hpp	/^    using ordered_less RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:less
ostream_iterator	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_iterator(ostream_type & s, Char const * d = nullptr) noexcept$/;"	f	struct:ranges::ostream_iterator
ostream_iterator	include/range/v3/iterator/stream_iterators.hpp	/^        using ostream_iterator = ranges::ostream_iterator<T, Char, Traits>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::ostream_iterator<T,Char,Traits>
ostream_iterator	include/range/v3/iterator/stream_iterators.hpp	/^    struct ostream_iterator$/;"	s	namespace:ranges
ostream_joiner	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_joiner(ostream_type & s, Delim && d)$/;"	f	struct:ranges::ostream_joiner
ostream_joiner	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_joiner(ostream_type & s, Delim const & d)$/;"	f	struct:ranges::ostream_joiner
ostream_joiner	include/range/v3/iterator/stream_iterators.hpp	/^    struct ostream_joiner$/;"	s	namespace:ranges
ostream_type	include/range/v3/iterator/stream_iterators.hpp	/^        typedef std::basic_ostream<Char, Traits> ostream_type;$/;"	t	struct:ranges::ostreambuf_iterator	typeref:typename:std::basic_ostream<Char,Traits>
ostream_type	include/range/v3/iterator/stream_iterators.hpp	/^        using ostream_type = std::basic_ostream<Char, Traits>;$/;"	t	struct:ranges::ostream_iterator	typeref:typename:std::basic_ostream<Char,Traits>
ostream_type	include/range/v3/iterator/stream_iterators.hpp	/^        using ostream_type = std::basic_ostream<Char, Traits>;$/;"	t	struct:ranges::ostream_joiner	typeref:typename:std::basic_ostream<Char,Traits>
ostreambuf_iterator	include/range/v3/iterator/stream_iterators.hpp	/^        ostreambuf_iterator(ostream_type & s) noexcept$/;"	f	struct:ranges::ostreambuf_iterator
ostreambuf_iterator	include/range/v3/iterator/stream_iterators.hpp	/^        ostreambuf_iterator(streambuf_type * s) noexcept$/;"	f	struct:ranges::ostreambuf_iterator
ostreambuf_iterator	include/range/v3/iterator/stream_iterators.hpp	/^    struct ostreambuf_iterator$/;"	s	namespace:ranges
out	include/range/v3/algorithm/result_types.hpp	/^            O out;$/;"	m	struct:ranges::detail::in1_in2_out_result	typeref:typename:O
out	include/range/v3/algorithm/result_types.hpp	/^            O out;$/;"	m	struct:ranges::detail::in1_out_result	typeref:typename:O
out	include/range/v3/algorithm/result_types.hpp	/^            O out;$/;"	m	struct:ranges::detail::in_out_result	typeref:typename:O
out	include/range/v3/algorithm/result_types.hpp	/^            O out;$/;"	m	struct:ranges::detail::out_fun_result	typeref:typename:O
out1	include/range/v3/algorithm/result_types.hpp	/^            O1 out1;$/;"	m	struct:ranges::detail::in_out1_out2_result	typeref:typename:O1
out2	include/range/v3/algorithm/result_types.hpp	/^            O2 out2;$/;"	m	struct:ranges::detail::in_out1_out2_result	typeref:typename:O2
out_	include/range/v3/utility/memory.hpp	/^        O out_;$/;"	m	struct:ranges::raw_storage_iterator	typeref:typename:O
out_fun_result	include/range/v3/algorithm/result_types.hpp	/^        struct out_fun_result$/;"	s	namespace:ranges::detail
outer_	include/range/v3/view/join.hpp	/^        Outer outer_{};$/;"	m	struct:ranges::join_with_view	typeref:typename:Outer
outer_	include/range/v3/view/join.hpp	/^        Rng outer_{};$/;"	m	struct:ranges::join_view	typeref:typename:Rng
outer_cursor	include/range/v3/view/chunk.hpp	/^            constexpr explicit outer_cursor(chunk_view_ * view) noexcept$/;"	f	struct:ranges::chunk_view_::outer_cursor
outer_cursor	include/range/v3/view/chunk.hpp	/^        struct outer_cursor$/;"	s	struct:ranges::chunk_view_
outer_it_	include/range/v3/view/join.hpp	/^            iterator_t<COuter> outer_it_{};$/;"	m	struct:ranges::join_view::cursor	typeref:typename:iterator_t<COuter>
outer_it_	include/range/v3/view/join.hpp	/^            iterator_t<Outer> outer_it_{};$/;"	m	class:ranges::join_with_view::cursor	typeref:typename:iterator_t<Outer>
outer_iterator	include/range/v3/view/split.hpp	/^        using outer_iterator = detail::split_outer_iterator<split_view, Const>;$/;"	t	struct:ranges::split_view	typeref:typename:detail::split_outer_iterator<split_view,Const>
overload_fn	include/range/v3/functional/overload.hpp	/^    struct overload_fn$/;"	s	namespace:ranges
overloaded	include/overloaded.hpp	/^template <class... Ts> struct overloaded : Ts... { using Ts::operator()...; };$/;"	s
overloaded	include/range/v3/functional/overload.hpp	/^        constexpr overloaded(First first, Rest... rest)$/;"	f	struct:ranges::overloaded
overloaded	include/range/v3/functional/overload.hpp	/^    struct overloaded<>$/;"	s	namespace:ranges
overloaded	include/range/v3/functional/overload.hpp	/^    struct overloaded<First, Rest...>$/;"	s	namespace:ranges
pair_like	include/range/v3/view/subrange.hpp	/^        struct pair_like : meta::bool_<pair_like_<T>>$/;"	s	namespace:ranges::detail
param	include/range/v3/utility/random.hpp	/^                RANGES_INTENDED_MODULAR_ARITHMETIC auto param(O dest) const$/;"	f	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:CPP_ret (void)(requires weakly_incrementable<O> && indirectly_copyable<decltype (mixer_.begin ()),O>)
param_t	include/range/v3/algorithm/sample.hpp	/^                    using param_t = typename decltype(dist)::param_type;$/;"	t	function:ranges::RANGES_FUNC_BEGIN
param_t	include/range/v3/algorithm/sample.hpp	/^                using param_t = typename decltype(dist)::param_type;$/;"	t	function:ranges::detail::sample_sized_impl
param_t	include/range/v3/algorithm/shuffle.hpp	/^            using param_t = typename decltype(uid)::param_type;$/;"	t	function:ranges::RANGES_FUNC_BEGIN
parent_	include/range/v3/view/cache1.hpp	/^            cache1_view * parent_;$/;"	m	struct:ranges::cache1_view::cursor	typeref:typename:cache1_view *
parent_	include/range/v3/view/partial_sum.hpp	/^            Parent * parent_ = nullptr;$/;"	m	struct:ranges::partial_sum_view::cursor	typeref:typename:Parent *
parent_	include/range/v3/view/sample.hpp	/^            meta::const_if_c<IsConst, sample_view> * parent_;$/;"	m	class:ranges::sample_view::cursor	typeref:typename:meta::const_if_c<IsConst,sample_view> *
parent_	include/range/v3/view/split.hpp	/^            Parent * parent_ = nullptr;$/;"	m	struct:ranges::detail::split_outer_iterator	typeref:typename:Parent *
partial_sum_base_fn	include/range/v3/view/partial_sum.hpp	/^        struct partial_sum_base_fn$/;"	s	namespace:ranges::views
partial_sum_fn	include/range/v3/numeric/partial_sum.hpp	/^    struct partial_sum_fn$/;"	s	namespace:ranges
partial_sum_fn	include/range/v3/view/partial_sum.hpp	/^        struct partial_sum_fn : partial_sum_base_fn$/;"	s	namespace:ranges::views
partial_sum_result	include/range/v3/numeric/partial_sum.hpp	/^    using partial_sum_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
partial_sum_view	include/range/v3/view/partial_sum.hpp	/^        constexpr partial_sum_view(Rng rng, Fun fun) noexcept($/;"	f	struct:ranges::partial_sum_view
partial_sum_view	include/range/v3/view/partial_sum.hpp	/^    struct partial_sum_view$/;"	s	namespace:ranges
partition_copy_result	include/range/v3/algorithm/partition_copy.hpp	/^    using partition_copy_result = detail::in_out1_out2_result<I, O0, O1>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out1_out2_result<I,O0,O1>
partition_impl	include/range/v3/algorithm/partition.hpp	/^        I partition_impl(I first, S end_, C pred, P proj,$/;"	f	namespace:ranges::detail	typeref:typename:I
partition_impl	include/range/v3/algorithm/partition.hpp	/^        I partition_impl(I first, S last, C pred, P proj, detail::forward_iterator_tag_)$/;"	f	namespace:ranges::detail	typeref:typename:I
partition_point_n_fn	include/range/v3/algorithm/aux_/partition_point_n.hpp	/^        struct partition_point_n_fn$/;"	s	namespace:ranges::aux
pass_thru_inner_	include/range/v3/view/join.hpp	/^        struct pass_thru_inner_$/;"	s	namespace:ranges::detail
pattern_	include/range/v3/view/split.hpp	/^        Pattern pattern_ = Pattern();$/;"	m	struct:ranges::split_view	typeref:typename:Pattern
pf	test/oset.cpp	/^template <typename... Args> std::string pf(Args &&...) {$/;"	f	typeref:typename:std::string
pipeable	include/range/v3/functional/pipeable.hpp	/^    using pipeable RANGES_DEPRECATED("Please use pipeable_base instead") = pipeable_base;$/;"	t	namespace:ranges	typeref:typename:pipeable_base
pipeable_access	include/range/v3/functional/pipeable.hpp	/^    struct pipeable_access$/;"	s	namespace:ranges
pipeable_base	include/range/v3/functional/pipeable.hpp	/^    struct pipeable_base$/;"	s	namespace:ranges
pith	include/git_.hpp	/^  Pith pith;$/;"	m	struct:abo::Bark	typeref:typename:Pith
pith	include/union.hpp	/^  P pith;$/;"	m	struct:abo::union_fn	typeref:typename:P
plus	include/meta/meta.hpp	/^        using plus = defer<plus, T, U>;$/;"	t	namespace:meta::lazy	typeref:typename:defer<plus,T,U>
plus	include/meta/meta.hpp	/^    using plus = std::integral_constant<decltype(T::type::value + U::type::value),$/;"	t	namespace:meta
plus	include/range/v3/functional/arithmetic.hpp	/^    struct plus$/;"	s	namespace:ranges
pointer	include/range/v3/action/concepts.hpp	/^            using pointer = T *;$/;"	t	struct:ranges::detail::movable_input_iterator	typeref:typename:T *
pointer	include/range/v3/iterator/basic_iterator.hpp	/^            using pointer = meta::_t<$/;"	t	struct:ranges::iterator_associated_types_base_
pointer	include/range/v3/iterator/common_iterator.hpp	/^            using pointer = detail::iter_pointer_t<I>;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:detail::iter_pointer_t<I>
pointer	include/range/v3/iterator/common_iterator.hpp	/^            using pointer = void;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:void
pointer	include/range/v3/iterator/counted_iterator.hpp	/^            using pointer = void;$/;"	t	struct:ranges::_counted_iterator_::iterator_traits_	typeref:typename:void
pointer	include/range/v3/range/conversion.hpp	/^            using pointer = typename std::iterator_traits<I>::pointer;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:std::iterator_traits<I>::pointer
pointer	include/range/v3/view/span.hpp	/^        using pointer = T *;$/;"	t	struct:ranges::span	typeref:typename:T *
pointer	include/range/v3/view/split.hpp	/^            using pointer = iter_pointer_t<iterator_t<Base>>; \/\/ Not to spec$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:iter_pointer_t<iterator_t<Base>>
pointer	include/range/v3/view/split.hpp	/^            using pointer = value_type *; \/\/ Not to spec$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:value_type *
pointer	test/p.cpp	/^  using pointer = value_type *;$/;"	t	struct:aiterator	typeref:typename:value_type *	file:
polymorphic_downcast	include/range/v3/utility/polymorphic_cast.hpp	/^    auto polymorphic_downcast(Source && x) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
polymorphic_downcast	include/range/v3/utility/polymorphic_cast.hpp	/^    auto polymorphic_downcast(Source * x) noexcept$/;"	f	namespace:ranges	typeref:typename:auto
pop_heap_n_fn	include/range/v3/algorithm/heap_algorithm.hpp	/^        struct pop_heap_n_fn$/;"	s	namespace:ranges::detail
pop_size	include/range/v3/view/sample.hpp	/^            D pop_size()$/;"	f	class:ranges::sample_view::cursor	typeref:typename:D
pos	include/range/v3/detail/range_access.hpp	/^        static constexpr Cur & pos(basic_iterator<Cur> & it) noexcept$/;"	f	struct:ranges::range_access	typeref:typename:Cur &
pos	include/range/v3/detail/range_access.hpp	/^        static constexpr Cur && pos(basic_iterator<Cur> && it) noexcept$/;"	f	struct:ranges::range_access	typeref:typename:Cur &&
pos	include/range/v3/detail/range_access.hpp	/^        static constexpr Cur const & pos(basic_iterator<Cur> const & it) noexcept$/;"	f	struct:ranges::range_access	typeref:typename:Cur const &
pos	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr Cur & pos() noexcept$/;"	f	struct:basic_iterator	typeref:typename:Cur &
pos	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr Cur const & pos() const noexcept$/;"	f	struct:basic_iterator	typeref:typename:Cur const &
pos	include/range/v3/view/concat.hpp	/^                cursor * pos;$/;"	m	struct:ranges::concat_view::cursor::advance_fwd_fun	typeref:typename:cursor *
pos	include/range/v3/view/concat.hpp	/^                cursor * pos;$/;"	m	struct:ranges::concat_view::cursor::advance_rev_fun	typeref:typename:cursor *
pos	include/range/v3/view/concat.hpp	/^                cursor * pos;$/;"	m	struct:ranges::concat_view::cursor::next_fun	typeref:typename:cursor *
pos	include/range/v3/view/concat.hpp	/^                cursor * pos;$/;"	m	struct:ranges::concat_view::cursor::prev_fun	typeref:typename:cursor *
pos_at_	include/range/v3/view/slice.hpp	/^        iterator_t<Rng> pos_at_(Rng && rng, Int i, bidirectional_range_tag,$/;"	f	namespace:ranges::detail	typeref:typename:iterator_t<Rng>
pos_at_	include/range/v3/view/slice.hpp	/^        iterator_t<Rng> pos_at_(Rng && rng, Int i, input_range_tag, std::false_type)$/;"	f	namespace:ranges::detail	typeref:typename:iterator_t<Rng>
pos_at_	include/range/v3/view/slice.hpp	/^        iterator_t<Rng> pos_at_(Rng && rng, Int i, input_range_tag, std::true_type)$/;"	f	namespace:ranges::detail	typeref:typename:iterator_t<Rng>
post_inc	include/range/v3/view/split.hpp	/^            constexpr split_inner_iterator post_inc(std::true_type) \/\/ Forward$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:split_inner_iterator
post_inc	include/range/v3/view/split.hpp	/^            constexpr split_outer_iterator post_inc(std::true_type) \/\/ Forward$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:split_outer_iterator
post_inc	include/range/v3/view/split.hpp	/^            constexpr void post_inc(std::false_type) \/\/ Input$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:void
post_inc	include/range/v3/view/split.hpp	/^            constexpr void post_inc(std::false_type) \/\/ Input$/;"	f	struct:ranges::detail::split_outer_iterator	typeref:typename:void
post_increment_	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr auto post_increment_(std::true_type, int) \/\/$/;"	f	struct:basic_iterator	typeref:typename:CPP_ret (detail::postfix_increment_proxy<V>)(requires constructible_from<V,typename A::reference> && move_constructible<V>)
post_increment_	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr basic_iterator post_increment_(std::false_type, int)$/;"	f	struct:basic_iterator	typeref:typename:basic_iterator
post_increment_	include/range/v3/iterator/basic_iterator.hpp	/^        constexpr void post_increment_(std::true_type, long)$/;"	f	struct:basic_iterator	typeref:typename:void
post_increment_	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr auto post_increment_(std::false_type) -> decltype(current_++)$/;"	f	struct:ranges::counted_iterator	typeref:typename:decltype (current_++)
post_increment_	include/range/v3/iterator/counted_iterator.hpp	/^        constexpr void post_increment_(std::true_type)$/;"	f	struct:ranges::counted_iterator	typeref:typename:void
postfix_increment_proxy	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr postfix_increment_proxy(T && t)$/;"	f	struct:ranges::postfix_increment_proxy
postfix_increment_proxy	include/range/v3/iterator/basic_iterator.hpp	/^        struct postfix_increment_proxy$/;"	s	namespace:ranges
pre_inc	include/range/v3/view/split.hpp	/^            constexpr void pre_inc(std::false_type) \/\/ Input$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:void
pre_inc	include/range/v3/view/split.hpp	/^            constexpr void pre_inc(std::true_type) \/\/ Forward$/;"	f	struct:ranges::detail::split_inner_iterator	typeref:typename:void
pred	include/range/v3/view/group_by.hpp	/^            struct pred$/;"	s	struct:ranges::group_by_view::cursor
pred_	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^            Pred & pred_;$/;"	m	struct:ranges::detail::lower_bound_predicate	typeref:typename:Pred &
pred_	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^            Pred * pred_;$/;"	m	struct:ranges::detail::upper_bound_predicate	typeref:typename:Pred *
pred_	include/range/v3/functional/not_fn.hpp	/^        RANGES_NO_UNIQUE_ADDRESS FD pred_;$/;"	m	struct:ranges::logical_negate	typeref:typename:RANGES_NO_UNIQUE_ADDRESS FD
pred_	include/range/v3/view/drop_while.hpp	/^        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Pred> pred_;$/;"	m	struct:ranges::drop_while_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Pred>
pred_	include/range/v3/view/remove.hpp	/^            struct pred_$/;"	s	struct:ranges::views::remove_base_fn
pred_	include/range/v3/view/set_algorithm.hpp	/^            pred_ref_ pred_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:pred_ref_
pred_	include/range/v3/view/set_algorithm.hpp	/^            pred_ref_ pred_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:pred_ref_
pred_	include/range/v3/view/set_algorithm.hpp	/^            pred_ref_ pred_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:pred_ref_
pred_	include/range/v3/view/set_algorithm.hpp	/^            pred_ref_ pred_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:pred_ref_
pred_	include/range/v3/view/set_algorithm.hpp	/^            semiregular_box_t<C> pred_;$/;"	m	struct:ranges::detail::set_algorithm_view	typeref:typename:semiregular_box_t<C>
pred_	include/range/v3/view/split_when.hpp	/^                semiregular_box_t<Pred> pred_;$/;"	m	struct:ranges::views::split_when_base_fn::predicate_pred_	typeref:typename:semiregular_box_t<Pred>
pred_	include/range/v3/view/take_while.hpp	/^            RANGES_NO_UNIQUE_ADDRESS semiregular_box_ref_or_val_t<Pred, IsConst> pred_;$/;"	m	struct:ranges::iter_take_while_view::sentinel_adaptor	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_ref_or_val_t<Pred,IsConst>
pred_	include/range/v3/view/take_while.hpp	/^        RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Pred> pred_;$/;"	m	struct:ranges::iter_take_while_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<Pred>
pred_	include/range/v3/view/trim.hpp	/^        semiregular_box_t<Pred> pred_;$/;"	m	struct:ranges::trim_view	typeref:typename:semiregular_box_t<Pred>
pred_ref_	include/range/v3/view/set_algorithm.hpp	/^            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:semiregular_box_ref_or_val_t<C,IsConst>
pred_ref_	include/range/v3/view/set_algorithm.hpp	/^            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:semiregular_box_ref_or_val_t<C,IsConst>
pred_ref_	include/range/v3/view/set_algorithm.hpp	/^            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:semiregular_box_ref_or_val_t<C,IsConst>
pred_ref_	include/range/v3/view/set_algorithm.hpp	/^            using pred_ref_ = semiregular_box_ref_or_val_t<C, IsConst>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:semiregular_box_ref_or_val_t<C,IsConst>
predicate_pred_	include/range/v3/view/split_when.hpp	/^            struct predicate_pred_$/;"	s	struct:ranges::views::split_when_base_fn
prev	include/range/v3/iterator/common_iterator.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I>)
prev	include/range/v3/iterator/move_iterators.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I>)
prev	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr void prev()$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:void
prev	include/range/v3/view/adaptor.hpp	/^        static auto prev(I & it) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::adaptor_base	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I>)
prev	include/range/v3/view/adaptor.hpp	/^        void prev()$/;"	f	struct:ranges::adaptor_cursor	typeref:typename:void
prev	include/range/v3/view/adjacent_filter.hpp	/^            constexpr auto prev(iterator_t<CRng> & it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::adjacent_filter_view::adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<CRng>)
prev	include/range/v3/view/adjacent_remove_if.hpp	/^            constexpr auto prev(iterator_t<Rng> & it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::adjacent_remove_if_view::adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<Rng>)
prev	include/range/v3/view/cartesian_product.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:CPP_ret (void)(requires cartesian_produce_view_can_bidi<IsConst,Views...>)
prev	include/range/v3/view/chunk.hpp	/^            constexpr auto prev(iterator_t<CRng> & it) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<CRng>)
prev	include/range/v3/view/concat.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:CPP_ret (void)(requires and_v<bidirectional_range<Rngs>...>)
prev	include/range/v3/view/cycle.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:CPP_ret (void)(requires bidirectional_range<CRng>)
prev	include/range/v3/view/enumerate.hpp	/^                void prev()$/;"	f	struct:ranges::detail::index_view::cursor	typeref:typename:void
prev	include/range/v3/view/intersperse.hpp	/^            constexpr auto prev(iterator_t<CRng> & it) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<CRng>)
prev	include/range/v3/view/iota.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:CPP_ret (void)(requires detail::decrementable_<From>)
prev	include/range/v3/view/iota.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:CPP_ret (void)(requires detail::decrementable_<From>)
prev	include/range/v3/view/join.hpp	/^            constexpr auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::join_view::cursor	typeref:typename:CPP_ret (void)(requires ref_is_glvalue::value && bidirectional_range<COuter> && bidirectional_range<CInner> && common_range<CInner>)
prev	include/range/v3/view/remove_if.hpp	/^            constexpr auto prev(iterator_t<Rng> & it) const -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::remove_if_view::adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<Rng>)
prev	include/range/v3/view/repeat.hpp	/^            void prev()$/;"	f	struct:ranges::repeat_view::cursor	typeref:typename:void
prev	include/range/v3/view/repeat_n.hpp	/^            void prev()$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:void
prev	include/range/v3/view/sliding.hpp	/^            auto prev() -> CPP_ret(void)(requires bidirectional_range<Rng>)$/;"	f	struct:ranges::sliding_view_detail::trailing	typeref:typename:CPP_ret (void)(requires bidirectional_range<Rng>)
prev	include/range/v3/view/sliding.hpp	/^            auto prev(iterator_t<Rng> & it) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<Rng>)
prev	include/range/v3/view/sliding.hpp	/^            void prev()$/;"	f	struct:ranges::sliding_view_detail::trailing	typeref:typename:void
prev	include/range/v3/view/stride.hpp	/^            constexpr auto prev(iterator_t<CRng> & it) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::stride_view::adaptor	typeref:typename:CPP_ret (void)(requires bidirectional_range<CRng>)
prev	include/range/v3/view/subrange.hpp	/^        RANGES_NODISCARD constexpr auto prev(iter_difference_t<I> n = 1) const$/;"	f	struct:ranges::subrange	typeref:typename:CPP_ret (subrange)(requires bidirectional_iterator<I>)
prev	include/range/v3/view/transform.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::iter_transform2_view::cursor	typeref:typename:CPP_ret (void)(requires bidirectional_range<R1> && bidirectional_range<R2>)
prev	include/range/v3/view/zip_with.hpp	/^            auto prev() -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::iter_zip_with_view::cursor	typeref:typename:CPP_ret (void)(requires and_v<bidirectional_range<meta::const_if_c<Const,Rngs>>...>)
prev_	include/range/v3/view/cartesian_product.hpp	/^            void prev_(meta::size_t<0>)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
prev_	include/range/v3/view/cartesian_product.hpp	/^            void prev_(meta::size_t<N>)$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:void
prev_fn	include/range/v3/iterator/operations.hpp	/^    struct prev_fn$/;"	s	namespace:ranges
prev_fun	include/range/v3/view/concat.hpp	/^            struct prev_fun$/;"	s	struct:ranges::concat_view::cursor
prev_or_zero_	include/range/v3/view/tail.hpp	/^        constexpr T prev_or_zero_(T n)$/;"	f	namespace:ranges::detail	typeref:typename:T
print	example/for_each_assoc.cpp	/^auto print = [](int i) { cout << i << ' '; };$/;"	v	typeref:typename:auto
print	example/for_each_sequence.cpp	/^auto print = [](int i) { cout << i << ' '; };$/;"	v	typeref:typename:auto
print	include/ntskills.hpp	/^  void print(std::ostream &os) const { os << this->underlying().get(); }$/;"	f	struct:nt::Printable	typeref:typename:void
print_rng_	include/range/v3/view/interface.hpp	/^        Stream & print_rng_(Stream & sout, Rng & rng)$/;"	f	namespace:ranges::detail	typeref:typename:Stream &
printm	example/for_each_assoc.cpp	/^auto printm = [](std::pair<string, int> p) {$/;"	v	typeref:typename:auto
private_	include/range/v3/iterator/basic_iterator.hpp	/^            struct private_$/;"	s	struct:ranges::detail::cursor_traits_
probe_	include/range/v3/view/drop_last.hpp	/^            iterator_t<Rng> probe_;$/;"	m	struct:ranges::drop_last_view::adaptor	typeref:typename:iterator_t<Rng>
probe_begin	include/range/v3/view/drop_last.hpp	/^        detail::non_propagating_cache<iterator_t<Rng>> probe_begin;$/;"	m	struct:ranges::drop_last_view	typeref:typename:detail::non_propagating_cache<iterator_t<Rng>>
product_cardinality	include/range/v3/view/cartesian_product.hpp	/^        using product_cardinality = std::integral_constant<$/;"	t	namespace:ranges::detail
proj1_	include/range/v3/view/set_algorithm.hpp	/^            proj1_ref_ proj1_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:proj1_ref_
proj1_	include/range/v3/view/set_algorithm.hpp	/^            proj1_ref_ proj1_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:proj1_ref_
proj1_	include/range/v3/view/set_algorithm.hpp	/^            proj1_ref_ proj1_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:proj1_ref_
proj1_	include/range/v3/view/set_algorithm.hpp	/^            proj1_ref_ proj1_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:proj1_ref_
proj1_	include/range/v3/view/set_algorithm.hpp	/^            semiregular_box_t<P1> proj1_;$/;"	m	struct:ranges::detail::set_algorithm_view	typeref:typename:semiregular_box_t<P1>
proj1_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:semiregular_box_ref_or_val_t<P1,IsConst>
proj1_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:semiregular_box_ref_or_val_t<P1,IsConst>
proj1_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:semiregular_box_ref_or_val_t<P1,IsConst>
proj1_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj1_ref_ = semiregular_box_ref_or_val_t<P1, IsConst>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:semiregular_box_ref_or_val_t<P1,IsConst>
proj2_	include/range/v3/view/set_algorithm.hpp	/^            proj2_ref_ proj2_;$/;"	m	struct:ranges::detail::set_difference_cursor	typeref:typename:proj2_ref_
proj2_	include/range/v3/view/set_algorithm.hpp	/^            proj2_ref_ proj2_;$/;"	m	struct:ranges::detail::set_intersection_cursor	typeref:typename:proj2_ref_
proj2_	include/range/v3/view/set_algorithm.hpp	/^            proj2_ref_ proj2_;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:proj2_ref_
proj2_	include/range/v3/view/set_algorithm.hpp	/^            proj2_ref_ proj2_;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:typename:proj2_ref_
proj2_	include/range/v3/view/set_algorithm.hpp	/^            semiregular_box_t<P2> proj2_;$/;"	m	struct:ranges::detail::set_algorithm_view	typeref:typename:semiregular_box_t<P2>
proj2_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:semiregular_box_ref_or_val_t<P2,IsConst>
proj2_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:semiregular_box_ref_or_val_t<P2,IsConst>
proj2_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:semiregular_box_ref_or_val_t<P2,IsConst>
proj2_ref_	include/range/v3/view/set_algorithm.hpp	/^            using proj2_ref_ = semiregular_box_ref_or_val_t<P2, IsConst>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:semiregular_box_ref_or_val_t<P2,IsConst>
projected	include/range/v3/iterator/concepts.hpp	/^    using projected = typename detail::select_projected_<Proj>::template apply<I>;$/;"	t	namespace:ranges	typeref:typename:detail::select_projected_<Proj>::template apply<I>
projected_	include/range/v3/iterator/concepts.hpp	/^        struct projected_$/;"	s	namespace:ranges::detail
promise	include/range/v3/experimental/utility/generator.hpp	/^            promise_type const & promise() const noexcept$/;"	f	struct:ranges::experimental::sized_generator	typeref:typename:promise_type const &
promise_type	include/range/v3/experimental/utility/generator.hpp	/^            using promise_type = detail::generator_promise<Reference>;$/;"	t	struct:ranges::experimental::generator	typeref:typename:detail::generator_promise<Reference>
promise_type	include/range/v3/experimental/utility/generator.hpp	/^            using promise_type = detail::sized_generator_promise<Reference>;$/;"	t	struct:ranges::experimental::sized_generator	typeref:typename:detail::sized_generator_promise<Reference>
promote_as_signed_	include/range/v3/view/iota.hpp	/^        struct promote_as_signed_$/;"	s	namespace:ranges::detail
protect_fn	include/range/v3/functional/bind.hpp	/^    struct protect_fn$/;"	s	namespace:ranges
protector	include/range/v3/functional/bind.hpp	/^        protector(Bind b)$/;"	f	struct:ranges::protector
protector	include/range/v3/functional/bind.hpp	/^    struct protector$/;"	s	namespace:ranges
proxy_reference_conversion	include/range/v3/iterator/basic_iterator.hpp	/^        struct proxy_reference_conversion$/;"	s	namespace:ranges::detail
ptr_	include/range/v3/utility/any.hpp	/^        std::unique_ptr<interface> ptr_;$/;"	m	struct:ranges::any	typeref:typename:std::unique_ptr<interface>
ptr_	include/range/v3/utility/optional.hpp	/^                T * ptr_ = nullptr;$/;"	m	struct:ranges::detail::optional_adl::optional_base	typeref:typename:T *
push_back	include/range/v3/action/push_back.hpp	/^        auto push_back(Cont && cont, Rng && rng) -> CPP_ret(insert_t<Cont, Rng>)( \/\/$/;"	f	namespace:ranges::adl_push_back_detail	typeref:typename:CPP_ret (insert_t<Cont,Rng>)(requires lvalue_container_like<Cont> && range<Rng>)
push_back	include/range/v3/action/push_back.hpp	/^        auto push_back(Cont && cont, T && t) -> CPP_ret(push_back_t<Cont, T>)( \/\/$/;"	f	namespace:ranges::adl_push_back_detail	typeref:typename:CPP_ret (push_back_t<Cont,T>)(requires lvalue_container_like<Cont> && (!range<T>)&& constructible_from<range_value_t<Cont>,T>)
push_back_fn	include/range/v3/action/push_back.hpp	/^        struct push_back_fn$/;"	s	namespace:ranges::adl_push_back_detail
push_back_t	include/range/v3/action/push_back.hpp	/^        using push_back_t = decltype(static_cast<void>($/;"	t	namespace:ranges::adl_push_back_detail
push_front	include/range/v3/action/push_front.hpp	/^        auto push_front(Cont && cont, Rng && rng) -> CPP_ret(insert_t<Cont, Rng>)( \/\/$/;"	f	namespace:ranges::adl_push_front_detail	typeref:typename:CPP_ret (insert_t<Cont,Rng>)(requires lvalue_container_like<Cont> && range<Rng>)
push_front	include/range/v3/action/push_front.hpp	/^        auto push_front(Cont && cont, T && t) -> CPP_ret(push_front_t<Cont, T>)( \/\/$/;"	f	namespace:ranges::adl_push_front_detail	typeref:typename:CPP_ret (push_front_t<Cont,T>)(requires lvalue_container_like<Cont> && (!range<T>)&& constructible_from<range_value_t<Cont>,T>)
push_front_fn	include/range/v3/action/push_front.hpp	/^        struct push_front_fn$/;"	s	namespace:ranges::adl_push_front_detail
push_front_t	include/range/v3/action/push_front.hpp	/^        using push_front_t = decltype(static_cast<void>($/;"	t	namespace:ranges::adl_push_front_detail
quiet_NaN	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t quiet_NaN() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
radix	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr int radix = 2;$/;"	m	struct:std::numeric_limits	typeref:typename:int
radix	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr int numeric_limits<::ranges::detail::diffmax_t>::radix;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:int
random_access	include/range/v3/view/any_view.hpp	/^        random_access = 15,   \/\/\/<\\brief satisfies ranges::concepts::random_access_range$/;"	e	enum:ranges::category
random_access_cursor_tag	include/range/v3/detail/range_access.hpp	/^        using random_access_cursor_tag =$/;"	t	namespace:ranges::detail	typeref:typename:concepts::tag<random_access_cursor_concept,bidirectional_cursor_tag>
random_access_iterator_tag	include/range/v3/iterator/traits.hpp	/^    using random_access_iterator_tag RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:std::random_access_iterator_tag
random_access_iterator_tag_	include/range/v3/iterator/traits.hpp	/^        using random_access_iterator_tag_ =$/;"	t	namespace:ranges::detail	typeref:typename:::concepts::tag<random_access_iterator_concept,bidirectional_iterator_tag_>
random_access_range_tag	include/range/v3/range/concepts.hpp	/^    using random_access_range_tag =$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<random_access_range_concept,bidirectional_range_tag>
randutils	include/range/v3/utility/random.hpp	/^        namespace randutils$/;"	n	namespace:ranges::detail
range_access	include/range/v3/detail/range_access.hpp	/^    struct range_access$/;"	s	namespace:ranges
range_cardinality	include/range/v3/range/traits.hpp	/^    struct range_cardinality$/;"	s	namespace:ranges
range_category_t	include/range/v3/range/traits.hpp	/^    using range_category_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:meta::_t<detail::iterator_category<iterator_t<Rng>>>
range_common_iterator_t	include/range/v3/range/traits.hpp	/^    using range_common_iterator_t = common_iterator_t<iterator_t<Rng>, sentinel_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:common_iterator_t<iterator_t<Rng>,sentinel_t<Rng>>
range_common_reference_t	include/range/v3/range/traits.hpp	/^    using range_common_reference_t = iter_common_reference_t<iterator_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:iter_common_reference_t<iterator_t<Rng>>
range_cpp17_iterator_t	include/range/v3/range/traits.hpp	/^        using range_cpp17_iterator_t = cpp17_iterator_t<iterator_t<Rng>, sentinel_t<Rng>>;$/;"	t	namespace:ranges::detail	typeref:typename:cpp17_iterator_t<iterator_t<Rng>,sentinel_t<Rng>>
range_difference_t	include/range/v3/range/traits.hpp	/^    using range_difference_t = iter_difference_t<iterator_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:iter_difference_t<iterator_t<Rng>>
range_difference_type_t	include/range/v3/range/traits.hpp	/^    using range_difference_type_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:iter_difference_t<iterator_t<Rng>>
range_distance_	include/meta/meta.hpp	/^        constexpr std::size_t range_distance_(T begin, T end)$/;"	f	namespace:meta::detail	typeref:typename:std::size_t
range_reference_t	include/range/v3/range/traits.hpp	/^    using range_reference_t = iter_reference_t<iterator_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:iter_reference_t<iterator_t<Rng>>
range_rvalue_reference_t	include/range/v3/range/traits.hpp	/^    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:iter_rvalue_reference_t<iterator_t<Rng>>
range_size_t	include/range/v3/range/traits.hpp	/^    using range_size_t = decltype(ranges::size(std::declval<Rng &>()));$/;"	t	namespace:ranges
range_size_type_t	include/range/v3/range/traits.hpp	/^    using range_size_type_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:detail::iter_size_t<iterator_t<Rng>>
range_tag	include/range/v3/range/concepts.hpp	/^    using range_tag = ::concepts::tag<range_concept>;$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<range_concept>
range_tag_of	include/range/v3/range/concepts.hpp	/^    using range_tag_of = ::concepts::tag_of<$/;"	t	namespace:ranges	typeref:typename:::concepts::tag_of<meta::list<contiguous_range_concept,random_access_range_concept,bidirectional_range_concept,forward_range_concept,input_range_concept,range_concept>,T>
range_value_t	include/range/v3/range/traits.hpp	/^    using range_value_t = iter_value_t<iterator_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:iter_value_t<iterator_t<Rng>>
range_value_type_t	include/range/v3/range/traits.hpp	/^    using range_value_type_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:iter_value_t<iterator_t<Rng>>
ranges	example/calendar.cpp	/^namespace ranges$/;"	n	file:
ranges	include/range/v3/action/action.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/adjacent_remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/concepts.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/drop.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/drop_while.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/erase.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/insert.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/join.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/push_back.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/push_front.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/remove.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/reverse.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/shuffle.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/slice.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/sort.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/split.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/split_when.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/stable_sort.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/stride.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/take.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/take_while.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/transform.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/unique.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/action/unstable_remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/adjacent_find.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/adjacent_remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/all_of.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/any_of.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/equal_range_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/merge_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/merge_n_with_buffer.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/partition_point_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/binary_search.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/copy_backward.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/copy_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/copy_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/count.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/count_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/ends_with.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/equal.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/equal_range.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/fill.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/fill_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/find.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/find_end.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/find_first_of.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/find_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/find_if_not.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/for_each.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/for_each_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/generate.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/generate_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/heap_algorithm.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/inplace_merge.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/is_partitioned.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/is_sorted.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/is_sorted_until.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/lexicographical_compare.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/lower_bound.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/max.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/max_element.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/merge.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/min.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/min_element.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/minmax.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/minmax_element.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/mismatch.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/move.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/move_backward.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/none_of.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/nth_element.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/partial_sort.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/partial_sort_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/partition.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/partition_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/partition_point.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/permutation.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/remove.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/remove_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/remove_copy_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/replace.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/replace_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/replace_copy_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/replace_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/result_types.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/reverse.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/reverse_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/rotate.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/rotate_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/sample.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/search.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/search_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/set_algorithm.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/shuffle.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/sort.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/stable_partition.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/stable_sort.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/starts_with.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/swap_ranges.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/tagspec.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/transform.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/unique.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/unique_copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/unstable_remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/algorithm/upper_bound.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/detail/adl_get.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/detail/config.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/detail/range_access.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/detail/variant.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/detail/with_braced_init_args.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/experimental/utility/generator.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/experimental/view/shared.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/arithmetic.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/bind.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/bind_back.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/comparisons.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/compose.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/concepts.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/identity.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/indirect.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/invoke.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/not_fn.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/on.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/overload.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/pipeable.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/functional/reference_wrapper.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/access.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/basic_iterator.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/common_iterator.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/concepts.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/counted_iterator.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/default_sentinel.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/diffmax_t.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/insert_iterators.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/move_iterators.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/operations.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/reverse_iterator.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/stream_iterators.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/traits.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator/unreachable_sentinel.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/iterator_range.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/numeric/accumulate.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/numeric/adjacent_difference.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/numeric/inner_product.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/numeric/iota.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/numeric/partial_sum.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/access.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/concepts.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/conversion.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/dangling.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/operations.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/primitives.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range/traits.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/range_fwd.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/addressof.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/any.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/box.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/common_tuple.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/common_type.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/compressed_pair.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/copy.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/functional.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/get.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/in_place.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/infinity.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/memory.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/move.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/nullptr_v.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/optional.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/polymorphic_cast.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/random.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/scope_exit.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/semiregular_box.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/static_const.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/swap.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/tagged_pair.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/tagged_tuple.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/tuple_algorithm.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/utility/variant.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/adaptor.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/addressof.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/adjacent_filter.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/adjacent_remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/all.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/any_view.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/c_str.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/cache1.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/cartesian_product.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/chunk.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/common.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/concat.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/const.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/counted.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/cycle.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/delimit.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/drop.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/drop_exactly.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/drop_last.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/drop_while.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/empty.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/enumerate.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/exclusive_scan.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/facade.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/filter.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/for_each.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/generate.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/generate_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/getlines.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/group_by.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/indices.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/indirect.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/interface.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/intersperse.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/iota.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/istream.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/join.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/linear_distribute.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/map.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/move.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/partial_sum.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/ref.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/remove.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/remove_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/repeat.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/repeat_n.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/replace.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/replace_if.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/reverse.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/sample.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/set_algorithm.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/single.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/slice.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/sliding.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/span.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/split.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/split_when.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/stride.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/subrange.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/tail.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/take.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/take_exactly.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/take_last.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/take_while.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/tokenize.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/transform.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/trim.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/unbounded.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/unique.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/view.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/zip.hpp	/^namespace ranges$/;"	n
ranges	include/range/v3/view/zip_with.hpp	/^namespace ranges$/;"	n
ranges	include/std/detail/associated_types.hpp	/^namespace ranges$/;"	n
rargs	include/range/v3/utility/common_tuple.hpp	/^        using rargs = args_<sizeof...(Ts), Ts &...>;$/;"	t	namespace:ranges::detail
raw_buffer	include/range/v3/utility/memory.hpp	/^        explicit raw_buffer(Val * first)$/;"	f	struct:ranges::raw_buffer
raw_buffer	include/range/v3/utility/memory.hpp	/^    struct raw_buffer$/;"	s	namespace:ranges
raw_storage_iterator	include/range/v3/utility/memory.hpp	/^        explicit raw_storage_iterator(O out)$/;"	f	struct:ranges::raw_storage_iterator
raw_storage_iterator	include/range/v3/utility/memory.hpp	/^    struct raw_storage_iterator$/;"	s	namespace:ranges
rbegin	include/range/v3/view/span.hpp	/^        constexpr reverse_iterator rbegin() const noexcept$/;"	f	struct:ranges::span	typeref:typename:reverse_iterator
read	example/calendar.cpp	/^    decltype(auto) read() const$/;"	f	struct:interleave_view::cursor	typeref:typename:decltype (auto)	file:
read	include/range/v3/experimental/utility/generator.hpp	/^                Reference read() const$/;"	f	struct:ranges::experimental::generator::cursor	typeref:typename:Reference
read	include/range/v3/experimental/utility/generator.hpp	/^            meta::if_<std::is_reference<Reference>, Reference, Reference const &> read()$/;"	f	struct:ranges::detail::generator_promise	typeref:typename:meta::if_<std::is_reference<Reference>,Reference,Reference const &>
read	include/range/v3/iterator/common_iterator.hpp	/^            decltype(auto) read() const$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:decltype (auto)
read	include/range/v3/iterator/common_iterator.hpp	/^            decltype(auto) read()$/;"	f	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:decltype (auto)
read	include/range/v3/iterator/move_iterators.hpp	/^            auto read() const noexcept(noexcept(*std::declval<I const &>()))$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:CPP_member auto
read	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr auto read() const -> iter_reference_t<I>$/;"	f	struct:ranges::detail::reverse_cursor	typeref:typename:iter_reference_t<I>
read	include/range/v3/view/adaptor.hpp	/^        R read() const noexcept($/;"	f	struct:ranges::adaptor_cursor	typeref:typename:R
read	include/range/v3/view/adaptor.hpp	/^        static auto read(I const & it, detail::adaptor_base_current_mem_fn = {}) noexcept($/;"	f	struct:ranges::adaptor_base	typeref:typename:auto
read	include/range/v3/view/any_view.hpp	/^            Ref read() const$/;"	f	struct:ranges::detail::any_input_cursor	typeref:typename:Ref
read	include/range/v3/view/any_view.hpp	/^            virtual Ref read() const override$/;"	f	struct:ranges::detail::any_input_view_impl	typeref:typename:Ref
read	include/range/v3/view/cache1.hpp	/^            range_value_t<Rng> && read() const$/;"	f	struct:ranges::cache1_view::cursor	typeref:typename:range_value_t<Rng> &&
read	include/range/v3/view/cartesian_product.hpp	/^            common_tuple<range_reference_t<constify_if<Views>>...> read() const$/;"	f	struct:ranges::cartesian_product_view::cursor	typeref:typename:common_tuple<range_reference_t<constify_if<Views>>...>
read	include/range/v3/view/chunk.hpp	/^                constexpr iter_reference_t<iterator_t<Rng>> read() const$/;"	f	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:iter_reference_t<iterator_t<Rng>>
read	include/range/v3/view/chunk.hpp	/^            constexpr auto read(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::chunk_view_::adaptor	typeref:typename:decltype (views::take (make_subrange (it,end_),n_))
read	include/range/v3/view/chunk.hpp	/^            constexpr inner_view read() const$/;"	f	struct:ranges::chunk_view_::outer_cursor	typeref:typename:inner_view
read	include/range/v3/view/concat.hpp	/^            reference read() const$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:reference
read	include/range/v3/view/const.hpp	/^            reference_ read(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::const_view::adaptor	typeref:typename:reference_
read	include/range/v3/view/enumerate.hpp	/^                Size read() const$/;"	f	struct:ranges::detail::index_view::cursor	typeref:typename:Size
read	include/range/v3/view/exclusive_scan.hpp	/^            T read(iterator_t<CRng> const &) const$/;"	f	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:T
read	include/range/v3/view/generate.hpp	/^            result_t && read() const$/;"	f	struct:ranges::generate_view::cursor	typeref:typename:result_t &&
read	include/range/v3/view/generate_n.hpp	/^            result_t && read() const$/;"	f	struct:ranges::generate_n_view::cursor	typeref:typename:result_t &&
read	include/range/v3/view/getlines.hpp	/^            std::string & read() const noexcept$/;"	f	struct:ranges::getlines_view::cursor	typeref:typename:std::string &
read	include/range/v3/view/group_by.hpp	/^            auto read() const$/;"	f	struct:ranges::group_by_view::cursor
read	include/range/v3/view/intersperse.hpp	/^            constexpr range_value_t<Rng> read(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:range_value_t<Rng>
read	include/range/v3/view/iota.hpp	/^            From read() const$/;"	f	struct:ranges::closed_iota_view::cursor	typeref:typename:From
read	include/range/v3/view/iota.hpp	/^            From read() const$/;"	f	struct:ranges::iota_view::cursor	typeref:typename:From
read	include/range/v3/view/istream.hpp	/^            Val & read() const noexcept$/;"	f	struct:ranges::istream_view::cursor	typeref:typename:Val &
read	include/range/v3/view/join.hpp	/^            reference read() const$/;"	f	class:ranges::join_with_view::cursor	typeref:typename:reference
read	include/range/v3/view/linear_distribute.hpp	/^            constexpr T read() const noexcept$/;"	f	struct:ranges::views::linear_distribute_view	typeref:typename:T
read	include/range/v3/view/move.hpp	/^            range_rvalue_reference_t<CRng> read(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::move_view::adaptor	typeref:typename:range_rvalue_reference_t<CRng>
read	include/range/v3/view/partial_sum.hpp	/^            constexpr range_value_t<Rng> read() const$/;"	f	struct:ranges::partial_sum_view::cursor	typeref:typename:range_value_t<Rng>
read	include/range/v3/view/repeat.hpp	/^            Val const & read() const noexcept$/;"	f	struct:ranges::repeat_view::cursor	typeref:typename:Val const &
read	include/range/v3/view/repeat_n.hpp	/^            Val const & read() const$/;"	f	struct:ranges::repeat_n_view::cursor	typeref:typename:Val const &
read	include/range/v3/view/sample.hpp	/^            range_reference_t<Rng> read() const$/;"	f	class:ranges::sample_view::cursor	typeref:typename:range_reference_t<Rng>
read	include/range/v3/view/set_algorithm.hpp	/^            reference_type read() const noexcept(noexcept(*it1_) && noexcept(*it2_))$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:reference_type
read	include/range/v3/view/set_algorithm.hpp	/^            reference_type read() const noexcept(noexcept(*it1_) && noexcept(*it2_))$/;"	f	struct:ranges::detail::set_union_cursor	typeref:typename:reference_type
read	include/range/v3/view/sliding.hpp	/^            auto read(iterator_t<CRng> const & it) const$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:decltype (views::counted (uncounted (it),n_))
read	include/range/v3/view/sliding.hpp	/^            auto read(iterator_t<Rng> const & it) const$/;"	f	struct:ranges::sliding_view::adaptor	typeref:typename:decltype (views::counted (uncounted (it),n_))
read	include/range/v3/view/split_when.hpp	/^            reference_ read() const$/;"	f	struct:ranges::split_when_view::cursor	typeref:typename:reference_
read_	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr reference_t_ read_() const noexcept($/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:reference_t_
readable_iterator_associated_types_base	include/range/v3/iterator/basic_iterator.hpp	/^        struct readable_iterator_associated_types_base : range_access::mixin_base_t<Cur>$/;"	s	namespace:ranges::detail
readable_traits	include/range/v3/iterator/traits.hpp	/^        using readable_traits = ranges::readable_traits<T>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::readable_traits<T>
readable_traits_1_	include/std/detail/associated_types.hpp	/^        struct readable_traits_1_ : readable_traits_2_<T>$/;"	s	namespace:ranges::detail
readable_traits_1_	include/std/detail/associated_types.hpp	/^        struct readable_traits_1_<T *> : detail::with_value_type_<T>$/;"	s	namespace:ranges::detail
readable_traits_1_	include/std/detail/associated_types.hpp	/^        struct readable_traits_1_<T[N]> : with_value_type_<T>$/;"	s	namespace:ranges::detail
readable_traits_1_	include/std/detail/associated_types.hpp	/^        struct readable_traits_1_<T[]> : with_value_type_<T>$/;"	s	namespace:ranges::detail
readable_traits_2_	include/std/detail/associated_types.hpp	/^        struct readable_traits_2_$/;"	s	namespace:ranges::detail
recounted	include/range/v3/iterator/operations.hpp	/^        constexpr I recounted(I const &, I i, iter_difference_t<I>)$/;"	f	namespace:ranges::adl_uncounted_recounted_detail	typeref:typename:I
recounted_fn	include/range/v3/iterator/operations.hpp	/^        struct recounted_fn$/;"	s	namespace:ranges::adl_uncounted_recounted_detail
recurse	include/meta/meta.hpp	/^            recurse$/;"	e	enum:meta::detail::indices_strategy_
ref	include/nt.hpp	/^  using ref = NamedType<T &, Parameter, Skills...>;$/;"	t	class:nt::NamedType	typeref:typename:NamedType<T &,Parameter,Skills...>
ref	include/range/v3/detail/variant.hpp	/^            constexpr indexed_element<T &&, Index::value> ref() const noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<T &&,Index::value>
ref	include/range/v3/detail/variant.hpp	/^            constexpr indexed_element<T &, Index::value> ref() const noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<T &,Index::value>
ref	include/range/v3/detail/variant.hpp	/^            constexpr indexed_element<T const, Index::value> ref() const noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<T const,Index::value>
ref	include/range/v3/detail/variant.hpp	/^            constexpr indexed_element<T, Index::value> ref() noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<T,Index::value>
ref	include/range/v3/detail/variant.hpp	/^            constexpr indexed_element<void, Index::value> ref() const noexcept$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<void,Index::value>
ref	include/range/v3/utility/variant.hpp	/^            constexpr indexed_element<T const [N], Index::value> ref() const {$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<T const[N],Index::value>
ref	include/range/v3/utility/variant.hpp	/^            constexpr indexed_element<T[N], Index::value> ref()$/;"	f	struct:ranges::detail::indexed_datum	typeref:typename:indexed_element<T[N],Index::value>
ref_	include/range/v3/detail/variant.hpp	/^            reference_wrapper<T &&> ref_;$/;"	m	struct:ranges::detail::indexed_datum	typeref:typename:reference_wrapper<T &&>
ref_	include/range/v3/detail/variant.hpp	/^            reference_wrapper<T &> ref_;$/;"	m	struct:ranges::detail::indexed_datum	typeref:typename:reference_wrapper<T &>
ref_	include/range/v3/detail/variant.hpp	/^        reference_wrapper<T> ref_;$/;"	m	struct:ranges::indexed_element	typeref:typename:reference_wrapper<T>
ref_	include/range/v3/experimental/utility/generator.hpp	/^            semiregular_box_t<Reference> ref_;$/;"	m	struct:ranges::detail::generator_promise	typeref:typename:semiregular_box_t<Reference>
ref_fn	include/range/v3/functional/reference_wrapper.hpp	/^    struct ref_fn$/;"	s	namespace:ranges
ref_fn	include/range/v3/view/ref.hpp	/^        struct ref_fn$/;"	s	namespace:ranges::views
ref_is_glvalue	include/range/v3/view/join.hpp	/^            using ref_is_glvalue = std::is_reference<CInner>;$/;"	t	struct:ranges::join_view::cursor	typeref:typename:std::is_reference<CInner>
ref_t	include/range/v3/functional/reference_wrapper.hpp	/^    using ref_t = decltype(ref(std::declval<T>()));$/;"	t	namespace:ranges
ref_t	include/range/v3/utility/scope_exit.hpp	/^        using ref_t = decltype(std::ref(std::declval<Fun const &>()));$/;"	t	struct:ranges::scope_exit
ref_view	include/range/v3/view/ref.hpp	/^            using ref_view = ranges::ref_view<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::ref_view<Rng>
ref_view	include/range/v3/view/ref.hpp	/^        constexpr ref_view(Rng & rng) noexcept$/;"	f	struct:ranges::ref_view
ref_view	include/range/v3/view/ref.hpp	/^    struct ref_view$/;"	s	namespace:ranges
refcount_	include/range/v3/experimental/utility/generator.hpp	/^            std::atomic<unsigned int> refcount_{1};$/;"	m	class:ranges::experimental::enable_coroutine_owner	typeref:typename:std::atomic<unsigned int>
reference	include/range/v3/action/concepts.hpp	/^            using reference = T &&;$/;"	t	struct:ranges::detail::movable_input_iterator	typeref:typename:T &&
reference	include/range/v3/functional/reference_wrapper.hpp	/^        using reference = meta::if_<std::is_reference<T>, T, T &>;$/;"	t	struct:ranges::reference_wrapper	typeref:typename:meta::if_<std::is_reference<T>,T,T &>
reference	include/range/v3/iterator/basic_iterator.hpp	/^            using reference = iter_reference_t;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:iter_reference_t
reference	include/range/v3/iterator/basic_iterator.hpp	/^            using reference = void;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:void
reference	include/range/v3/iterator/common_iterator.hpp	/^            using reference = iter_reference_t<I>;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:iter_reference_t<I>
reference	include/range/v3/iterator/common_iterator.hpp	/^            using reference = void;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:void
reference	include/range/v3/iterator/concepts.hpp	/^            using reference = indirect_result_t<Proj &, I>;$/;"	t	struct:ranges::detail::projected_	typeref:typename:indirect_result_t<Proj &,I>
reference	include/range/v3/iterator/counted_iterator.hpp	/^            using reference = void;$/;"	t	struct:ranges::_counted_iterator_::iterator_traits_	typeref:typename:void
reference	include/range/v3/iterator/move_iterators.hpp	/^        using reference = iter_rvalue_reference_t<I>;$/;"	t	struct:ranges::move_iterator	typeref:typename:iter_rvalue_reference_t<I>
reference	include/range/v3/range/conversion.hpp	/^            using reference = ValueType;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:ValueType
reference	include/range/v3/view/concat.hpp	/^            using reference = common_reference_t<range_reference_t<constify_if<Rngs>>...>;$/;"	t	struct:ranges::concat_view::cursor	typeref:typename:common_reference_t<range_reference_t<constify_if<Rngs>>...>
reference	include/range/v3/view/join.hpp	/^            using reference =$/;"	t	class:ranges::join_with_view::cursor	typeref:typename:common_reference_t<range_reference_t<Inner>,range_reference_t<ValRng>>
reference	include/range/v3/view/span.hpp	/^        using reference = T &;$/;"	t	struct:ranges::span	typeref:typename:T &
reference	include/range/v3/view/split.hpp	/^            using reference = range_reference_t<Base>;        \/\/ Not to spec$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:range_reference_t<Base>
reference	include/range/v3/view/split.hpp	/^            using reference = value_type; \/\/ Not to spec$/;"	t	struct:ranges::detail::split_outer_iterator	typeref:typename:value_type
reference	test/p.cpp	/^  using reference = value_type &;$/;"	t	struct:aiterator	typeref:typename:value_type &	file:
reference_	include/range/v3/view/const.hpp	/^            using reference_ =$/;"	t	struct:ranges::const_view::adaptor	typeref:typename:common_reference_t<value_ const &&,range_reference_t<CRng>>
reference_	include/range/v3/view/split_when.hpp	/^            using reference_ =$/;"	t	struct:ranges::split_when_view::cursor	typeref:typename:indirect_view<take_while_view<iota_view<iterator_t<CRng>>,search_pred>>
reference_t	include/range/v3/iterator/traits.hpp	/^    using reference_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:iter_reference_t<R>
reference_t_	include/range/v3/iterator/basic_iterator.hpp	/^            using reference_t_ = cursor_reference_t<Cur>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:cursor_reference_t<Cur>
reference_t_	include/range/v3/iterator/basic_iterator.hpp	/^            using reference_t_ = private_;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:private_
reference_type	include/range/v3/view/set_algorithm.hpp	/^            using reference_type =$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:common_reference_t<range_reference_t<R1>,range_reference_t<R2>>
reference_type	include/range/v3/view/set_algorithm.hpp	/^            using reference_type =$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:common_reference_t<range_reference_t<R1>,range_reference_t<R2>>
reference_wrapper	include/range/v3/functional/reference_wrapper.hpp	/^    struct reference_wrapper : private detail::reference_wrapper_<T>$/;"	s	namespace:ranges
reference_wrapper_	include/range/v3/functional/reference_wrapper.hpp	/^            constexpr reference_wrapper_(T & t) noexcept$/;"	f	struct:ranges::detail::reference_wrapper_
reference_wrapper_	include/range/v3/functional/reference_wrapper.hpp	/^            constexpr reference_wrapper_(T && t) noexcept$/;"	f	struct:ranges::detail::reference_wrapper_
reference_wrapper_	include/range/v3/functional/reference_wrapper.hpp	/^        struct reference_wrapper_$/;"	s	namespace:ranges::detail
reference_wrapper_	include/range/v3/functional/reference_wrapper.hpp	/^        struct reference_wrapper_<T &&>$/;"	s	namespace:ranges::detail
reference_wrapper_	include/range/v3/functional/reference_wrapper.hpp	/^        struct reference_wrapper_<T &> : reference_wrapper_<T>$/;"	s	namespace:ranges::detail
remainder_	include/range/v3/view/chunk.hpp	/^        range_difference_t<Rng> remainder_;$/;"	m	struct:ranges::chunk_view_	typeref:typename:range_difference_t<Rng>
remove_base_fn	include/range/v3/view/remove.hpp	/^        struct remove_base_fn$/;"	s	namespace:ranges::views
remove_copy_if_result	include/range/v3/algorithm/remove_copy_if.hpp	/^    using remove_copy_if_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
remove_copy_result	include/range/v3/algorithm/remove_copy.hpp	/^    using remove_copy_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
remove_cvref_t	include/concepts/concepts.hpp	/^        using remove_cvref_t =$/;"	t	namespace:concepts::detail	typeref:typename:std::remove_cv<typename std::remove_reference<T>::type>::type
remove_cvref_t	include/concepts/type_traits.hpp	/^    using remove_cvref_t =$/;"	t	namespace:concepts	typeref:typename:std::remove_cv<typename std::remove_reference<T>::type>::type
remove_fn	include/range/v3/action/remove.hpp	/^        struct remove_fn$/;"	s	namespace:ranges::actions
remove_fn	include/range/v3/view/remove.hpp	/^        struct remove_fn : remove_base_fn$/;"	s	namespace:ranges::views
remove_if_base_fn	include/range/v3/view/remove_if.hpp	/^        struct remove_if_base_fn$/;"	s	namespace:ranges::views
remove_if_fn	include/range/v3/action/remove_if.hpp	/^        struct remove_if_fn$/;"	s	namespace:ranges::actions
remove_if_fn	include/range/v3/view/remove_if.hpp	/^        struct remove_if_fn : remove_if_base_fn$/;"	s	namespace:ranges::views
remove_if_view	include/range/v3/view/remove_if.hpp	/^        constexpr remove_if_view(Rng rng, Pred pred)$/;"	f	struct:ranges::remove_if_view
remove_if_view	include/range/v3/view/remove_if.hpp	/^    struct RANGES_EMPTY_BASES remove_if_view$/;"	s	namespace:ranges
rend	include/range/v3/view/span.hpp	/^        constexpr reverse_iterator rend() const noexcept$/;"	f	struct:ranges::span	typeref:typename:reverse_iterator
repeat	include/meta/meta.hpp	/^            repeat,$/;"	e	enum:meta::detail::indices_strategy_
repeat_fn	include/range/v3/view/repeat.hpp	/^        struct repeat_fn$/;"	s	namespace:ranges::views
repeat_n_fn	include/range/v3/view/repeat_n.hpp	/^        struct repeat_n_fn$/;"	s	namespace:ranges::views
repeat_n_view	include/range/v3/view/repeat_n.hpp	/^        constexpr repeat_n_view(Val value, std::ptrdiff_t n)$/;"	f	struct:ranges::repeat_n_view
repeat_n_view	include/range/v3/view/repeat_n.hpp	/^    struct repeat_n_view : view_facade<repeat_n_view<Val>, finite>$/;"	s	namespace:ranges
repeat_view	include/range/v3/view/repeat.hpp	/^        constexpr explicit repeat_view(Val value)$/;"	f	struct:ranges::repeat_view
repeat_view	include/range/v3/view/repeat.hpp	/^    struct repeat_view : view_facade<repeat_view<Val>, infinite>$/;"	s	namespace:ranges
replace_base_fn	include/range/v3/view/replace.hpp	/^        struct replace_base_fn$/;"	s	namespace:ranges::views
replace_copy_if_result	include/range/v3/algorithm/replace_copy_if.hpp	/^    using replace_copy_if_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
replace_copy_result	include/range/v3/algorithm/replace_copy.hpp	/^    using replace_copy_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
replace_fn	include/range/v3/view/replace.hpp	/^        struct replace_fn : replace_base_fn$/;"	s	namespace:ranges::views
replace_if_base_fn	include/range/v3/view/replace_if.hpp	/^        struct replace_if_base_fn$/;"	s	namespace:ranges::views
replace_if_fn	include/range/v3/view/replace_if.hpp	/^        struct replace_if_fn : replace_if_base_fn$/;"	s	namespace:ranges::views
replacer_fn	include/range/v3/view/replace.hpp	/^            constexpr replacer_fn(Val1 old_value, Val2 new_value)$/;"	f	struct:ranges::detail::replacer_fn
replacer_fn	include/range/v3/view/replace.hpp	/^        struct replacer_fn$/;"	s	namespace:ranges::detail
replacer_if_fn	include/range/v3/view/replace_if.hpp	/^            constexpr replacer_if_fn(Pred pred, Val new_value)$/;"	f	struct:ranges::detail::replacer_if_fn
replacer_if_fn	include/range/v3/view/replace_if.hpp	/^        struct replacer_if_fn : compressed_pair<semiregular_box_t<Pred>, Val>$/;"	s	namespace:ranges::detail
repo	include/git.hpp	/^  const UPtr<git_repository> &repo;$/;"	m	struct:git::TreeBark	typeref:typename:const UPtr<git_repository> &
requires_	include/concepts/concepts.hpp	/^        constexpr bool requires_()$/;"	f	namespace:concepts::detail	typeref:typename:bool
requires_	include/concepts/concepts.hpp	/^    CPP_INLINE_VAR constexpr std::enable_if_t<B, int> requires_ = 0;$/;"	v	namespace:concepts	typeref:typename:CPP_INLINE_VAR std::enable_if_t<B,int>
requires_	include/concepts/concepts.hpp	/^    std::enable_if_t<B> requires_()$/;"	f	namespace:concepts	typeref:typename:std::enable_if_t<B>
res_t	include/range/v3/detail/variant.hpp	/^                using res_t = meta::_t<$/;"	t	function:ranges::detail::variant_get::get	typeref:typename:meta::_t<std::add_rvalue_reference<meta::at_c<meta::as_list<Variant>,N>>>
reset	example/comprehensions.cpp	/^  void reset() { start_ = std::chrono::high_resolution_clock::now(); }$/;"	f	class:timer	typeref:typename:void	file:
reset	include/range/v3/utility/optional.hpp	/^                constexpr void reset() noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:void
reset	include/range/v3/utility/optional.hpp	/^                constexpr void reset() noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_storage	typeref:typename:void
reset	include/range/v3/utility/optional.hpp	/^                void reset() noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_storage	typeref:typename:void
reset	include/range/v3/utility/semiregular_box.hpp	/^        void reset()$/;"	f	struct:ranges::semiregular_box	typeref:typename:void
result_	include/range/v3/range/concepts.hpp	/^            bool result_;$/;"	m	struct:ranges::detail::enable_view_helper_	typeref:typename:bool
result_of	include/range/v3/functional/invoke.hpp	/^        "Please use ranges::invoke_result") result_of$/;"	s	namespace:ranges
result_of	include/range/v3/functional/invoke.hpp	/^        "Please use ranges::invoke_result") result_of<Fun(Args...)>$/;"	s	namespace:ranges
result_t	include/range/v3/view/generate.hpp	/^        using result_t = invoke_result_t<G &>;$/;"	t	struct:ranges::generate_view	typeref:typename:invoke_result_t<G &>
result_t	include/range/v3/view/generate_n.hpp	/^        using result_t = invoke_result_t<G &>;$/;"	t	struct:ranges::generate_n_view	typeref:typename:invoke_result_t<G &>
result_type	include/range/v3/utility/random.hpp	/^                typedef IntRep result_type;$/;"	t	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:IntRep
resume	include/range/v3/experimental/utility/generator.hpp	/^            void resume()$/;"	f	struct:ranges::experimental::coroutine_owner	typeref:typename:void
resume	include/range/v3/experimental/utility/generator.hpp	/^        inline void resume(std::experimental::coroutine_handle<> coro)$/;"	f	namespace:ranges::detail	typeref:typename:void
return_t	include/concepts/concepts.hpp	/^    using return_t = meta::invoke<return_t_<EnableIf>, T>;$/;"	t	namespace:concepts	typeref:typename:meta::invoke<return_t_<EnableIf>,T>
return_t_	include/concepts/concepts.hpp	/^    struct return_t_$/;"	s	namespace:concepts
return_temporary_buffer	include/range/v3/utility/memory.hpp	/^        struct return_temporary_buffer$/;"	s	namespace:ranges::detail
return_void	include/range/v3/experimental/utility/generator.hpp	/^            void return_void() const noexcept$/;"	f	struct:ranges::detail::generator_promise	typeref:typename:void
reverse_copy_result	include/range/v3/algorithm/reverse_copy.hpp	/^    using reverse_copy_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
reverse_cursor	include/range/v3/iterator/reverse_iterator.hpp	/^            constexpr reverse_cursor(I it)$/;"	f	struct:ranges::detail::reverse_cursor
reverse_cursor	include/range/v3/iterator/reverse_iterator.hpp	/^        struct reverse_cursor$/;"	s	namespace:ranges::detail
reverse_fn	include/range/v3/action/reverse.hpp	/^        struct reverse_fn$/;"	s	namespace:ranges::actions
reverse_fn	include/range/v3/view/reverse.hpp	/^        struct reverse_fn$/;"	s	namespace:ranges::views
reverse_impl	include/range/v3/algorithm/reverse.hpp	/^        void reverse_impl(I first, I last, detail::bidirectional_iterator_tag_)$/;"	f	namespace:ranges::detail	typeref:typename:void
reverse_impl	include/range/v3/algorithm/reverse.hpp	/^        void reverse_impl(I first, I last, detail::random_access_iterator_tag_)$/;"	f	namespace:ranges::detail	typeref:typename:void
reverse_iterator	include/range/v3/view/span.hpp	/^        using reverse_iterator = ranges::reverse_iterator<iterator>;$/;"	t	struct:ranges::span	typeref:typename:ranges::reverse_iterator<iterator>
reverse_view	include/range/v3/view/reverse.hpp	/^            using reverse_view = ranges::reverse_view<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::reverse_view<Rng>
reverse_view	include/range/v3/view/reverse.hpp	/^        explicit constexpr reverse_view(Rng rng)$/;"	f	struct:ranges::reverse_view
reverse_view	include/range/v3/view/reverse.hpp	/^    struct RANGES_EMPTY_BASES reverse_view$/;"	s	namespace:ranges
rex_	include/range/v3/view/tokenize.hpp	/^        Regex rex_;$/;"	m	struct:ranges::tokenize_view	typeref:typename:Regex
rng1_	include/range/v3/view/set_algorithm.hpp	/^            Rng1 rng1_;$/;"	m	struct:ranges::detail::set_algorithm_view	typeref:typename:Rng1
rng1_	include/range/v3/view/transform.hpp	/^        Rng1 rng1_;$/;"	m	struct:ranges::iter_transform2_view	typeref:typename:Rng1
rng2_	include/range/v3/view/set_algorithm.hpp	/^            Rng2 rng2_;$/;"	m	struct:ranges::detail::set_algorithm_view	typeref:typename:Rng2
rng2_	include/range/v3/view/transform.hpp	/^        Rng2 rng2_;$/;"	m	struct:ranges::iter_transform2_view	typeref:typename:Rng2
rng_	include/range/v3/iterator_range.hpp	/^        iterator_range<I, S> rng_;$/;"	m	struct:ranges::sized_iterator_range	typeref:typename:iterator_range<I,S>
rng_	include/range/v3/view/adaptor.hpp	/^        base_range_t rng_;$/;"	m	struct:ranges::view_adaptor	typeref:typename:base_range_t
rng_	include/range/v3/view/adjacent_filter.hpp	/^            Parent * rng_;$/;"	m	struct:ranges::adjacent_filter_view::adaptor	typeref:typename:Parent *
rng_	include/range/v3/view/adjacent_remove_if.hpp	/^            adjacent_remove_if_view * rng_;$/;"	m	struct:ranges::adjacent_remove_if_view::adaptor	typeref:typename:adjacent_remove_if_view *
rng_	include/range/v3/view/any_view.hpp	/^            RANGES_NO_UNIQUE_ADDRESS Rng rng_;$/;"	m	struct:ranges::detail::any_input_view_impl	typeref:typename:RANGES_NO_UNIQUE_ADDRESS Rng
rng_	include/range/v3/view/cache1.hpp	/^        Rng rng_;$/;"	m	struct:ranges::cache1_view	typeref:typename:Rng
rng_	include/range/v3/view/chunk.hpp	/^                chunk_view_ * rng_ = nullptr;$/;"	m	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:chunk_view_ *
rng_	include/range/v3/view/chunk.hpp	/^            chunk_view_ * rng_ = nullptr;$/;"	m	struct:ranges::chunk_view_::outer_cursor	typeref:typename:chunk_view_ *
rng_	include/range/v3/view/common.hpp	/^        Rng rng_;$/;"	m	struct:ranges::common_view	typeref:typename:Rng
rng_	include/range/v3/view/concat.hpp	/^            concat_view_t * rng_;$/;"	m	struct:ranges::concat_view::cursor	typeref:typename:concat_view_t *
rng_	include/range/v3/view/cycle.hpp	/^            cycled_view_t * rng_{};$/;"	m	struct:ranges::cycled_view::cursor	typeref:typename:cycled_view_t *
rng_	include/range/v3/view/cycle.hpp	/^        Rng rng_;$/;"	m	struct:ranges::cycled_view	typeref:typename:Rng
rng_	include/range/v3/view/drop.hpp	/^        Rng rng_;$/;"	m	struct:ranges::drop_view	typeref:typename:Rng
rng_	include/range/v3/view/drop_exactly.hpp	/^        Rng rng_;$/;"	m	struct:ranges::drop_exactly_view	typeref:typename:Rng
rng_	include/range/v3/view/drop_last.hpp	/^        Rng rng_;$/;"	m	struct:ranges::drop_last_view	typeref:typename:Rng
rng_	include/range/v3/view/drop_while.hpp	/^        Rng rng_;$/;"	m	struct:ranges::drop_while_view	typeref:typename:Rng
rng_	include/range/v3/view/exclusive_scan.hpp	/^            exclusive_scan_view_t * rng_;$/;"	m	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:exclusive_scan_view_t *
rng_	include/range/v3/view/generate_n.hpp	/^            generate_n_view * rng_;$/;"	m	struct:ranges::generate_n_view::cursor	typeref:typename:generate_n_view *
rng_	include/range/v3/view/getlines.hpp	/^            getlines_view * rng_ = nullptr;$/;"	m	struct:ranges::getlines_view::cursor	typeref:typename:getlines_view *
rng_	include/range/v3/view/group_by.hpp	/^        Rng rng_;$/;"	m	struct:ranges::group_by_view	typeref:typename:Rng
rng_	include/range/v3/view/istream.hpp	/^            istream_view * rng_ = nullptr;$/;"	m	struct:ranges::istream_view::cursor	typeref:typename:istream_view *
rng_	include/range/v3/view/join.hpp	/^            Parent * rng_ = nullptr;$/;"	m	struct:ranges::join_view::cursor	typeref:typename:Parent *
rng_	include/range/v3/view/join.hpp	/^            join_with_view * rng_ = nullptr;$/;"	m	class:ranges::join_with_view::cursor	typeref:typename:join_with_view *
rng_	include/range/v3/view/ref.hpp	/^        Rng * rng_ = nullptr; \/\/ exposition only$/;"	m	struct:ranges::ref_view	typeref:typename:Rng *
rng_	include/range/v3/view/remove_if.hpp	/^            remove_if_view * rng_;$/;"	m	struct:ranges::remove_if_view::adaptor	typeref:typename:remove_if_view *
rng_	include/range/v3/view/reverse.hpp	/^        Rng rng_;$/;"	m	struct:ranges::reverse_view	typeref:typename:Rng
rng_	include/range/v3/view/sample.hpp	/^        Rng rng_;$/;"	m	class:ranges::sample_view	typeref:typename:Rng
rng_	include/range/v3/view/slice.hpp	/^            Rng rng_;$/;"	m	struct:ranges::detail::slice_view_	typeref:typename:Rng
rng_	include/range/v3/view/split_when.hpp	/^        Rng rng_;$/;"	m	struct:ranges::split_when_view	typeref:typename:Rng
rng_	include/range/v3/view/stride.hpp	/^            stride_view_t * rng_;$/;"	m	struct:ranges::stride_view::adaptor	typeref:typename:stride_view_t *
rng_	include/range/v3/view/tail.hpp	/^        Rng rng_;$/;"	m	struct:ranges::tail_view	typeref:typename:Rng
rng_	include/range/v3/view/take_exactly.hpp	/^            Rng rng_;$/;"	m	struct:ranges::detail::take_exactly_view_	typeref:typename:Rng
rng_	include/range/v3/view/tokenize.hpp	/^        Rng rng_;$/;"	m	struct:ranges::tokenize_view	typeref:typename:Rng
rng_	include/range/v3/view/trim.hpp	/^        Rng rng_;$/;"	m	struct:ranges::trim_view	typeref:typename:Rng
rng_ptr_	include/range/v3/experimental/view/shared.hpp	/^            std::shared_ptr<Rng> rng_ptr_;$/;"	m	struct:ranges::experimental::shared_view	typeref:typename:std::shared_ptr<Rng>
rngs_	example/calendar.cpp	/^    std::vector<range_value_t<Rngs>> *rngs_;$/;"	m	struct:interleave_view::cursor	typeref:typename:std::vector<range_value_t<Rngs>> *	file:
rngs_	example/calendar.cpp	/^    std::vector<range_value_t<Rngs>> rngs_;$/;"	m	class:interleave_view	typeref:typename:std::vector<range_value_t<Rngs>>	file:
rngs_	include/range/v3/view/concat.hpp	/^        std::tuple<Rngs...> rngs_;$/;"	m	struct:ranges::concat_view	typeref:typename:std::tuple<Rngs...>
rngs_	include/range/v3/view/zip_with.hpp	/^        std::tuple<Rngs...> rngs_;$/;"	m	struct:ranges::iter_zip_with_view	typeref:typename:std::tuple<Rngs...>
rotate_	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_(I first, I middle, I last, detail::forward_iterator_tag_)$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
rotate_	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_(I first, I middle, I last,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
rotate_	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_(I first, I middle, S last, detail::forward_iterator_tag_)$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
rotate_copy_result	include/range/v3/algorithm/rotate_copy.hpp	/^    using rotate_copy_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
rotate_forward	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_forward(I first, I middle, S last)$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
rotate_gcd	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_gcd(I first, I middle, I last)$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
rotate_left	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_left(I first, I last)$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
rotate_right	include/range/v3/algorithm/rotate.hpp	/^        subrange<I> rotate_right(I first, I last)$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
round_error	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t round_error() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
round_style	include/range/v3/iterator/diffmax_t.hpp	/^        numeric_limits<::ranges::detail::diffmax_t>::round_style;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:std::float_round_style
round_style	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr std::float_round_style round_style = std::round_toward_zero;$/;"	m	struct:std::numeric_limits	typeref:typename:std::float_round_style
rsi_	include/range/v3/utility/memory.hpp	/^        raw_storage_iterator<Val *, Val> rsi_;$/;"	m	struct:ranges::raw_buffer	typeref:typename:raw_storage_iterator<Val *,Val>
rtti_tag	include/range/v3/view/any_view.hpp	/^        struct rtti_tag$/;"	s	namespace:ranges::detail
run	test/oset.cpp	/^constexpr auto run(int (*c)(T *, Args...), Args &&... args) {$/;"	f	typeref:typename:auto
rvalue_reference	include/range/v3/view/join.hpp	/^            using rvalue_reference = common_reference_t<range_rvalue_reference_t<Inner>,$/;"	t	class:ranges::join_with_view::cursor	typeref:typename:common_reference_t<range_rvalue_reference_t<Inner>,range_rvalue_reference_t<ValRng>>
rvalue_reference_	include/range/v3/view/const.hpp	/^            using rvalue_reference_ =$/;"	t	struct:ranges::const_view::adaptor	typeref:typename:common_reference_t<value_ const &&,range_rvalue_reference_t<CRng>>
rvalue_reference_t	include/range/v3/iterator/traits.hpp	/^    using rvalue_reference_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:iter_rvalue_reference_t<I>
rvalue_reference_t_	include/range/v3/iterator/basic_iterator.hpp	/^            using rvalue_reference_t_ = cursor_rvalue_reference_t<Cur>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:cursor_rvalue_reference_t<Cur>
rvalue_reference_t_	include/range/v3/iterator/basic_iterator.hpp	/^            using rvalue_reference_t_ = private_;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:private_
rvalue_reference_type	include/range/v3/view/set_algorithm.hpp	/^            using rvalue_reference_type =$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:common_reference_t<range_rvalue_reference_t<R1>,range_rvalue_reference_t<R2>>
rvalue_reference_type	include/range/v3/view/set_algorithm.hpp	/^            using rvalue_reference_type =$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:common_reference_t<range_rvalue_reference_t<R1>,range_rvalue_reference_t<R2>>
safe_iterator_t	include/range/v3/range/dangling.hpp	/^    using safe_iterator_t = detail::maybe_dangling_<Rng, iterator_t<Rng>>;$/;"	t	namespace:ranges	typeref:typename:detail::maybe_dangling_<Rng,iterator_t<Rng>>
safe_subrange_t	include/range/v3/view/subrange.hpp	/^    using safe_subrange_t = detail::maybe_dangling_<R, subrange<iterator_t<R>>>;$/;"	t	namespace:ranges	typeref:typename:detail::maybe_dangling_<R,subrange<iterator_t<R>>>
same_as	include/meta/meta_fwd.hpp	/^    META_CONCEPT same_as =$/;"	v	namespace:meta	typeref:typename:META_CONCEPT
sample_base_fn	include/range/v3/view/sample.hpp	/^        struct sample_base_fn$/;"	s	namespace:ranges::views
sample_fn	include/range/v3/view/sample.hpp	/^        struct sample_fn : sample_base_fn$/;"	s	namespace:ranges::views
sample_result	include/range/v3/algorithm/sample.hpp	/^    using sample_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
sample_sized_impl	include/range/v3/algorithm/sample.hpp	/^        auto sample_sized_impl(I first, S last, iter_difference_t<I> pop_size, O out,$/;"	f	namespace:ranges::detail	typeref:typename:sample_result<I,O>
sample_view	include/range/v3/view/sample.hpp	/^        explicit sample_view(Rng rng, D sample_size, URNG & generator)$/;"	f	class:ranges::sample_view
sample_view	include/range/v3/view/sample.hpp	/^    class sample_view : public view_facade<sample_view<Rng, URNG>, finite>$/;"	c	namespace:ranges
sanitize_fn	include/range/v3/range/dangling.hpp	/^    using sanitize_fn RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:_sanitize_fn
satisfy	include/range/v3/view/concat.hpp	/^            void satisfy(meta::size_t<N>)$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:void
satisfy	include/range/v3/view/concat.hpp	/^            void satisfy(meta::size_t<cranges - 1>)$/;"	f	struct:ranges::concat_view::cursor	typeref:typename:void
satisfy	include/range/v3/view/join.hpp	/^            void satisfy()$/;"	f	class:ranges::join_with_view::cursor	typeref:typename:void
satisfy	include/range/v3/view/join.hpp	/^            void satisfy()$/;"	f	struct:ranges::join_view::cursor	typeref:typename:void
satisfy	include/range/v3/view/set_algorithm.hpp	/^            void satisfy()$/;"	f	struct:ranges::detail::set_difference_cursor	typeref:typename:void
satisfy	include/range/v3/view/set_algorithm.hpp	/^            void satisfy()$/;"	f	struct:ranges::detail::set_intersection_cursor	typeref:typename:void
satisfy	include/range/v3/view/set_algorithm.hpp	/^            void satisfy()$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:void
satisfy	include/range/v3/view/set_algorithm.hpp	/^            void satisfy()$/;"	f	struct:ranges::detail::set_union_cursor	typeref:typename:void
satisfy_forward	include/range/v3/view/adjacent_remove_if.hpp	/^        constexpr void satisfy_forward(iterator_t<Rng> & it)$/;"	f	struct:ranges::adjacent_remove_if_view	typeref:typename:void
satisfy_forward	include/range/v3/view/remove_if.hpp	/^        constexpr void satisfy_forward(iterator_t<Rng> & it)$/;"	f	struct:ranges::remove_if_view	typeref:typename:void
satisfy_reverse	include/range/v3/view/adjacent_remove_if.hpp	/^        constexpr void satisfy_reverse(iterator_t<Rng> & it)$/;"	f	struct:ranges::adjacent_remove_if_view	typeref:typename:void
satisfy_reverse	include/range/v3/view/remove_if.hpp	/^        constexpr void satisfy_reverse(iterator_t<Rng> & it)$/;"	f	struct:ranges::remove_if_view	typeref:typename:void
sbuf_	include/range/v3/iterator/stream_iterators.hpp	/^        streambuf_type * sbuf_ = nullptr;$/;"	m	struct:ranges::ostreambuf_iterator	typeref:typename:streambuf_type *
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        explicit scope_exit(Fun && fun) noexcept(noexcept(scope_exit(std::move(fun),$/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        explicit scope_exit(Fun const & fun) noexcept($/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        scope_exit(Fun && fun, std::true_type) noexcept$/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        scope_exit(Fun const & fun, guard && g)$/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        scope_exit(Fun const & fun, std::false_type)$/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        scope_exit(Fun const & fun, std::true_type) noexcept$/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^        scope_exit(scope_exit && that) noexcept($/;"	f	struct:ranges::scope_exit
scope_exit	include/range/v3/utility/scope_exit.hpp	/^    struct scope_exit$/;"	s	namespace:ranges
search_impl	include/range/v3/algorithm/search.hpp	/^        subrange<I1> search_impl(I1 begin1, S1 end1, I2 begin2, S2 end2, C & pred,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I1>
search_n_impl	include/range/v3/algorithm/search_n.hpp	/^        subrange<I> search_n_impl(I first, S last, D cnt, V const & val, C & pred,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
search_n_sized_impl	include/range/v3/algorithm/search_n.hpp	/^        subrange<I> search_n_sized_impl(I const begin_, S last, D const d_, D cnt,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I>
search_pred	include/range/v3/view/split_when.hpp	/^            struct search_pred$/;"	s	struct:ranges::split_when_view::cursor
search_sized_impl	include/range/v3/algorithm/search.hpp	/^        subrange<I1> search_sized_impl(I1 const begin1_, S1 end1, D1 const d1_, I2 begin2,$/;"	f	namespace:ranges::detail	typeref:typename:subrange<I1>
second	include/range/v3/utility/compressed_pair.hpp	/^        constexpr Second & second() &$/;"	f	struct:ranges::compressed_pair	typeref:typename:Second &
second	include/range/v3/utility/compressed_pair.hpp	/^        constexpr Second && second() &&$/;"	f	struct:ranges::compressed_pair	typeref:typename:Second &&
second	include/range/v3/utility/compressed_pair.hpp	/^        constexpr Second const & second() const &$/;"	f	struct:ranges::compressed_pair	typeref:typename:Second const &
second_	include/range/v3/functional/compose.hpp	/^        Second second_;$/;"	m	struct:ranges::composed	typeref:typename:RANGES_NO_UNIQUE_ADDRESS Second
second_	include/range/v3/functional/on.hpp	/^        Fn2 second_;$/;"	m	struct:ranges::transformed	typeref:typename:RANGES_NO_UNIQUE_ADDRESS Fn2
second_	include/range/v3/functional/overload.hpp	/^        overloaded<Rest...> second_;$/;"	m	struct:ranges::overloaded	typeref:typename:RANGES_NO_UNIQUE_ADDRESS overloaded<Rest...>
second_type	include/range/v3/utility/compressed_pair.hpp	/^        using second_type = Second;$/;"	t	struct:ranges::compressed_pair	typeref:typename:Second
seed	include/range/v3/utility/random.hpp	/^                auto seed(I first, S last) -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:CPP_ret (void)(requires input_iterator<I> && sentinel_for<S,I> && convertible_to<iter_reference_t<I>,IntRep>)
seed_seq_fe	include/range/v3/utility/random.hpp	/^            struct seed_seq_fe$/;"	s	namespace:ranges::detail::randutils
seed_seq_fe128	include/range/v3/utility/random.hpp	/^            using seed_seq_fe128 = seed_seq_fe<4, std::uint32_t>;$/;"	t	namespace:ranges::detail::randutils	typeref:typename:seed_seq_fe<4,std::uint32_t>
seed_seq_fe256	include/range/v3/utility/random.hpp	/^            using seed_seq_fe256 = seed_seq_fe<8, std::uint32_t>;$/;"	t	namespace:ranges::detail::randutils	typeref:typename:seed_seq_fe<8,std::uint32_t>
select_projected_	include/range/v3/iterator/concepts.hpp	/^        struct select_projected_$/;"	s	namespace:ranges::detail
select_projected_	include/range/v3/iterator/concepts.hpp	/^        struct select_projected_<identity>$/;"	s	namespace:ranges::detail
selection_sort	include/range/v3/algorithm/nth_element.hpp	/^        auto selection_sort(I first, I last, C & pred, P & proj) -> CPP_ret(void)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (void)(requires bidirectional_iterator<I> && indirect_relation<C,projected<I,P>>)
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^        constexpr semiregular_box() noexcept($/;"	f	struct:ranges::semiregular_box
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^        constexpr semiregular_box(tag, std::false_type) noexcept$/;"	f	struct:ranges::semiregular_box
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^        constexpr semiregular_box(tag, std::true_type) noexcept($/;"	f	struct:ranges::semiregular_box
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^        semiregular_box(semiregular_box && that) noexcept($/;"	f	struct:ranges::semiregular_box
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^        semiregular_box(semiregular_box const & that) noexcept($/;"	f	struct:ranges::semiregular_box
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^    struct semiregular_box : private detail::semiregular_get$/;"	s	namespace:ranges
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^    struct semiregular_box<T &&>$/;"	s	namespace:ranges
semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^    struct semiregular_box<T &>$/;"	s	namespace:ranges
semiregular_box_ref_or_val_t	include/range/v3/utility/semiregular_box.hpp	/^    using semiregular_box_ref_or_val_t = meta::if_c<$/;"	t	namespace:ranges
semiregular_box_t	include/range/v3/utility/semiregular_box.hpp	/^    using semiregular_box_t = meta::if_c<(bool)semiregular<T>, T, semiregular_box<T>>;$/;"	t	namespace:ranges
semiregular_get	include/range/v3/utility/semiregular_box.hpp	/^        struct semiregular_get$/;"	s	namespace:ranges::detail
semiregular_ref_or_val_t	include/range/v3/utility/semiregular_box.hpp	/^    using semiregular_ref_or_val_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:semiregular_box_ref_or_val_t<T,IsConst>
semiregular_t	include/range/v3/utility/semiregular_box.hpp	/^    using semiregular_t RANGES_DEPRECATED("Please use semiregular_box_t instead.") =$/;"	t	namespace:ranges	typeref:typename:semiregular_box_t<T>
sent_	include/range/v3/iterator/move_iterators.hpp	/^        S sent_;$/;"	m	struct:ranges::move_sentinel	typeref:typename:S
sentinel	include/range/v3/iterator_range.hpp	/^        using sentinel = S;$/;"	t	struct:ranges::iterator_range	typeref:typename:S
sentinel	include/range/v3/iterator_range.hpp	/^        using sentinel = S;$/;"	t	struct:ranges::sized_iterator_range	typeref:typename:S
sentinel	include/range/v3/view/cache1.hpp	/^            constexpr explicit sentinel(sentinel_t<Rng> last)$/;"	f	struct:ranges::cache1_view::sentinel
sentinel	include/range/v3/view/cache1.hpp	/^        struct sentinel$/;"	s	struct:ranges::cache1_view
sentinel	include/range/v3/view/concat.hpp	/^            sentinel(concat_view_t * rng, end_tag)$/;"	f	struct:ranges::concat_view::sentinel
sentinel	include/range/v3/view/concat.hpp	/^        struct sentinel$/;"	s	struct:ranges::concat_view
sentinel	include/range/v3/view/iota.hpp	/^            constexpr explicit sentinel(To to)$/;"	f	struct:ranges::iota_view::sentinel
sentinel	include/range/v3/view/iota.hpp	/^        struct sentinel$/;"	s	struct:ranges::iota_view
sentinel	include/range/v3/view/subrange.hpp	/^        using sentinel = S;$/;"	t	struct:ranges::subrange	typeref:typename:S
sentinel	include/range/v3/view/take.hpp	/^            constexpr explicit sentinel(sentinel_t<Base> last)$/;"	f	struct:ranges::take_view::sentinel
sentinel	include/range/v3/view/take.hpp	/^        struct sentinel$/;"	s	struct:ranges::take_view
sentinel	include/range/v3/view/transform.hpp	/^            sentinel(meta::const_if_c<Const, iter_transform2_view> * parent,$/;"	f	struct:ranges::iter_transform2_view::sentinel
sentinel	include/range/v3/view/transform.hpp	/^        struct sentinel$/;"	s	struct:ranges::iter_transform2_view
sentinel	include/range/v3/view/zip_with.hpp	/^            sentinel(detail::ignore_t,$/;"	f	struct:ranges::iter_zip_with_view::sentinel
sentinel	include/range/v3/view/zip_with.hpp	/^        struct sentinel$/;"	s	struct:ranges::iter_zip_with_view
sentinel_adaptor	include/range/v3/view/delimit.hpp	/^            sentinel_adaptor(Val value)$/;"	f	struct:ranges::delimit_view::sentinel_adaptor
sentinel_adaptor	include/range/v3/view/delimit.hpp	/^        struct sentinel_adaptor : adaptor_base$/;"	s	struct:ranges::delimit_view
sentinel_adaptor	include/range/v3/view/drop_last.hpp	/^        struct sentinel_adaptor : adaptor_base$/;"	s	struct:ranges::drop_last_view
sentinel_adaptor	include/range/v3/view/intersperse.hpp	/^        struct sentinel_adaptor : adaptor_base$/;"	s	struct:ranges::intersperse_view
sentinel_adaptor	include/range/v3/view/take_while.hpp	/^            sentinel_adaptor(semiregular_box_ref_or_val_t<Pred, IsConst> pred)$/;"	f	struct:ranges::iter_take_while_view::sentinel_adaptor
sentinel_adaptor	include/range/v3/view/take_while.hpp	/^        struct sentinel_adaptor : adaptor_base$/;"	s	struct:ranges::iter_take_while_view
sentinel_box_t	include/range/v3/view/any_view.hpp	/^            using sentinel_box_t = any_view_sentinel_impl<Rng>;$/;"	t	struct:ranges::detail::any_input_view_impl	typeref:typename:any_view_sentinel_impl<Rng>
sentinel_t	include/range/v3/range/access.hpp	/^    using sentinel_t = decltype(end(std::declval<Rng &>()));$/;"	t	namespace:ranges
sentinel_tag	include/range/v3/iterator/concepts.hpp	/^    using sentinel_tag = concepts::tag<sentinel_for_concept>;$/;"	t	namespace:ranges	typeref:typename:concepts::tag<sentinel_for_concept>
sentinel_tag_of	include/range/v3/iterator/concepts.hpp	/^    using sentinel_tag_of =$/;"	t	namespace:ranges	typeref:typename:concepts::tag_of<meta::list<sized_sentinel_for_concept,sentinel_for_concept>,S,I>
set_algorithm_view	include/range/v3/view/set_algorithm.hpp	/^            set_algorithm_view(Rng1 rng1, Rng2 rng2, C pred, P1 proj1, P2 proj2)$/;"	f	struct:ranges::detail::set_algorithm_view
set_algorithm_view	include/range/v3/view/set_algorithm.hpp	/^        struct set_algorithm_view$/;"	s	namespace:ranges::detail
set_difference_base_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_difference_base_fn$/;"	s	namespace:ranges::views
set_difference_cardinality	include/range/v3/view/set_algorithm.hpp	/^        constexpr cardinality set_difference_cardinality(cardinality c1, cardinality c2)$/;"	f	namespace:ranges::detail	typeref:typename:cardinality
set_difference_cursor	include/range/v3/view/set_algorithm.hpp	/^            set_difference_cursor(pred_ref_ pred, proj1_ref_ proj1, proj2_ref_ proj2,$/;"	f	struct:ranges::detail::set_difference_cursor
set_difference_cursor	include/range/v3/view/set_algorithm.hpp	/^        struct set_difference_cursor$/;"	s	namespace:ranges::detail
set_difference_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_difference_fn : set_difference_base_fn$/;"	s	namespace:ranges::views
set_difference_result	include/range/v3/algorithm/set_algorithm.hpp	/^    using set_difference_result = detail::in1_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_out_result<I,O>
set_difference_view	include/range/v3/view/set_algorithm.hpp	/^    using set_difference_view =$/;"	t	namespace:ranges
set_end_	include/range/v3/view/cycle.hpp	/^            void set_end_(std::false_type) const$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:void
set_end_	include/range/v3/view/cycle.hpp	/^            void set_end_(std::true_type) const$/;"	f	struct:ranges::cycled_view::cursor	typeref:typename:void
set_intersection_base_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_intersection_base_fn$/;"	s	namespace:ranges::views
set_intersection_cardinality	include/range/v3/view/set_algorithm.hpp	/^        constexpr cardinality set_intersection_cardinality(cardinality c1, cardinality c2)$/;"	f	namespace:ranges::detail	typeref:typename:cardinality
set_intersection_cursor	include/range/v3/view/set_algorithm.hpp	/^            set_intersection_cursor(pred_ref_ pred, proj1_ref_ proj1, proj2_ref_ proj2,$/;"	f	struct:ranges::detail::set_intersection_cursor
set_intersection_cursor	include/range/v3/view/set_algorithm.hpp	/^        struct set_intersection_cursor$/;"	s	namespace:ranges::detail
set_intersection_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_intersection_fn : set_intersection_base_fn$/;"	s	namespace:ranges::views
set_intersection_view	include/range/v3/view/set_algorithm.hpp	/^    using set_intersection_view =$/;"	t	namespace:ranges
set_offset	include/range/v3/view/stride.hpp	/^            constexpr void set_offset(range_difference_t<Rng> const delta) noexcept$/;"	f	struct:ranges::detail::stride_view_base_	typeref:typename:void
set_offset	include/range/v3/view/stride.hpp	/^            constexpr void set_offset(range_difference_t<Rng> const) const noexcept$/;"	f	struct:ranges::detail::stride_view_base_	typeref:typename:void
set_size_	include/range/v3/view/subrange.hpp	/^        constexpr auto set_size_(size_type n) noexcept -> CPP_ret(void)( \/\/$/;"	f	struct:ranges::subrange	typeref:typename:CPP_member auto
set_size_	include/range/v3/view/subrange.hpp	/^        static constexpr void set_size_(...) noexcept$/;"	f	struct:ranges::subrange	typeref:typename:void
set_symmetric_difference_base_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_symmetric_difference_base_fn$/;"	s	namespace:ranges::views
set_symmetric_difference_cardinality	include/range/v3/view/set_algorithm.hpp	/^        constexpr cardinality set_symmetric_difference_cardinality(cardinality c1,$/;"	f	namespace:ranges::detail	typeref:typename:cardinality
set_symmetric_difference_cursor	include/range/v3/view/set_algorithm.hpp	/^            set_symmetric_difference_cursor(pred_ref_ pred, proj1_ref_ proj1,$/;"	f	struct:ranges::detail::set_symmetric_difference_cursor
set_symmetric_difference_cursor	include/range/v3/view/set_algorithm.hpp	/^        struct set_symmetric_difference_cursor$/;"	s	namespace:ranges::detail
set_symmetric_difference_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_symmetric_difference_fn : set_symmetric_difference_base_fn$/;"	s	namespace:ranges::views
set_symmetric_difference_result	include/range/v3/algorithm/set_algorithm.hpp	/^    using set_symmetric_difference_result = detail::in1_in2_out_result<I1, I2, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_in2_out_result<I1,I2,O>
set_symmetric_difference_view	include/range/v3/view/set_algorithm.hpp	/^    using set_symmetric_difference_view = detail::set_algorithm_view<$/;"	t	namespace:ranges
set_union_base_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_union_base_fn$/;"	s	namespace:ranges::views
set_union_cardinality	include/range/v3/view/set_algorithm.hpp	/^        constexpr cardinality set_union_cardinality(cardinality c1, cardinality c2)$/;"	f	namespace:ranges::detail	typeref:typename:cardinality
set_union_cursor	include/range/v3/view/set_algorithm.hpp	/^            set_union_cursor(pred_ref_ pred, proj1_ref_ proj1, proj2_ref_ proj2,$/;"	f	struct:ranges::detail::set_union_cursor
set_union_cursor	include/range/v3/view/set_algorithm.hpp	/^        struct set_union_cursor$/;"	s	namespace:ranges::detail
set_union_fn	include/range/v3/view/set_algorithm.hpp	/^        struct set_union_fn : set_union_base_fn$/;"	s	namespace:ranges::views
set_union_result	include/range/v3/algorithm/set_algorithm.hpp	/^    using set_union_result = detail::in1_in2_out_result<I1, I2, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_in2_out_result<I1,I2,O>
set_union_view	include/range/v3/view/set_algorithm.hpp	/^    using set_union_view =$/;"	t	namespace:ranges
shared_fn	include/range/v3/experimental/view/shared.hpp	/^            struct shared_fn : pipeable_base$/;"	s	namespace:ranges::experimental::views
shared_view	include/range/v3/experimental/view/shared.hpp	/^            explicit shared_view(Rng rng)$/;"	f	struct:ranges::experimental::shared_view
shared_view	include/range/v3/experimental/view/shared.hpp	/^        struct shared_view$/;"	s	namespace:ranges::experimental
shuffle_fn	include/range/v3/action/shuffle.hpp	/^        struct shuffle_fn$/;"	s	namespace:ranges::actions
sift_down_n_fn	include/range/v3/algorithm/heap_algorithm.hpp	/^        struct sift_down_n_fn$/;"	s	namespace:ranges::detail
sift_up_n_fn	include/range/v3/algorithm/heap_algorithm.hpp	/^        struct sift_up_n_fn$/;"	s	namespace:ranges::detail
signaling_NaN	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr ::ranges::detail::diffmax_t signaling_NaN() noexcept$/;"	f	struct:std::numeric_limits	typeref:typename:::ranges::detail::diffmax_t
simple_view	include/range/v3/view/view.hpp	/^    constexpr bool simple_view() noexcept$/;"	f	namespace:ranges	typeref:typename:bool
sin_	include/range/v3/view/getlines.hpp	/^        std::istream * sin_;$/;"	m	struct:ranges::getlines_view	typeref:typename:std::istream *
sin_	include/range/v3/view/istream.hpp	/^        std::istream * sin_;$/;"	m	struct:ranges::istream_view	typeref:typename:std::istream *
single_fn	include/range/v3/view/single.hpp	/^        struct single_fn$/;"	s	namespace:ranges::views
single_pass	include/range/v3/iterator/common_iterator.hpp	/^            using single_pass = meta::bool_<!forward_iterator<I>>;$/;"	t	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:meta::bool_<!forward_iterator<I>>
single_pass	include/range/v3/iterator/move_iterators.hpp	/^            using single_pass = meta::bool_<(bool)single_pass_iterator_<I>>;$/;"	t	struct:ranges::detail::move_into_cursor_types_
single_pass	include/range/v3/view/adaptor.hpp	/^        using single_pass = meta::bool_<(bool)range_access::single_pass_t<Adapt>() ||$/;"	t	struct:ranges::adaptor_cursor
single_pass	include/range/v3/view/any_view.hpp	/^            using single_pass = std::true_type;$/;"	t	struct:ranges::detail::any_input_cursor	typeref:typename:std::true_type
single_pass	include/range/v3/view/cache1.hpp	/^            using single_pass = std::true_type;$/;"	t	struct:ranges::cache1_view::cursor	typeref:typename:std::true_type
single_pass	include/range/v3/view/concat.hpp	/^            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<Rngs>>...>;$/;"	t	struct:ranges::concat_view::cursor	typeref:typename:meta::or_c<single_pass_iterator_<iterator_t<Rngs>>...>
single_pass	include/range/v3/view/exclusive_scan.hpp	/^                public : using single_pass = exclusive_scan_view::single_pass;$/;"	t	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:exclusive_scan_view::single_pass
single_pass	include/range/v3/view/exclusive_scan.hpp	/^        using single_pass = meta::bool_<single_pass_iterator_<iterator_t<Rng>>>;$/;"	t	struct:ranges::exclusive_scan_view	typeref:typename:meta::bool_<single_pass_iterator_<iterator_t<Rng>>>
single_pass	include/range/v3/view/getlines.hpp	/^            using single_pass = std::true_type;$/;"	t	struct:ranges::getlines_view::cursor	typeref:typename:std::true_type
single_pass	include/range/v3/view/istream.hpp	/^            using single_pass = std::true_type;$/;"	t	struct:ranges::istream_view::cursor	typeref:typename:std::true_type
single_pass	include/range/v3/view/join.hpp	/^            using single_pass = meta::bool_<single_pass_iterator_<iterator_t<COuter>> ||$/;"	t	struct:ranges::join_view::cursor	typeref:typename:meta::bool_<single_pass_iterator_<iterator_t<COuter>>||single_pass_iterator_<iterator_t<CInner>>||!ref_is_glvalue::value>
single_pass	include/range/v3/view/join.hpp	/^            using single_pass = std::true_type;$/;"	t	class:ranges::join_with_view::cursor	typeref:typename:std::true_type
single_pass	include/range/v3/view/partial_sum.hpp	/^            using single_pass = meta::bool_<single_pass_iterator_<iterator_t<Base>>>;$/;"	t	struct:ranges::partial_sum_view::cursor	typeref:typename:meta::bool_<single_pass_iterator_<iterator_t<Base>>>
single_pass	include/range/v3/view/set_algorithm.hpp	/^            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:meta::or_c<single_pass_iterator_<iterator_t<R1>>,single_pass_iterator_<iterator_t<R2>>>
single_pass	include/range/v3/view/set_algorithm.hpp	/^            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:meta::or_c<single_pass_iterator_<iterator_t<R1>>,single_pass_iterator_<iterator_t<R2>>>
single_pass	include/range/v3/view/set_algorithm.hpp	/^            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:meta::or_c<single_pass_iterator_<iterator_t<R1>>,single_pass_iterator_<iterator_t<R2>>>
single_pass	include/range/v3/view/set_algorithm.hpp	/^            using single_pass = meta::or_c<single_pass_iterator_<iterator_t<R1>>,$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:meta::or_c<single_pass_iterator_<iterator_t<R1>>,single_pass_iterator_<iterator_t<R2>>>
single_pass	include/range/v3/view/transform.hpp	/^            using single_pass = meta::or_c<(bool)single_pass_iterator_<iterator_t<R1>>,$/;"	t	struct:ranges::iter_transform2_view::cursor
single_pass	include/range/v3/view/zip_with.hpp	/^            using single_pass = meta::or_c<($/;"	t	struct:ranges::iter_zip_with_view::cursor
single_pass_	include/range/v3/detail/range_access.hpp	/^        struct single_pass_$/;"	s	struct:ranges::range_access
single_pass_t	include/range/v3/detail/range_access.hpp	/^        using single_pass_t = meta::_t<single_pass_<Cur>>;$/;"	t	struct:ranges::range_access	typeref:typename:meta::_t<single_pass_<Cur>>
single_view	include/range/v3/view/single.hpp	/^            using single_view = ranges::single_view<T>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::single_view<T>
single_view	include/range/v3/view/single.hpp	/^        constexpr explicit single_view(T && t)$/;"	f	struct:ranges::single_view
single_view	include/range/v3/view/single.hpp	/^        constexpr explicit single_view(T const & t)$/;"	f	struct:ranges::single_view
single_view	include/range/v3/view/single.hpp	/^        constexpr single_view(in_place_t, std::false_type, Args &&... args)$/;"	f	struct:ranges::single_view
single_view	include/range/v3/view/single.hpp	/^        constexpr single_view(in_place_t, std::true_type, Args &&... args)$/;"	f	struct:ranges::single_view
single_view	include/range/v3/view/single.hpp	/^    struct single_view : view_interface<single_view<T>, (cardinality)1>$/;"	s	namespace:ranges
size	include/meta/meta.hpp	/^        static constexpr std::size_t size() noexcept { return sizeof...(Is); }$/;"	f	struct:meta::integer_sequence	typeref:typename:std::size_t
size	include/range/v3/detail/variant.hpp	/^        static constexpr std::size_t size() noexcept$/;"	f	struct:ranges::variant	typeref:typename:std::size_t
size	include/range/v3/experimental/utility/generator.hpp	/^            experimental::generator_size_t size() const noexcept$/;"	f	struct:ranges::detail::sized_generator_promise	typeref:typename:experimental::generator_size_t
size	include/range/v3/experimental/utility/generator.hpp	/^            generator_size_t size() const noexcept$/;"	f	struct:ranges::experimental::sized_generator	typeref:typename:generator_size_t
size	include/range/v3/iterator_range.hpp	/^        size_type size() const noexcept$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:size_type
size	include/range/v3/utility/random.hpp	/^                constexpr std::size_t size() const$/;"	f	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:std::size_t
size	include/range/v3/view/any_view.hpp	/^            std::size_t size() \/\/ override-ish$/;"	f	struct:ranges::detail::any_input_view_impl	typeref:typename:std::size_t
size	include/range/v3/view/concat.hpp	/^        constexpr auto size() const -> CPP_ret(std::size_t)( \/\/$/;"	f	struct:ranges::concat_view	typeref:typename:CPP_ret (std::size_t)(requires (detail::concat_cardinality<Rngs...>::value>=0))
size	include/range/v3/view/counted.hpp	/^        auto size() const$/;"	f	struct:ranges::counted_view	typeref:typename:auto
size	include/range/v3/view/drop_last.hpp	/^        range_size_t<Rng> size()$/;"	f	struct:ranges::drop_last_view	typeref:typename:range_size_t<Rng>
size	include/range/v3/view/empty.hpp	/^        static constexpr std::size_t size() noexcept$/;"	f	struct:ranges::empty_view	typeref:typename:std::size_t
size	include/range/v3/view/generate_n.hpp	/^        std::size_t size() const$/;"	f	struct:ranges::generate_n_view	typeref:typename:std::size_t
size	include/range/v3/view/interface.hpp	/^        constexpr auto size() -> CPP_ret(detail::iter_size_t<iterator_t<D<True>>>)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (detail::iter_size_t<iterator_t<D<True>>>)(requires True && (Cardinality<0)&& sized_sentinel_for<sentinel_t<D<True>>,iterator_t<D<True>>> && forward_range<D<True>>)
size	include/range/v3/view/interface.hpp	/^        constexpr auto size() const                               \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:CPP_ret (detail::iter_size_t<iterator_t<D<True>>>)(requires True && (Cardinality<0)&& sized_sentinel_for<sentinel_t<D<True> const>,iterator_t<D<True> const>> && forward_range<D<True> const>)
size	include/range/v3/view/interface.hpp	/^        static constexpr auto size() noexcept -> CPP_ret(std::size_t)( \/\/$/;"	f	struct:ranges::view_interface	typeref:typename:auto
size	include/range/v3/view/join.hpp	/^        static constexpr auto size() -> CPP_ret(std::size_t)( \/\/$/;"	f	struct:ranges::join_view	typeref:typename:CPP_ret (std::size_t)(requires (detail::join_cardinality<Rng> ()>=0))
size	include/range/v3/view/join.hpp	/^        static constexpr auto size() -> CPP_ret(std::size_t)( \/\/$/;"	f	struct:ranges::join_with_view	typeref:typename:CPP_ret (std::size_t)(requires (detail::join_cardinality<Rng,ValRng> ()>=0))
size	include/range/v3/view/linear_distribute.hpp	/^            constexpr std::size_t size() const noexcept$/;"	f	struct:ranges::views::linear_distribute_view	typeref:typename:std::size_t
size	include/range/v3/view/repeat_n.hpp	/^        constexpr std::size_t size() const$/;"	f	struct:ranges::repeat_n_view	typeref:typename:std::size_t
size	include/range/v3/view/single.hpp	/^        static constexpr std::size_t size() noexcept$/;"	f	struct:ranges::single_view	typeref:typename:std::size_t
size	include/range/v3/view/slice.hpp	/^            auto size() const$/;"	f	struct:ranges::detail::slice_view_	typeref:typename:auto
size	include/range/v3/view/span.hpp	/^            constexpr span_index_t size() const noexcept$/;"	f	struct:ranges::detail::span_extent	typeref:typename:span_index_t
size	include/range/v3/view/subrange.hpp	/^        constexpr auto size() const -> CPP_ret(size_type)( \/\/$/;"	f	struct:ranges::subrange	typeref:typename:CPP_ret (size_type)(requires (K==subrange_kind::sized))
size	include/range/v3/view/take_exactly.hpp	/^            auto size() const$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:auto
size	include/range/v3/view/take_exactly.hpp	/^            detail::iter_size_t<iterator_t<Rng>> size() const$/;"	f	struct:ranges::detail::take_exactly_view_	typeref:typename:detail::iter_size_t<iterator_t<Rng>>
size	include/range/v3/view/transform.hpp	/^        static constexpr auto size() -> CPP_ret(std::size_t)( \/\/$/;"	f	struct:ranges::iter_transform2_view	typeref:typename:CPP_ret (std::size_t)(requires (my_cardinality>=0))
size_	include/range/v3/experimental/utility/generator.hpp	/^            experimental::generator_size size_ = experimental::generator_size::invalid;$/;"	m	struct:ranges::detail::sized_generator_promise	typeref:typename:experimental::generator_size
size_	include/range/v3/iterator_range.hpp	/^        size_type size_;$/;"	m	struct:ranges::sized_iterator_range	typeref:typename:size_type
size_	include/range/v3/view/chunk.hpp	/^        constexpr Size size_(Size base_size) const$/;"	f	struct:ranges::chunk_view_	typeref:typename:Size
size_	include/range/v3/view/sample.hpp	/^            RANGES_NO_UNIQUE_ADDRESS detail::size_tracker<Base> size_;$/;"	m	class:ranges::sample_view::cursor	typeref:typename:RANGES_NO_UNIQUE_ADDRESS detail::size_tracker<Base>
size_	include/range/v3/view/sample.hpp	/^        mutable range_difference_t<Rng> size_;$/;"	m	class:ranges::sample_view	typeref:typename:range_difference_t<Rng>
size_	include/range/v3/view/span.hpp	/^            span_index_t size_ = 0;$/;"	m	struct:ranges::detail::span_extent	typeref:typename:span_index_t
size_	include/range/v3/view/transform.hpp	/^        static constexpr auto size_(Self & self)$/;"	f	struct:ranges::iter_transform2_view	typeref:typename:auto
size_bytes	include/range/v3/view/span.hpp	/^        constexpr index_type size_bytes() const noexcept$/;"	f	struct:ranges::span	typeref:typename:index_type
size_t	include/meta/meta.hpp	/^    using size_t = std::integral_constant<std::size_t, N>;$/;"	t	namespace:meta	typeref:typename:std::integral_constant<std::size_t,N>
size_tracker	include/range/v3/view/sample.hpp	/^            size_tracker(Rng &)$/;"	f	class:ranges::detail::size_tracker
size_tracker	include/range/v3/view/sample.hpp	/^        class size_tracker<Rng, true>$/;"	c	namespace:ranges::detail
size_type	include/range/v3/iterator/operations.hpp	/^            using size_type = meta::_t<std::make_unsigned<iter_difference_t<I>>>;$/;"	t	function:ranges::iter_size_fn::operator ()	typeref:typename:meta::_t<std::make_unsigned<iter_difference_t<I>>>
size_type	include/range/v3/iterator/traits.hpp	/^        "size_type.") size_type : detail::size_type_<T>$/;"	s	namespace:ranges
size_type	include/range/v3/iterator_range.hpp	/^        using size_type = detail::iter_size_t<I>;$/;"	t	struct:ranges::sized_iterator_range	typeref:typename:detail::iter_size_t<I>
size_type	include/range/v3/range/conversion.hpp	/^                using size_type = decltype(c.max_size());$/;"	t	function:ranges::detail::to_container::fn::impl
size_type	include/range/v3/range/primitives.hpp	/^                using size_type = detail::iter_size_t<_begin_::_t<R>>;$/;"	t	function:ranges::_size_::fn::impl_	typeref:typename:detail::iter_size_t<_begin_::_t<R>>
size_type	include/range/v3/view/chunk.hpp	/^                    using size_type = detail::iter_size_t<iterator_t<Rng>>;$/;"	t	function:ranges::chunk_view_::outer_cursor::inner_view::CPP_fun	typeref:typename:detail::iter_size_t<iterator_t<Rng>>
size_type	include/range/v3/view/concat.hpp	/^            using size_type = common_type_t<range_size_t<Rngs const>...>;$/;"	t	function:ranges::concat_view::CPP_fun	typeref:typename:common_type_t<range_size_t<Rngs const>...>
size_type	include/range/v3/view/concat.hpp	/^            using size_type = common_type_t<range_size_t<Rngs>...>;$/;"	t	function:ranges::concat_view::CPP_fun	typeref:typename:common_type_t<range_size_t<Rngs>...>
size_type	include/range/v3/view/interface.hpp	/^            using size_type = detail::iter_size_t<iterator_t<D<True>>>;$/;"	t	function:ranges::view_interface::size	typeref:typename:detail::iter_size_t<iterator_t<D<True>>>
size_type	include/range/v3/view/interface.hpp	/^            using size_type = range_size_t<Derived const>;$/;"	t	function:ranges::view_interface::at	typeref:typename:range_size_t<Derived const>
size_type	include/range/v3/view/interface.hpp	/^            using size_type = range_size_t<Derived>;$/;"	t	function:ranges::view_interface::at	typeref:typename:range_size_t<Derived>
size_type	include/range/v3/view/stride.hpp	/^            using size_type = range_size_t<Rng const>;$/;"	t	function:ranges::stride_view::CPP_fun	typeref:typename:range_size_t<Rng const>
size_type	include/range/v3/view/stride.hpp	/^            using size_type = range_size_t<Rng>;$/;"	t	function:ranges::stride_view::CPP_fun	typeref:typename:range_size_t<Rng>
size_type	include/range/v3/view/subrange.hpp	/^        using size_type = detail::iter_size_t<I>;$/;"	t	struct:ranges::subrange	typeref:typename:detail::iter_size_t<I>
size_type	include/range/v3/view/tail.hpp	/^            using size_type = range_size_t<Rng>;$/;"	t	function:ranges::tail_view::CPP_fun	typeref:typename:range_size_t<Rng>
size_type	include/range/v3/view/transform.hpp	/^            using size_type = common_type_t<range_size_t<Rng1>, range_size_t<Rng2>>;$/;"	t	function:ranges::iter_transform2_view::size_	typeref:typename:common_type_t<range_size_t<Rng1>,range_size_t<Rng2>>
size_type	include/range/v3/view/zip_with.hpp	/^            using size_type = common_type_t<range_size_t<Rngs const>...>;$/;"	t	function:ranges::iter_zip_with_view::CPP_fun	typeref:typename:common_type_t<range_size_t<Rngs const>...>
size_type_	include/range/v3/iterator/traits.hpp	/^        struct size_type_ : meta::defer<iter_size_t, T>$/;"	s	namespace:ranges::detail
size_type_t	include/range/v3/iterator/traits.hpp	/^    using size_type_t RANGES_DEPRECATED("size_type_t is deprecated.") =$/;"	t	namespace:ranges	typeref:typename:detail::iter_size_t<I>
sized	include/range/v3/view/any_view.hpp	/^        sized = 16,           \/\/\/<\\brief satisfies ranges::concepts::sized_range$/;"	e	enum:ranges::category
sized	include/range/v3/view/drop_last.hpp	/^                sized,$/;"	e	enum:ranges::detail::drop_last_view::mode_enum
sized	include/range/v3/view/subrange.hpp	/^        sized$/;"	e	enum:ranges::subrange_kind
sized_cursor_difference_t	include/range/v3/detail/range_access.hpp	/^        using sized_cursor_difference_t = decltype($/;"	t	struct:ranges::range_access
sized_generator	include/range/v3/experimental/utility/generator.hpp	/^            sized_generator(promise_type * p)$/;"	f	struct:ranges::experimental::sized_generator
sized_generator	include/range/v3/experimental/utility/generator.hpp	/^        struct sized_generator : generator<Reference, Value>$/;"	s	namespace:ranges::experimental
sized_generator_promise	include/range/v3/experimental/utility/generator.hpp	/^        struct sized_generator_promise : generator_promise<Reference>$/;"	s	namespace:ranges::detail
sized_iterator_range	include/range/v3/iterator_range.hpp	/^        RANGES_NDEBUG_CONSTEXPR sized_iterator_range(I first, S last, size_type size)$/;"	f	struct:ranges::sized_iterator_range	typeref:typename:RANGES_NDEBUG_CONSTEXPR
sized_iterator_range	include/range/v3/iterator_range.hpp	/^    struct sized_iterator_range$/;"	s	namespace:ranges
sized_range_tag	include/range/v3/range/concepts.hpp	/^    using sized_range_tag = ::concepts::tag<sized_range_concept, range_tag>;$/;"	t	namespace:ranges	typeref:typename:::concepts::tag<sized_range_concept,range_tag>
sized_range_tag_of	include/range/v3/range/concepts.hpp	/^    using sized_range_tag_of =$/;"	t	namespace:ranges	typeref:typename:::concepts::tag_of<meta::list<sized_range_concept,range_concept>,T>
sized_sentinel_tag	include/range/v3/iterator/concepts.hpp	/^    using sized_sentinel_tag = concepts::tag<sized_sentinel_for_concept, sentinel_tag>;$/;"	t	namespace:ranges	typeref:typename:concepts::tag<sized_sentinel_for_concept,sentinel_tag>
slice_base_fn	include/range/v3/view/slice.hpp	/^        struct slice_base_fn$/;"	s	namespace:ranges::views
slice_bounds	include/range/v3/view/interface.hpp	/^        struct slice_bounds$/;"	s	namespace:ranges::detail
slice_fn	include/range/v3/action/slice.hpp	/^        struct slice_fn$/;"	s	namespace:ranges::actions
slice_fn	include/range/v3/view/slice.hpp	/^        struct slice_fn : slice_base_fn$/;"	s	namespace:ranges::views
slice_view	include/range/v3/view/slice.hpp	/^    struct slice_view : detail::slice_view_<Rng, (bool)random_access_range<Rng>>$/;"	s	namespace:ranges
slice_view_	include/range/v3/view/slice.hpp	/^            constexpr slice_view_(Rng rng, range_difference_t<Rng> from,$/;"	f	struct:ranges::detail::slice_view_
slice_view_	include/range/v3/view/slice.hpp	/^        struct slice_view_ : view_facade<slice_view<Rng>, finite>$/;"	s	namespace:ranges::detail
slice_view_	include/range/v3/view/slice.hpp	/^        struct slice_view_<Rng, true> : view_interface<slice_view<Rng>, finite>$/;"	s	namespace:ranges::detail
sliding_base_fn	include/range/v3/view/sliding.hpp	/^        struct sliding_base_fn$/;"	s	namespace:ranges::views
sliding_fn	include/range/v3/view/sliding.hpp	/^        struct sliding_fn : sliding_base_fn$/;"	s	namespace:ranges::views
sliding_view	include/range/v3/view/sliding.hpp	/^    struct sliding_view<Rng, sliding_view_detail::cache::first>$/;"	s	namespace:ranges
sliding_view	include/range/v3/view/sliding.hpp	/^    struct sliding_view<Rng, sliding_view_detail::cache::last>$/;"	s	namespace:ranges
sliding_view	include/range/v3/view/sliding.hpp	/^    struct sliding_view<Rng, sliding_view_detail::cache::none>$/;"	s	namespace:ranges
sliding_view_detail	include/range/v3/view/sliding.hpp	/^    namespace sliding_view_detail$/;"	n	namespace:ranges
sort3	include/range/v3/algorithm/nth_element.hpp	/^        auto sort3(I x, I y, I z, C & pred, P & proj) -> CPP_ret(unsigned)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (unsigned)(requires forward_iterator<I> && indirect_relation<C,projected<I,P>>)
sort_fn	include/range/v3/action/sort.hpp	/^        struct sort_fn$/;"	s	namespace:ranges::actions
sort_n_with_buffer_fn	include/range/v3/algorithm/aux_/sort_n_with_buffer.hpp	/^        struct sort_n_with_buffer_fn$/;"	s	namespace:ranges::aux
sout_	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_type * sout_;$/;"	m	struct:ranges::ostream_iterator	typeref:typename:ostream_type *
sout_	include/range/v3/iterator/stream_iterators.hpp	/^        ostream_type * sout_;$/;"	m	struct:ranges::ostream_joiner	typeref:typename:ostream_type *
span	include/range/v3/view/span.hpp	/^        constexpr span(pointer first, pointer last) noexcept$/;"	f	struct:ranges::span
span	include/range/v3/view/span.hpp	/^        constexpr span(pointer ptr, index_type cnt) noexcept$/;"	f	struct:ranges::span
span	include/range/v3/view/span.hpp	/^    struct RANGES_EMPTY_BASES span$/;"	s	namespace:ranges
span_extent	include/range/v3/view/span.hpp	/^            constexpr span_extent(span_index_t size) noexcept$/;"	f	struct:ranges::detail::span_extent
span_extent	include/range/v3/view/span.hpp	/^            constexpr span_extent(tag) noexcept$/;"	f	struct:ranges::detail::span_extent
span_extent	include/range/v3/view/span.hpp	/^        struct span_extent$/;"	s	namespace:ranges::detail
span_extent	include/range/v3/view/span.hpp	/^        struct span_extent<dynamic_extent>$/;"	s	namespace:ranges::detail
span_index_t	include/range/v3/view/span.hpp	/^        using span_index_t = std::ptrdiff_t;$/;"	t	namespace:ranges::detail	typeref:typename:std::ptrdiff_t
split_base_fn	include/range/v3/view/split.hpp	/^        struct split_base_fn$/;"	s	namespace:ranges::views
split_fn	include/range/v3/action/split.hpp	/^        struct split_fn$/;"	s	namespace:ranges::actions
split_fn	include/range/v3/view/split.hpp	/^        struct split_fn : split_base_fn$/;"	s	namespace:ranges::views
split_inner_iterator	include/range/v3/view/split.hpp	/^            constexpr explicit split_inner_iterator(Outer i)$/;"	f	struct:ranges::detail::split_inner_iterator
split_inner_iterator	include/range/v3/view/split.hpp	/^        struct split_inner_iterator<split_view<V, Pattern>, Const>$/;"	s	namespace:ranges::detail
split_outer_iterator	include/range/v3/view/split.hpp	/^        struct split_outer_iterator<split_view<V, Pattern>, Const>$/;"	s	namespace:ranges::detail
split_outer_iterator_base	include/range/v3/view/split.hpp	/^        using split_outer_iterator_base =$/;"	t	namespace:ranges::detail	typeref:typename:meta::invoke<here_or_there_<forward_iterator<It>>,It>
split_value_t	include/range/v3/action/split.hpp	/^            using split_value_t =$/;"	t	struct:ranges::actions::split_fn
split_value_t	include/range/v3/action/split_when.hpp	/^            using split_value_t =$/;"	t	struct:ranges::actions::split_when_fn
split_view	include/range/v3/view/split.hpp	/^             ranges::detail::tiny_range<Pattern>)) using split_view =$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::split_view<Rng,Pattern>
split_view	include/range/v3/view/split.hpp	/^            struct RANGES_EMPTY_BASES split_view$/;"	s	namespace:ranges
split_view	include/range/v3/view/split.hpp	/^        constexpr split_view(V base, Pattern pattern)$/;"	f	struct:ranges::split_view
split_view_base	include/range/v3/view/split.hpp	/^        using split_view_base = meta::invoke<here_or_there_<!forward_iterator<It>>, It>;$/;"	t	namespace:ranges::detail	typeref:typename:meta::invoke<here_or_there_<!forward_iterator<>> It>
split_when_base_fn	include/range/v3/view/split_when.hpp	/^        struct split_when_base_fn$/;"	s	namespace:ranges::views
split_when_fn	include/range/v3/action/split_when.hpp	/^        struct split_when_fn$/;"	s	namespace:ranges::actions
split_when_fn	include/range/v3/view/split_when.hpp	/^        struct split_when_fn : split_when_base_fn$/;"	s	namespace:ranges::views
split_when_view	include/range/v3/view/split_when.hpp	/^        split_when_view(Rng rng, Fun fun)$/;"	f	struct:ranges::split_when_view
split_when_view	include/range/v3/view/split_when.hpp	/^    struct split_when_view$/;"	s	namespace:ranges
stable_partition_impl	include/range/v3/algorithm/stable_partition.hpp	/^        I stable_partition_impl(I first, I last, C pred, P proj, D len, Pair const p,$/;"	f	namespace:ranges::detail	typeref:typename:I
stable_partition_impl	include/range/v3/algorithm/stable_partition.hpp	/^        I stable_partition_impl(I first, I last, C pred, P proj, D len, Pair p,$/;"	f	namespace:ranges::detail	typeref:typename:I
stable_partition_impl	include/range/v3/algorithm/stable_partition.hpp	/^        I stable_partition_impl(I first, S end_, C pred, P proj,$/;"	f	namespace:ranges::detail	typeref:typename:I
stable_partition_impl	include/range/v3/algorithm/stable_partition.hpp	/^        I stable_partition_impl(I first, S last, C pred, P proj,$/;"	f	namespace:ranges::detail	typeref:typename:I
stable_sort_adaptive	include/range/v3/algorithm/stable_sort.hpp	/^        void stable_sort_adaptive(I first, I last, V * buffer, std::ptrdiff_t buffer_size,$/;"	f	namespace:ranges::detail	typeref:typename:void
stable_sort_fn	include/range/v3/action/stable_sort.hpp	/^        struct stable_sort_fn$/;"	s	namespace:ranges::actions
start_	example/comprehensions.cpp	/^  std::chrono::high_resolution_clock::time_point start_;$/;"	m	class:timer	typeref:typename:std::chrono::high_resolution_clock::time_point	file:
state	include/range/v3/view/set_algorithm.hpp	/^            } state;$/;"	m	struct:ranges::detail::set_symmetric_difference_cursor	typeref:enum:ranges::detail::set_symmetric_difference_cursor::state_t
state	include/range/v3/view/set_algorithm.hpp	/^            } state;$/;"	m	struct:ranges::detail::set_union_cursor	typeref:enum:ranges::detail::set_union_cursor::state_t
state_t	include/range/v3/view/set_algorithm.hpp	/^            enum class state_t$/;"	g	struct:ranges::detail::set_symmetric_difference_cursor
state_t	include/range/v3/view/set_algorithm.hpp	/^            enum class state_t$/;"	g	struct:ranges::detail::set_union_cursor
static_const	include/concepts/swap.hpp	/^        struct static_const$/;"	s	namespace:concepts::detail
static_const	include/range/v3/utility/static_const.hpp	/^    struct static_const$/;"	s	namespace:ranges
std	include/range/v3/detail/variant.hpp	/^namespace std$/;"	n
std	include/range/v3/iterator/common_iterator.hpp	/^namespace std$/;"	n
std	include/range/v3/iterator/diffmax_t.hpp	/^namespace std$/;"	n
std	include/range/v3/iterator/insert_iterators.hpp	/^namespace std$/;"	n
std	include/range/v3/iterator/move_iterators.hpp	/^namespace std$/;"	n
std	include/range/v3/iterator/stream_iterators.hpp	/^namespace std$/;"	n
std	include/range/v3/iterator_range.hpp	/^namespace std$/;"	n
std	include/range/v3/utility/common_tuple.hpp	/^namespace std$/;"	n
std	include/range/v3/utility/compressed_pair.hpp	/^namespace std$/;"	n
std	include/range/v3/utility/tagged_pair.hpp	/^namespace std$/;"	n
std	include/range/v3/view/subrange.hpp	/^namespace std$/;"	n
stir	include/range/v3/utility/random.hpp	/^                seed_seq_fe & stir()$/;"	f	struct:ranges::detail::randutils::seed_seq_fe	typeref:typename:seed_seq_fe &
storage	include/range/v3/utility/compressed_pair.hpp	/^        using storage = box<T, meta::list<meta::size_t<I>, Ts...>>;$/;"	t	namespace:ranges::compressed_tuple_detail	typeref:typename:box<T,meta::list<meta::size_t<I>,Ts...>>
store_inner_	include/range/v3/view/join.hpp	/^        struct store_inner_$/;"	s	namespace:ranges::detail
store_size_	include/range/v3/view/subrange.hpp	/^        constexpr bool store_size_() noexcept$/;"	f	namespace:ranges::detail	typeref:typename:bool
str_	include/range/v3/view/getlines.hpp	/^        std::string str_;$/;"	m	struct:ranges::getlines_view	typeref:typename:std::string
strategy_	include/meta/meta.hpp	/^        constexpr indices_strategy_ strategy_(std::size_t cur, std::size_t end)$/;"	f	namespace:meta::detail	typeref:typename:indices_strategy_
streambuf_type	include/range/v3/iterator/stream_iterators.hpp	/^        typedef std::basic_streambuf<Char, Traits> streambuf_type;$/;"	t	struct:ranges::ostreambuf_iterator	typeref:typename:std::basic_streambuf<Char,Traits>
stride_	include/range/v3/view/stride.hpp	/^            range_difference_t<Rng> stride_;$/;"	m	struct:ranges::detail::stride_view_base_	typeref:typename:range_difference_t<Rng>
stride_base_fn	include/range/v3/view/stride.hpp	/^        struct stride_base_fn$/;"	s	namespace:ranges::views
stride_fn	include/range/v3/action/stride.hpp	/^        struct stride_fn$/;"	s	namespace:ranges::actions
stride_fn	include/range/v3/view/stride.hpp	/^        struct stride_fn : stride_base_fn$/;"	s	namespace:ranges::views
stride_view	include/range/v3/view/stride.hpp	/^        constexpr stride_view(Rng rng, range_difference_t<Rng> const stride)$/;"	f	struct:ranges::stride_view
stride_view	include/range/v3/view/stride.hpp	/^    struct stride_view : detail::stride_view_base<Rng>$/;"	s	namespace:ranges
stride_view_adaptor	include/range/v3/view/stride.hpp	/^        using stride_view_adaptor =$/;"	t	namespace:ranges::detail	typeref:typename:view_adaptor<stride_view<Rng>,Rng,is_finite<Rng>::value?finite:range_cardinality<Rng>::value>
stride_view_base	include/range/v3/view/stride.hpp	/^        using stride_view_base = stride_view_base_<Rng, (bool)bidirectional_range<Rng>>;$/;"	t	namespace:ranges::detail
stride_view_base_	include/range/v3/view/stride.hpp	/^            constexpr stride_view_base_(Rng && rng, range_difference_t<Rng> const stride)$/;"	f	struct:ranges::detail::stride_view_base_
stride_view_base_	include/range/v3/view/stride.hpp	/^        struct stride_view_base_ : stride_view_adaptor<Rng>$/;"	s	namespace:ranges::detail
stride_view_base_	include/range/v3/view/stride.hpp	/^        struct stride_view_base_<Rng, false> : stride_view_adaptor<Rng>$/;"	s	namespace:ranges::detail
stride_view_t	include/range/v3/view/stride.hpp	/^            using stride_view_t = meta::const_if_c<Const, stride_view>;$/;"	t	struct:ranges::stride_view::adaptor	typeref:typename:meta::const_if_c<Const,stride_view>
subrange	include/range/v3/view/subrange.hpp	/^            using subrange = ranges::subrange<I, S>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::subrange<I,S>
subrange	include/range/v3/view/subrange.hpp	/^    struct subrange$/;"	s	namespace:ranges
subrange_kind	include/range/v3/view/subrange.hpp	/^    enum class subrange_kind : bool$/;"	g	namespace:ranges	typeref:typename:bool
subs_	include/range/v3/view/tokenize.hpp	/^        SubMatchRange subs_;$/;"	m	struct:ranges::tokenize_view	typeref:typename:SubMatchRange
subspan	include/range/v3/view/span.hpp	/^        constexpr span<T, (N >= Offset ? N - Offset : dynamic_extent)> subspan() const$/;"	f	struct:ranges::span	typeref:typename:span<T,(N>=Offset?N-Offset:dynamic_extent)>
subspan	include/range/v3/view/span.hpp	/^        constexpr span<T, detail::subspan_extent(N, Offset, Count)> subspan() const$/;"	f	struct:ranges::span	typeref:typename:span<T,detail::subspan_extent (N,Offset,Count)>
subspan	include/range/v3/view/span.hpp	/^        constexpr span<T, dynamic_extent> subspan(index_type offset) const noexcept$/;"	f	struct:ranges::span	typeref:typename:span<T,dynamic_extent>
subspan	include/range/v3/view/span.hpp	/^        constexpr span<T, dynamic_extent> subspan(index_type offset, index_type cnt) const$/;"	f	struct:ranges::span	typeref:typename:span<T,dynamic_extent>
subspan_extent	include/range/v3/view/span.hpp	/^        constexpr span_index_t subspan_extent(span_index_t Extent, span_index_t Offset,$/;"	f	namespace:ranges::detail	typeref:typename:span_index_t
sum_	include/range/v3/view/exclusive_scan.hpp	/^            semiregular_box_t<T> sum_;$/;"	m	struct:ranges::exclusive_scan_view::adaptor	typeref:typename:semiregular_box_t<T>
sum_	include/range/v3/view/partial_sum.hpp	/^            RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<range_value_t<Rng>> sum_;$/;"	m	struct:ranges::partial_sum_view::cursor	typeref:typename:RANGES_NO_UNIQUE_ADDRESS semiregular_box_t<range_value_t<Rng>>
sv_base	include/range/v3/view/sliding.hpp	/^            sv_base(Rng rng, range_difference_t<Rng> n)$/;"	f	struct:ranges::sliding_view_detail::sv_base
sv_base	include/range/v3/view/sliding.hpp	/^        struct RANGES_EMPTY_BASES sv_base$/;"	s	namespace:ranges::sliding_view_detail
swap	include/range/v3/experimental/utility/generator.hpp	/^            void swap(coroutine_owner & that) noexcept$/;"	f	struct:ranges::experimental::coroutine_owner	typeref:typename:void
swap	include/range/v3/experimental/utility/generator.hpp	/^            void swap(experimental::coroutine_owner<Promise> & x,$/;"	f	namespace:ranges::detail::coroutine_owner_	typeref:typename:void
swap	include/range/v3/utility/any.hpp	/^        friend void swap(any & x, any & y) noexcept$/;"	f	namespace:ranges	typeref:typename:void
swap	include/range/v3/utility/any.hpp	/^        inline void swap(any & x, any & y) noexcept$/;"	f	namespace:ranges::_any_	typeref:typename:void
swap	include/range/v3/utility/any.hpp	/^        void swap(any & that) noexcept$/;"	f	struct:ranges::any	typeref:typename:void
swap	include/range/v3/utility/optional.hpp	/^                constexpr auto swap(optional_base & that) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:CPP_member auto
swap	include/range/v3/utility/tagged_pair.hpp	/^        constexpr auto swap($/;"	f	namespace:ranges::_tagged_	typeref:typename:auto
swap	include/range/v3/utility/tagged_pair.hpp	/^        constexpr auto swap(tagged & that) noexcept(is_nothrow_swappable<B>::value)$/;"	f	class:ranges::tagged	typeref:typename:auto
swap	include/range/v3/utility/tagged_pair.hpp	/^        friend constexpr auto swap(tagged & x,$/;"	f	namespace:ranges	typeref:typename:auto
swap_	include/range/v3/utility/optional.hpp	/^                constexpr void swap_(std::false_type, optional_base & that) noexcept($/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:void
swap_	include/range/v3/utility/optional.hpp	/^                constexpr void swap_(std::true_type, optional_base & that) noexcept$/;"	f	struct:ranges::detail::optional_adl::optional_base	typeref:typename:void
swap_fn	include/concepts/swap.hpp	/^        struct swap_fn$/;"	s	namespace:concepts::adl_swap_detail
swap_ranges_result	include/range/v3/algorithm/swap_ranges.hpp	/^    using swap_ranges_result = detail::in1_in2_result<I1, I2>;$/;"	t	namespace:ranges	typeref:typename:detail::in1_in2_result<I1,I2>
sync_URNG	include/range/v3/utility/random.hpp	/^        class sync_URNG : private URNG$/;"	c	namespace:ranges::detail
t_	include/range/v3/detail/variant.hpp	/^            T ** t_;$/;"	m	struct:ranges::detail::get_fn	typeref:typename:T **
t_	include/range/v3/functional/reference_wrapper.hpp	/^            T * t_ = nullptr;$/;"	m	struct:ranges::detail::reference_wrapper_	typeref:typename:T *
tag	include/concepts/concepts.hpp	/^    struct tag$/;"	s	namespace:concepts
tag	include/range/v3/iterator/diffmax_t.hpp	/^            struct tag$/;"	s	struct:ranges::detail::diffmax_t
tag	include/range/v3/utility/optional.hpp	/^                struct tag$/;"	s	struct:ranges::detail::optional_adl::optional_storage
tag	include/range/v3/utility/optional.hpp	/^        struct tag$/;"	s	struct:ranges::nullopt_t
tag	include/range/v3/utility/semiregular_box.hpp	/^        struct tag$/;"	s	struct:ranges::semiregular_box
tag	include/range/v3/view/span.hpp	/^            struct tag$/;"	s	struct:ranges::detail::span_extent
tag_elem	include/range/v3/utility/tagged_pair.hpp	/^        using tag_elem = meta::back<meta::as_list<T>>;$/;"	t	namespace:ranges::detail	typeref:typename:meta::back<meta::as_list<T>>
tag_of	include/concepts/concepts.hpp	/^    using tag_of =$/;"	t	namespace:concepts
tag_spec	include/range/v3/utility/tagged_pair.hpp	/^        using tag_spec = meta::front<meta::as_list<T>>;$/;"	t	namespace:ranges::detail	typeref:typename:meta::front<meta::as_list<T>>
tagged	include/range/v3/utility/tagged_pair.hpp	/^        "Class template tagged is deprecated.") tagged$/;"	c	namespace:ranges
tagged_chain	include/range/v3/utility/tagged_pair.hpp	/^        struct tagged_chain$/;"	s	namespace:ranges::detail
tagged_chain	include/range/v3/utility/tagged_pair.hpp	/^        struct tagged_chain<Base, I, First, Rest...>$/;"	s	namespace:ranges::detail
tagged_pair	include/range/v3/utility/tagged_pair.hpp	/^    using tagged_pair RANGES_DEPRECATED("ranges::tagged_pair is deprecated.") =$/;"	t	namespace:ranges
tagged_tuple	include/range/v3/utility/tagged_tuple.hpp	/^    using tagged_tuple RANGES_DEPRECATED("ranges::tagged_tuple is deprecated.") =$/;"	t	namespace:ranges	typeref:typename:tagged<std::tuple<detail::tag_elem<Ts>...>,detail::tag_spec<Ts>...>
tail	include/range/v3/detail/variant.hpp	/^                    tail_t tail;$/;"	m	union:ranges::detail::variant_data_::type::__anon4da570f9020a	typeref:typename:tail_t
tail	include/range/v3/detail/variant.hpp	/^                    tail_t tail;$/;"	m	union:ranges::detail::variant_data_::type::__anon4da570f9030a	typeref:typename:tail_t
tail_fn	include/range/v3/view/tail.hpp	/^        struct tail_fn$/;"	s	namespace:ranges::views
tail_t	include/range/v3/detail/variant.hpp	/^                using tail_t = meta::_t<variant_data_<meta::list<Ts...>>>;$/;"	t	struct:ranges::detail::variant_data_::type	typeref:typename:meta::_t<variant_data_<meta::list<Ts...>>>
tail_view	include/range/v3/view/tail.hpp	/^        tail_view(Rng rng)$/;"	f	struct:ranges::tail_view
tail_view	include/range/v3/view/tail.hpp	/^    struct tail_view$/;"	s	namespace:ranges
take_address	include/range/v3/view/addressof.hpp	/^            struct take_address$/;"	s	struct:ranges::views::addressof_fn
take_base_fn	include/range/v3/view/take.hpp	/^        struct take_base_fn$/;"	s	namespace:ranges::views
take_exactly_base_fn	include/range/v3/view/take_exactly.hpp	/^        struct take_exactly_base_fn$/;"	s	namespace:ranges::views
take_exactly_fn	include/range/v3/view/take_exactly.hpp	/^        struct take_exactly_fn : take_exactly_base_fn$/;"	s	namespace:ranges::views
take_exactly_view	include/range/v3/view/take_exactly.hpp	/^    using take_exactly_view = detail::take_exactly_view_<Rng>;$/;"	t	namespace:ranges	typeref:typename:detail::take_exactly_view_<Rng>
take_exactly_view_	include/range/v3/view/take_exactly.hpp	/^            take_exactly_view_(Rng rng, range_difference_t<Rng> n)$/;"	f	struct:ranges::detail::take_exactly_view_
take_exactly_view_	include/range/v3/view/take_exactly.hpp	/^        struct take_exactly_view_$/;"	s	namespace:ranges::detail
take_exactly_view_	include/range/v3/view/take_exactly.hpp	/^        struct take_exactly_view_<Rng, true>$/;"	s	namespace:ranges::detail
take_fn	include/range/v3/action/take.hpp	/^        struct take_fn$/;"	s	namespace:ranges::actions
take_fn	include/range/v3/view/take.hpp	/^        struct take_fn : take_base_fn$/;"	s	namespace:ranges::views
take_last_base_fn	include/range/v3/view/take_last.hpp	/^        struct take_last_base_fn$/;"	s	namespace:ranges::views
take_last_fn	include/range/v3/view/take_last.hpp	/^        struct take_last_fn : take_last_base_fn$/;"	s	namespace:ranges::views
take_view	include/range/v3/view/take.hpp	/^            using take_view = ranges::take_view<Rng>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::take_view<Rng>
take_view	include/range/v3/view/take.hpp	/^        constexpr take_view(Rng base, range_difference_t<Rng> cnt)$/;"	f	struct:ranges::take_view
take_view	include/range/v3/view/take.hpp	/^    struct take_view : view_interface<take_view<Rng>, finite>$/;"	s	namespace:ranges
take_while_base_fn	include/range/v3/view/take_while.hpp	/^        struct take_while_base_fn$/;"	s	namespace:ranges::views
take_while_fn	include/range/v3/action/take_while.hpp	/^        struct take_while_fn$/;"	s	namespace:ranges::actions
take_while_fn	include/range/v3/view/take_while.hpp	/^        struct take_while_fn : take_while_base_fn$/;"	s	namespace:ranges::views
take_while_view	include/range/v3/view/take_while.hpp	/^            using take_while_view = ranges::take_while_view<Rng, Pred>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::take_while_view<Rng,Pred>
take_while_view	include/range/v3/view/take_while.hpp	/^        constexpr take_while_view(Rng rng, Pred pred)$/;"	f	struct:ranges::take_while_view
take_while_view	include/range/v3/view/take_while.hpp	/^    struct take_while_view : iter_take_while_view<Rng, indirected<Pred>>$/;"	s	namespace:ranges
templ	include/ntskills.hpp	/^  template <typename T> struct templ : crtp<T, templ> {$/;"	s	struct:nt::ImplicitlyConvertibleTo
test	include/range/v3/range/concepts.hpp	/^            static constexpr auto test(T const *) -> CPP_ret(bool)( \/\/$/;"	f	struct:ranges::detail::enable_view_helper_	typeref:typename:CPP_ret (bool)(requires range<T> && range<T const>)
test	include/range/v3/range/concepts.hpp	/^            static constexpr auto test(void const *) -> bool$/;"	f	struct:ranges::detail::enable_view_helper_	typeref:typename:bool
there	include/range/v3/view/split.hpp	/^        struct there$/;"	s	namespace:ranges::detail
throw_bad_optional_access	include/range/v3/utility/optional.hpp	/^        [[noreturn]] bool throw_bad_optional_access()$/;"	f	namespace:ranges::detail	typeref:typename:[[noreturn]]bool
timer	example/comprehensions.cpp	/^  timer() { reset(); }$/;"	f	class:timer	file:
timer	example/comprehensions.cpp	/^class timer {$/;"	c	file:
tinyness_before	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool tinyness_before = false;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
tinyness_before	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::tinyness_before;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
tmp1	include/range/v3/iterator/basic_iterator.hpp	/^            using tmp1 = meta::list<value_t_, R1>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:meta::list<value_t_,R1>
tmp2	include/range/v3/iterator/basic_iterator.hpp	/^            using tmp2 =$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:meta::if_<meta::in<tmp1,uncvref_t<R2>>,tmp1,meta::push_back<tmp1,R2>>
tmp3	include/range/v3/iterator/basic_iterator.hpp	/^            using tmp3 =$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:meta::if_<meta::in<tmp2,uncvref_t<R3>>,tmp2,meta::push_back<tmp2,R3>>
to	include/range/v3/range/conversion.hpp	/^        auto to(RANGES_HIDDEN_DETAIL(detail::to_container = {}))$/;"	f	namespace:ranges::_to_	typeref:typename:detail::to_container_fn<detail::from_range<ContT>>
to	include/range/v3/range/conversion.hpp	/^        auto to(RANGES_HIDDEN_DETAIL(detail::to_container = {}))$/;"	f	namespace:ranges::_to_	typeref:typename:detail::to_container_fn<meta::id<Cont>>
to	include/range/v3/range/conversion.hpp	/^        auto to(Rng && rng) -> CPP_ret(Cont)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (Cont)(requires range<Rng> && detail::convertible_to_container<Rng,Cont>)
to	include/range/v3/range/conversion.hpp	/^        auto to(Rng && rng) -> CPP_ret(ContT<range_value_t<Rng>>)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (ContT<range_value_t<Rng>>)(requires range<Rng> && detail::convertible_to_container<Rng,ContT<range_value_t<Rng>>>)
to	include/range/v3/range/conversion.hpp	/^        auto to(std::initializer_list<T> il) -> CPP_ret(Cont)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (Cont)(requires detail::convertible_to_container<std::initializer_list<T>,Cont>)
to	include/range/v3/range/conversion.hpp	/^        auto to(std::initializer_list<T> il) -> CPP_ret(ContT<T>)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (ContT<T>)(requires detail::convertible_to_container<std::initializer_list<T>,ContT<T>>)
to	include/range/v3/view/interface.hpp	/^            To to;$/;"	m	struct:ranges::detail::slice_bounds	typeref:typename:To
to_	include/range/v3/iterator/operations.hpp	/^    constexpr void advance_fn::to_(I & i, S s, std::false_type)$/;"	f	class:ranges::advance_fn	typeref:typename:void
to_	include/range/v3/iterator/operations.hpp	/^    constexpr void advance_fn::to_(I & i, S s, std::true_type)$/;"	f	class:ranges::advance_fn	typeref:typename:void
to_	include/range/v3/range/conversion.hpp	/^        auto to_(Rng && rng) -> CPP_ret(Cont)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (Cont)(requires range<Rng> && detail::convertible_to_container<Rng,Cont>)
to_	include/range/v3/range/conversion.hpp	/^        auto to_(Rng && rng) -> CPP_ret(ContT<range_value_t<Rng>>)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (ContT<range_value_t<Rng>>)(requires range<Rng> && detail::convertible_to_container<Rng,ContT<range_value_t<Rng>>>)
to_	include/range/v3/range/conversion.hpp	/^        auto to_(detail::to_container = {}) -> detail::to_container_fn<meta::id<Cont>>$/;"	f	namespace:ranges::_to_	typeref:typename:detail::to_container_fn<meta::id<Cont>>
to_	include/range/v3/range/conversion.hpp	/^        auto to_(detail::to_container = {})$/;"	f	namespace:ranges::_to_	typeref:typename:detail::to_container_fn<detail::from_range<ContT>>
to_	include/range/v3/range/conversion.hpp	/^        auto to_(std::initializer_list<T> il) -> CPP_ret(ContT<T>)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (ContT<T>)(requires detail::convertible_to_container<std::initializer_list<T>,ContT<T>>)
to_	include/range/v3/range/conversion.hpp	/^        auto to_(std::initializer_list<T> list) -> CPP_ret(Cont)( \/\/$/;"	f	namespace:ranges::_to_	typeref:typename:CPP_ret (Cont)(requires detail::convertible_to_container<std::initializer_list<T>,Cont>)
to_	include/range/v3/view/iota.hpp	/^            RANGES_NO_UNIQUE_ADDRESS To to_ = To();$/;"	m	struct:ranges::closed_iota_view::cursor	typeref:typename:RANGES_NO_UNIQUE_ADDRESS To
to_	include/range/v3/view/iota.hpp	/^            RANGES_NO_UNIQUE_ADDRESS To to_;$/;"	m	struct:ranges::iota_view::sentinel	typeref:typename:RANGES_NO_UNIQUE_ADDRESS To
to_	include/range/v3/view/iota.hpp	/^        RANGES_NO_UNIQUE_ADDRESS To to_ = To();$/;"	m	struct:ranges::closed_iota_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS To
to_	include/range/v3/view/iota.hpp	/^        RANGES_NO_UNIQUE_ADDRESS To to_ = To();$/;"	m	struct:ranges::iota_view	typeref:typename:RANGES_NO_UNIQUE_ADDRESS To
to_	include/range/v3/view/linear_distribute.hpp	/^            T from_, to_;$/;"	m	struct:ranges::views::linear_distribute_view	typeref:typename:T
to_container	include/range/v3/range/conversion.hpp	/^        struct to_container$/;"	s	namespace:ranges::detail
to_container_fn	include/range/v3/range/conversion.hpp	/^        using to_container_fn = to_container::fn<ToContainer>;$/;"	t	namespace:ranges::detail	typeref:typename:to_container::fn<ToContainer>
to_container_iterator	include/range/v3/range/conversion.hpp	/^            to_container_iterator(OtherIt it)$/;"	f	struct:ranges::detail::to_container_iterator
to_container_iterator	include/range/v3/range/conversion.hpp	/^        struct to_container_iterator$/;"	s	namespace:ranges::detail
to_container_iterator_t	include/range/v3/range/conversion.hpp	/^        using to_container_iterator_t =$/;"	t	namespace:ranges::detail
to_impl_	include/range/v3/iterator/operations.hpp	/^    constexpr void advance_fn::to_impl_(I & i, S s, sentinel_tag)$/;"	f	class:ranges::advance_fn	typeref:typename:void
to_impl_	include/range/v3/iterator/operations.hpp	/^    constexpr void advance_fn::to_impl_(I & i, S s, sized_sentinel_tag)$/;"	f	class:ranges::advance_fn	typeref:typename:void
to_std_tuple	include/range/v3/utility/common_tuple.hpp	/^        std::tuple<Us...> to_std_tuple(Tup && tup, meta::index_sequence<Is...>)$/;"	f	namespace:ranges::detail	typeref:typename:std::tuple<Us...>
toggle_	include/range/v3/view/intersperse.hpp	/^            bool toggle_ = false;$/;"	m	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:bool
tokenize_base_fn	include/range/v3/view/tokenize.hpp	/^        struct tokenize_base_fn$/;"	s	namespace:ranges::views
tokenize_fn	include/range/v3/view/tokenize.hpp	/^        struct tokenize_fn : tokenize_base_fn$/;"	s	namespace:ranges::views
tokenize_view	include/range/v3/view/tokenize.hpp	/^        tokenize_view(Rng rng, Regex rex, SubMatchRange subs,$/;"	f	struct:ranges::tokenize_view
tokenize_view	include/range/v3/view/tokenize.hpp	/^    struct tokenize_view$/;"	s	namespace:ranges
trailing	include/range/v3/view/sliding.hpp	/^            constexpr trailing(Rng & rng)$/;"	f	struct:ranges::sliding_view_detail::trailing
trailing	include/range/v3/view/sliding.hpp	/^            constexpr trailing(Rng &) noexcept$/;"	f	struct:ranges::sliding_view_detail::trailing
trailing	include/range/v3/view/sliding.hpp	/^        struct trailing$/;"	s	namespace:ranges::sliding_view_detail
trailing	include/range/v3/view/sliding.hpp	/^        struct trailing<Rng, true>$/;"	s	namespace:ranges::sliding_view_detail
traits_type	include/range/v3/iterator/stream_iterators.hpp	/^        typedef Traits traits_type;$/;"	t	struct:ranges::ostreambuf_iterator	typeref:typename:Traits
traits_type	include/range/v3/iterator/stream_iterators.hpp	/^        using traits_type = Traits;$/;"	t	struct:ranges::ostream_iterator	typeref:typename:Traits
traits_type	include/range/v3/iterator/stream_iterators.hpp	/^        using traits_type = Traits;$/;"	t	struct:ranges::ostream_joiner	typeref:typename:Traits
transform2_cardinality	include/range/v3/view/transform.hpp	/^        constexpr cardinality transform2_cardinality(cardinality c1, cardinality c2)$/;"	f	namespace:ranges::detail	typeref:typename:cardinality
transform2_view	include/range/v3/view/transform.hpp	/^        constexpr transform2_view(Rng1 rng1, Rng2 rng2, Fun fun)$/;"	f	struct:ranges::transform2_view
transform2_view	include/range/v3/view/transform.hpp	/^    struct transform2_view : iter_transform2_view<Rng1, Rng2, indirected<Fun>>$/;"	s	namespace:ranges
transform_base_fn	include/range/v3/view/transform.hpp	/^        struct transform_base_fn$/;"	s	namespace:ranges::views
transform_fn	include/range/v3/action/transform.hpp	/^        struct transform_fn$/;"	s	namespace:ranges::actions
transform_fn	include/range/v3/view/transform.hpp	/^        struct transform_fn : transform_base_fn$/;"	s	namespace:ranges::views
transform_view	include/range/v3/view/transform.hpp	/^            using transform_view = ranges::transform_view<Rng, F>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::transform_view<Rng,F>
transform_view	include/range/v3/view/transform.hpp	/^        transform_view(Rng rng, Fun fun)$/;"	f	struct:ranges::transform_view
transform_view	include/range/v3/view/transform.hpp	/^    struct transform_view : iter_transform_view<Rng, indirected<Fun>>$/;"	s	namespace:ranges
transformed	include/range/v3/functional/on.hpp	/^        constexpr transformed(Fn1 fn1, Fn2 fn2)$/;"	f	struct:ranges::transformed
transformed	include/range/v3/functional/on.hpp	/^    struct transformed$/;"	s	namespace:ranges
transpose	example/calendar.cpp	/^transpose()$/;"	f	typeref:typename:auto
transpose_months	example/calendar.cpp	/^transpose_months()$/;"	f	typeref:typename:auto
traps	include/range/v3/iterator/diffmax_t.hpp	/^        static constexpr bool traps = true;$/;"	m	struct:std::numeric_limits	typeref:typename:bool
traps	include/range/v3/iterator/diffmax_t.hpp	/^    inline constexpr bool numeric_limits<::ranges::detail::diffmax_t>::traps;$/;"	m	class:std::numeric_limits<::ranges::detail::diffmax_t>	typeref:typename:bool
tree_iterator	test/p.cpp	/^template <typename T> struct tree_iterator {$/;"	s	file:
trim_base_fn	include/range/v3/view/trim.hpp	/^        struct trim_base_fn$/;"	s	namespace:ranges::views
trim_fn	include/range/v3/view/trim.hpp	/^        struct trim_fn : trim_base_fn$/;"	s	namespace:ranges::views
trim_view	include/range/v3/view/trim.hpp	/^        constexpr trim_view(Rng rng, Pred pred)$/;"	f	struct:ranges::trim_view
trim_view	include/range/v3/view/trim.hpp	/^    struct trim_view : view_interface<trim_view<Rng, Pred>>$/;"	s	namespace:ranges
tuple_apply_fn	include/range/v3/utility/tuple_algorithm.hpp	/^    struct tuple_apply_fn$/;"	s	namespace:ranges
tuple_element	include/range/v3/iterator_range.hpp	/^    struct tuple_element<0, ::ranges::iterator_range<I, S>>$/;"	v	namespace:std	typeref:struct:tuple_size template struct
tuple_element	include/range/v3/iterator_range.hpp	/^    struct tuple_element<0, ::ranges::sized_iterator_range<I, S>>$/;"	v	namespace:std	typeref:struct:tuple_size template struct
tuple_element	include/range/v3/utility/common_tuple.hpp	/^    struct tuple_element<0, ::ranges::common_pair<First, Second>>$/;"	v	namespace:std	typeref:struct:tuple_size template struct
tuple_element	include/range/v3/utility/common_tuple.hpp	/^    struct tuple_element<N, ::ranges::common_tuple<Ts...>>$/;"	v	namespace:std	typeref:struct:tuple_size template struct
tuple_element	include/range/v3/utility/compressed_pair.hpp	/^    struct tuple_element<0, ::ranges::compressed_pair<First, Second>>$/;"	v	namespace:std	typeref:struct:tuple_size template struct tuple_element template struct tuple_size template struct
tuple_element	include/range/v3/view/subrange.hpp	/^    struct tuple_element<0, ::ranges::subrange<I, S, K>>$/;"	v	namespace:std	typeref:struct:tuple_size template struct
tuple_element_fun_t	include/range/v3/view/subrange.hpp	/^        using tuple_element_fun_t = void (*)(meta::_t<std::tuple_element<N, T>> const &);$/;"	t	namespace:ranges::detail
tuple_foldl_fn	include/range/v3/utility/tuple_algorithm.hpp	/^    struct tuple_foldl_fn$/;"	s	namespace:ranges
tuple_for_each_fn	include/range/v3/utility/tuple_algorithm.hpp	/^    struct tuple_for_each_fn$/;"	s	namespace:ranges
tuple_indices_t	include/range/v3/utility/tuple_algorithm.hpp	/^    using tuple_indices_t = meta::make_index_sequence<$/;"	t	namespace:ranges	typeref:typename:meta::make_index_sequence<std::tuple_size<typename std::remove_reference<Tup>::type>::value>
tuple_t	include/range/v3/functional/bind_back.hpp	/^            struct tuple_t$/;"	s	struct:ranges::detail::bind_back_fn_
tuple_t	include/range/v3/functional/bind_back.hpp	/^            using tuple_t = std::tuple<Fn, Args...>;$/;"	t	struct:ranges::detail::bind_back_fn_	typeref:typename:std::tuple<Fn,Args...>
tuple_transform_fn	include/range/v3/utility/tuple_algorithm.hpp	/^    struct tuple_transform_fn$/;"	s	namespace:ranges
type	include/concepts/type_traits.hpp	/^            using type = T const &;$/;"	t	struct:concepts::detail::as_cref_	typeref:typename:T const &
type	include/concepts/type_traits.hpp	/^            using type = To const volatile;$/;"	t	struct:concepts::detail::_copy_cv_	typeref:typename:To const volatile
type	include/concepts/type_traits.hpp	/^            using type = To const;$/;"	t	struct:concepts::detail::_copy_cv_	typeref:typename:To const
type	include/concepts/type_traits.hpp	/^            using type = To volatile;$/;"	t	struct:concepts::detail::_copy_cv_	typeref:typename:To volatile
type	include/concepts/type_traits.hpp	/^            using type = To;$/;"	t	struct:concepts::detail::_copy_cv_	typeref:typename:To
type	include/concepts/type_traits.hpp	/^            using type = void const;$/;"	t	struct:concepts::detail::as_cref_	typeref:typename:void const
type	include/concepts/type_traits.hpp	/^            using type = void;$/;"	t	struct:concepts::detail::as_cref_	typeref:typename:void
type	include/meta/meta.hpp	/^            using type = State;$/;"	t	struct:meta::detail::make_indices_	typeref:typename:State
type	include/meta/meta.hpp	/^            using type = index_sequence<>;$/;"	t	struct:meta::detail::make_indices_	typeref:typename:index_sequence<>
type	include/meta/meta.hpp	/^            using type = std::false_type;$/;"	t	struct:meta::detail::is_callable_	typeref:typename:std::false_type
type	include/meta/meta.hpp	/^            using type = std::false_type;$/;"	t	struct:meta::detail::is_trait_	typeref:typename:std::false_type
type	include/meta/meta.hpp	/^        using type = T;$/;"	t	struct:meta::id	typeref:typename:T
type	include/meta/meta_fwd.hpp	/^        typename T::type;$/;"	m	class:meta::T	typeref:typename:typename
type	include/range/v3/detail/range_access.hpp	/^            using type = decltype(range_access::contiguous_2_<T>(42));$/;"	t	struct:ranges::range_access::contiguous_
type	include/range/v3/detail/range_access.hpp	/^            using type = decltype(range_access::cursor_difference_2_<Cur>(42));$/;"	t	struct:ranges::range_access::cursor_difference
type	include/range/v3/detail/range_access.hpp	/^            using type = decltype(range_access::mixin_base_2_<Cur>(42));$/;"	t	struct:ranges::range_access::mixin_base_
type	include/range/v3/detail/range_access.hpp	/^            using type = decltype(range_access::single_pass_2_<T>(42));$/;"	t	struct:ranges::range_access::single_pass_
type	include/range/v3/detail/variant.hpp	/^                constexpr type(meta::size_t<0>, Args &&... args) noexcept($/;"	f	struct:ranges::detail::variant_data_::type
type	include/range/v3/detail/variant.hpp	/^                constexpr type(meta::size_t<N>, Args &&... args) noexcept($/;"	f	struct:ranges::detail::variant_data_::type
type	include/range/v3/detail/variant.hpp	/^                type() noexcept$/;"	f	struct:ranges::detail::variant_data_::type
type	include/range/v3/detail/variant.hpp	/^            struct type$/;"	s	struct:ranges::detail::variant_data_
type	include/range/v3/detail/variant.hpp	/^            using type = indexed_datum<void, meta::npos>;$/;"	t	struct:ranges::detail::variant_data_	typeref:typename:indexed_datum<void,meta::npos>
type	include/range/v3/functional/invoke.hpp	/^            using type = decltype(invoke(std::declval<Fun>(), std::declval<Args>()...));$/;"	t	struct:ranges::detail::_invoke_result_
type	include/range/v3/functional/reference_wrapper.hpp	/^        using type = meta::_t<std::remove_reference<T>>;$/;"	t	struct:ranges::reference_wrapper	typeref:typename:meta::_t<std::remove_reference<T>>
type	include/range/v3/iterator/concepts.hpp	/^            using type = decltype(iterator_category_::test(iterator_tag_of<I>{}));$/;"	t	struct:ranges::detail::iterator_category_
type	include/range/v3/utility/any.hpp	/^            std::type_info const & type() const noexcept override$/;"	f	struct:ranges::any::impl	typeref:typename:std::type_info const &
type	include/range/v3/utility/any.hpp	/^        std::type_info const & type() const noexcept$/;"	f	struct:ranges::any	typeref:typename:std::type_info const &
type	include/range/v3/utility/tagged_pair.hpp	/^            using type = _tuple_wrapper_::forward_tuple_interface<Base>;$/;"	t	struct:ranges::detail::tagged_chain	typeref:typename:_tuple_wrapper_::forward_tuple_interface<Base>
type	include/range/v3/utility/tagged_pair.hpp	/^            using type = typename First::template getter<$/;"	t	struct:ranges::detail::tagged_chain	typeref:typename:First::template getter<Base,I,meta::_t<tagged_chain<Base,I+1,Rest...>>>
unary_transform_result	include/range/v3/algorithm/transform.hpp	/^    using unary_transform_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
unbounded_fn	include/range/v3/view/unbounded.hpp	/^        struct unbounded_fn$/;"	s	namespace:ranges::views
unbounded_view	include/range/v3/view/unbounded.hpp	/^        constexpr explicit unbounded_view(I it)$/;"	f	struct:ranges::unbounded_view
unbounded_view	include/range/v3/view/unbounded.hpp	/^    struct unbounded_view : view_interface<unbounded_view<I>, infinite>$/;"	s	namespace:ranges
unbox_fn	include/range/v3/detail/variant.hpp	/^        using unbox_fn = detail::get_datum_fn;$/;"	t	struct:ranges::variant	typeref:typename:detail::get_datum_fn
uncounted	include/range/v3/iterator/operations.hpp	/^        constexpr I uncounted(I i)$/;"	f	namespace:ranges::adl_uncounted_recounted_detail	typeref:typename:I
uncounted_fn	include/range/v3/iterator/operations.hpp	/^        struct uncounted_fn$/;"	s	namespace:ranges::adl_uncounted_recounted_detail
uncounted_t	include/range/v3/view/sliding.hpp	/^        using uncounted_t =$/;"	t	namespace:ranges::sliding_view_detail
underlying	include/newtype.hpp	/^  T &underlying() { return static_cast<T &>(*this); }$/;"	f	struct:abo::nt::crtp	typeref:typename:T &
underlying	include/newtype.hpp	/^  T const &underlying() const { return static_cast<T const &>(*this); }$/;"	f	struct:abo::nt::crtp	typeref:typename:T const &
underlying	include/ntskills.hpp	/^  T &underlying() { return static_cast<T &>(*this); }$/;"	f	struct:nt::crtp	typeref:typename:T &
underlying	include/ntskills.hpp	/^  T const &underlying() const { return static_cast<T const &>(*this); }$/;"	f	struct:nt::crtp	typeref:typename:T const &
unguarded_insertion_sort	include/range/v3/algorithm/sort.hpp	/^        inline void unguarded_insertion_sort(I first, I last, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:void
unguarded_linear_insert	include/range/v3/algorithm/sort.hpp	/^        inline void unguarded_linear_insert(I last, iter_value_t<I> val, C & pred,$/;"	f	namespace:ranges::detail	typeref:typename:void
unguarded_partition	include/range/v3/algorithm/sort.hpp	/^        inline I unguarded_partition(I first, I last, C & pred, P & proj)$/;"	f	namespace:ranges::detail	typeref:typename:I
unhandled_exception	include/range/v3/experimental/utility/generator.hpp	/^            void unhandled_exception() noexcept$/;"	f	struct:ranges::detail::generator_promise	typeref:typename:void
uninitialized_copy	include/range/v3/detail/variant.hpp	/^        O uninitialized_copy(I first, I last, O out)$/;"	f	namespace:ranges::detail	typeref:typename:O
uninitialized_copy	include/range/v3/detail/variant.hpp	/^        auto uninitialized_copy(I first, S last, O out) -> CPP_ret(O)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (O)(requires (!sized_sentinel_for<S,I>))
uninitialized_copy	include/range/v3/detail/variant.hpp	/^        auto uninitialized_copy(I first, S last, O out) -> CPP_ret(O)( \/\/$/;"	f	namespace:ranges::detail	typeref:typename:CPP_ret (O)(requires sized_sentinel_for<S,I>)
union_fn	include/union.hpp	/^template <typename P> struct union_fn {$/;"	s	namespace:abo
unique_base_fn	include/range/v3/view/unique.hpp	/^        struct unique_base_fn$/;"	s	namespace:ranges::views
unique_copy_impl	include/range/v3/algorithm/unique_copy.hpp	/^        unique_copy_result<I, O> unique_copy_impl(I first, S last, O out, C pred, P proj,$/;"	f	namespace:ranges::detail	typeref:typename:unique_copy_result<I,O>
unique_copy_result	include/range/v3/algorithm/unique_copy.hpp	/^    using unique_copy_result = detail::in_out_result<I, O>;$/;"	t	namespace:ranges	typeref:typename:detail::in_out_result<I,O>
unique_fn	include/range/v3/action/unique.hpp	/^        struct unique_fn$/;"	s	namespace:ranges::actions
unique_fn	include/range/v3/view/unique.hpp	/^        struct unique_fn : unique_base_fn$/;"	s	namespace:ranges::views
unique_variant	include/range/v3/detail/variant.hpp	/^    variant_unique_t<variant<Ts...>> unique_variant(variant<Ts...> const & var)$/;"	f	namespace:ranges	typeref:typename:variant_unique_t<variant<Ts...>>
unreachable_sentinel_t	include/range/v3/iterator/unreachable_sentinel.hpp	/^    struct unreachable_sentinel_t$/;"	s	namespace:ranges
unsized	include/range/v3/view/subrange.hpp	/^        unsized,$/;"	e	enum:ranges::subrange_kind
unstable_remove_if_fn	include/range/v3/action/unstable_remove_if.hpp	/^        struct unstable_remove_if_fn$/;"	s	namespace:ranges::actions
unwrap_reference_fn	include/range/v3/functional/reference_wrapper.hpp	/^    struct unwrap_reference_fn$/;"	s	namespace:ranges
unwrap_reference_t	include/range/v3/functional/reference_wrapper.hpp	/^    using unwrap_reference_t = decltype(unwrap_reference(std::declval<T>()));$/;"	t	namespace:ranges
update_	include/range/v3/view/cache1.hpp	/^        auto update_(range_reference_t<Rng> && val) -> CPP_ret(void)($/;"	f	struct:ranges::cache1_view	typeref:typename:CPP_ret (void)(requires (!assignable_from<range_value_t<Rng> &,range_reference_t<Rng>>))
update_	include/range/v3/view/cache1.hpp	/^        auto update_(range_reference_t<Rng> && val) -> CPP_ret(void)($/;"	f	struct:ranges::cache1_view	typeref:typename:CPP_ret (void)(requires assignable_from<range_value_t<Rng> &,range_reference_t<Rng>>)
update_inner_	include/range/v3/view/join.hpp	/^            constexpr views::all_t<Inner> & update_inner_(Inner && inner)$/;"	f	struct:ranges::detail::store_inner_	typeref:typename:views::all_t<Inner> &
update_inner_	include/range/v3/view/join.hpp	/^            static constexpr Inner & update_inner_(Inner && inner) noexcept$/;"	f	struct:ranges::detail::pass_thru_inner_	typeref:typename:Inner &
upper_bound_n_fn	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^        struct upper_bound_n_fn$/;"	s	namespace:ranges::aux
upper_bound_predicate	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^        struct upper_bound_predicate$/;"	s	namespace:ranges::detail
urng	include/range/v3/view/sample.hpp	/^                URNG & urng;$/;"	m	struct:ranges::views::sample_fn::lamduh	typeref:typename:URNG &
use_const_always	include/range/v3/view/join.hpp	/^        static constexpr bool use_const_always() noexcept$/;"	f	struct:ranges::join_view	typeref:typename:bool
use_reserve_t	include/range/v3/range/conversion.hpp	/^                using use_reserve_t =$/;"	t	function:ranges::detail::to_container::fn::operator ()
use_sentinel_t	include/range/v3/view/exclusive_scan.hpp	/^        using use_sentinel_t = meta::bool_<!common_range<Rng> || single_pass{}>;$/;"	t	struct:ranges::exclusive_scan_view	typeref:typename:meta::bool_<!common_range<Rng>||single_pass{}>
use_sentinel_t	include/range/v3/view/transform.hpp	/^        using use_sentinel_t =$/;"	t	struct:ranges::iter_transform_view
v3	include/range/v3/range_fwd.hpp	/^    inline namespace v3$/;"	n	namespace:ranges
val_	include/range/v3/action/push_back.hpp	/^                T (&val_)[N];$/;"	m	struct:ranges::adl_push_back_detail::push_back_fn::lamduh	typeref:typename:T (&)[]
val_	include/range/v3/action/push_front.hpp	/^                T (&val_)[N];$/;"	m	struct:ranges::adl_push_front_detail::push_front_fn::lamduh	typeref:typename:T (&)[]
val_	include/range/v3/action/split.hpp	/^                T (&val_)[N];$/;"	m	struct:ranges::actions::split_fn::lamduh	typeref:typename:T (&)[]
val_	include/range/v3/algorithm/aux_/lower_bound_n.hpp	/^            Val & val_;$/;"	m	struct:ranges::detail::lower_bound_predicate	typeref:typename:Val &
val_	include/range/v3/algorithm/aux_/upper_bound_n.hpp	/^            Val * val_;$/;"	m	struct:ranges::detail::upper_bound_predicate	typeref:typename:Val *
val_	include/range/v3/iterator/diffmax_t.hpp	/^            std::uintmax_t val_;$/;"	m	struct:ranges::detail::diffmax_t	typeref:typename:std::uintmax_t
val_	include/range/v3/view/generate.hpp	/^        detail::non_propagating_cache<result_t> val_;$/;"	m	struct:ranges::generate_view	typeref:typename:detail::non_propagating_cache<result_t>
val_	include/range/v3/view/generate_n.hpp	/^        detail::non_propagating_cache<result_t> val_;$/;"	m	struct:ranges::generate_n_view	typeref:typename:detail::non_propagating_cache<result_t>
val_	include/range/v3/view/intersperse.hpp	/^            range_value_t<Rng> val_;$/;"	m	struct:ranges::intersperse_view::cursor_adaptor	typeref:typename:range_value_t<Rng>
val_	include/range/v3/view/intersperse.hpp	/^        range_value_t<Rng> val_;$/;"	m	struct:ranges::intersperse_view	typeref:typename:range_value_t<Rng>
val_	include/range/v3/view/join.hpp	/^                T (&val_)[N];$/;"	m	struct:ranges::views::join_fn::lamduh	typeref:typename:T (&)[]
val_	include/range/v3/view/join.hpp	/^        views::all_t<ValRng> val_{};$/;"	m	struct:ranges::join_with_view	typeref:typename:views::all_t<ValRng>
valid	include/range/v3/detail/variant.hpp	/^        constexpr bool valid() const noexcept$/;"	f	struct:ranges::variant	typeref:typename:bool
value	include/concepts/swap.hpp	/^            static constexpr T const value {};$/;"	m	struct:concepts::detail::static_const	typeref:typename:T const
value	include/concepts/swap.hpp	/^        constexpr T const static_const<T>::value;$/;"	m	class:concepts::detail::static_const<T>	typeref:typename:T const
value	include/newtype.hpp	/^  T value;$/;"	m	struct:abo::nt::newtype	typeref:typename:T
value	include/nt.hpp	/^    typename std::enable_if<!std::is_reference<T>::value, void>::type;$/;"	t	namespace:nt	typeref:typename:std::enable_if<!std::is_reference<T>::
value	include/range/v3/utility/box.hpp	/^        Element value;$/;"	m	class:ranges::box	typeref:typename:Element
value	include/range/v3/utility/box.hpp	/^        mutable T value;$/;"	m	struct:ranges::mutable_	typeref:typename:T
value	include/range/v3/utility/box.hpp	/^        static Element value;$/;"	m	class:ranges::box	typeref:typename:Element
value	include/range/v3/utility/optional.hpp	/^        constexpr T & value() &$/;"	f	struct:ranges::optional	typeref:typename:T &
value	include/range/v3/utility/optional.hpp	/^        constexpr T && value() &&$/;"	f	struct:ranges::optional	typeref:typename:T &&
value	include/range/v3/utility/optional.hpp	/^        constexpr T const & value() const &$/;"	f	struct:ranges::optional	typeref:typename:T const &
value	include/range/v3/utility/optional.hpp	/^        constexpr T const && value() const &&$/;"	f	struct:ranges::optional	typeref:typename:T const &&
value	include/range/v3/utility/static_const.hpp	/^        static constexpr T value{};$/;"	m	struct:ranges::static_const	typeref:typename:T
value	include/range/v3/utility/static_const.hpp	/^    constexpr T static_const<T>::value;$/;"	m	class:ranges::static_const<T>	typeref:typename:T
value	include/range/v3/view/join.hpp	/^            if_then_t<!std::is_reference<range_reference_t<Rng>>::value,$/;"	t	namespace:ranges::detail	typeref:typename:if_then_t<!std::is_reference<range_reference_t<Rng>>::
value_	include/nt.hpp	/^  T value_;$/;"	m	class:nt::NamedType	typeref:typename:T
value_	include/range/v3/view/const.hpp	/^            using value_ = range_value_t<CRng>;$/;"	t	struct:ranges::const_view::adaptor	typeref:typename:range_value_t<CRng>
value_	include/range/v3/view/delimit.hpp	/^            Val value_;$/;"	m	struct:ranges::delimit_view::sentinel_adaptor	typeref:typename:Val
value_	include/range/v3/view/delimit.hpp	/^        Val value_;$/;"	m	struct:ranges::delimit_view	typeref:typename:Val
value_	include/range/v3/view/remove.hpp	/^                Value value_;$/;"	m	struct:ranges::views::remove_base_fn::pred_	typeref:typename:Value
value_	include/range/v3/view/repeat.hpp	/^            Val const * value_;$/;"	m	struct:ranges::repeat_view::cursor	typeref:typename:Val const *
value_	include/range/v3/view/repeat.hpp	/^        semiregular_box_t<Val> value_;$/;"	m	struct:ranges::repeat_view	typeref:typename:semiregular_box_t<Val>
value_	include/range/v3/view/repeat_n.hpp	/^            Val const * value_;$/;"	m	struct:ranges::repeat_n_view::cursor	typeref:typename:Val const *
value_	include/range/v3/view/repeat_n.hpp	/^        semiregular_box_t<Val> value_;$/;"	m	struct:ranges::repeat_n_view	typeref:typename:semiregular_box_t<Val>
value_	include/range/v3/view/single.hpp	/^        semiregular_box_t<T> value_;$/;"	m	struct:ranges::single_view	typeref:typename:semiregular_box_t<T>
value_t	include/range/v3/iterator/stream_iterators.hpp	/^        using value_t = meta::if_<std::is_void<T>, U, T>;$/;"	t	struct:ranges::ostream_iterator	typeref:typename:meta::if_<std::is_void<T>,U,T>
value_t_	include/range/v3/iterator/basic_iterator.hpp	/^            using value_t_ = private_;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:private_
value_t_	include/range/v3/iterator/basic_iterator.hpp	/^            using value_t_ = range_access::cursor_value_t<Cur>;$/;"	t	struct:ranges::detail::cursor_traits_	typeref:typename:range_access::cursor_value_t<Cur>
value_type	include/meta/meta.hpp	/^        using value_type = T;$/;"	t	struct:meta::integer_sequence	typeref:typename:T
value_type	include/meta/meta_fwd.hpp	/^        typename T::type::value_type;$/;"	m	class:meta::T::type	typeref:typename:typename
value_type	include/meta/meta_fwd.hpp	/^        typename T::value_type;$/;"	m	class:meta::T	typeref:typename:typename
value_type	include/range/v3/action/concepts.hpp	/^            using value_type = T;$/;"	t	struct:ranges::detail::movable_input_iterator	typeref:typename:T
value_type	include/range/v3/algorithm/inplace_merge.hpp	/^            using value_type = iter_value_t<I>;$/;"	t	function:ranges::RANGES_FUNC_BEGIN	typeref:typename:iter_value_t<I>
value_type	include/range/v3/algorithm/rotate.hpp	/^            using value_type = iter_value_t<I>;$/;"	t	function:ranges::detail::rotate_	typeref:typename:iter_value_t<I>
value_type	include/range/v3/algorithm/stable_partition.hpp	/^            using value_type = iter_value_t<I>;$/;"	t	function:ranges::detail::stable_partition_impl	typeref:typename:iter_value_t<I>
value_type	include/range/v3/experimental/utility/generator.hpp	/^                using value_type = Value;$/;"	t	struct:ranges::experimental::generator::cursor	typeref:typename:Value
value_type	include/range/v3/iterator/basic_iterator.hpp	/^            using value_type = range_access::cursor_value_t<Cur>;$/;"	t	struct:ranges::iterator_associated_types_base_	typeref:typename:range_access::cursor_value_t<Cur>
value_type	include/range/v3/iterator/common_iterator.hpp	/^            using value_type = iter_value_t<I>;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:iter_value_t<I>
value_type	include/range/v3/iterator/common_iterator.hpp	/^            using value_type = iter_value_t<I>;$/;"	t	struct:ranges::detail::cpp17_iterator_cursor	typeref:typename:iter_value_t<I>
value_type	include/range/v3/iterator/common_iterator.hpp	/^            using value_type = void;$/;"	t	struct:ranges::detail::common_iterator_std_traits	typeref:typename:void
value_type	include/range/v3/iterator/concepts.hpp	/^            using value_type = uncvref_t<reference>;$/;"	t	struct:ranges::detail::projected_	typeref:typename:uncvref_t<reference>
value_type	include/range/v3/iterator/counted_iterator.hpp	/^            using value_type = void;$/;"	t	struct:ranges::_counted_iterator_::iterator_traits_	typeref:typename:void
value_type	include/range/v3/iterator/move_iterators.hpp	/^            using value_type = iter_value_t<I>;$/;"	t	struct:ranges::detail::move_into_cursor_types_	typeref:typename:iter_value_t<I>
value_type	include/range/v3/iterator/move_iterators.hpp	/^        using value_type = iter_value_t<I>;$/;"	t	struct:ranges::move_iterator	typeref:typename:iter_value_t<I>
value_type	include/range/v3/range/conversion.hpp	/^            using value_type = ValueType;$/;"	t	struct:ranges::detail::to_container_iterator	typeref:typename:ValueType
value_type	include/range/v3/utility/optional.hpp	/^        using value_type = meta::_t<std::remove_cv<T>>;$/;"	t	struct:ranges::optional	typeref:typename:meta::_t<std::remove_cv<T>>
value_type	include/range/v3/view/adaptor.hpp	/^            using value_type = iter_value_t<BaseIter>;$/;"	t	struct:ranges::detail::adaptor_value_type_	typeref:typename:iter_value_t<BaseIter>
value_type	include/range/v3/view/adaptor.hpp	/^            using value_type = typename readable_traits<Adapt>::value_type;$/;"	t	struct:ranges::detail::adaptor_value_type_	typeref:typename:readable_traits<Adapt>::value_type
value_type	include/range/v3/view/cache1.hpp	/^            using value_type = range_value_t<Rng>;$/;"	t	struct:ranges::cache1_view::cursor	typeref:typename:range_value_t<Rng>
value_type	include/range/v3/view/cartesian_product.hpp	/^            using value_type = std::tuple<range_value_t<Views>...>;$/;"	t	struct:ranges::cartesian_product_view::cursor	typeref:typename:std::tuple<range_value_t<Views>...>
value_type	include/range/v3/view/chunk.hpp	/^                using value_type = range_value_t<Rng>;$/;"	t	struct:ranges::chunk_view_::outer_cursor::inner_view	typeref:typename:range_value_t<Rng>
value_type	include/range/v3/view/chunk.hpp	/^            using value_type = inner_view;$/;"	t	struct:ranges::chunk_view_::outer_cursor	typeref:typename:inner_view
value_type	include/range/v3/view/join.hpp	/^            using value_type = common_type_t<range_value_t<Inner>, range_value_t<ValRng>>;$/;"	t	class:ranges::join_with_view::cursor	typeref:typename:common_type_t<range_value_t<Inner>,range_value_t<ValRng>>
value_type	include/range/v3/view/move.hpp	/^            using value_type = range_value_t<Rng>;$/;"	t	struct:ranges::move_view::adaptor	typeref:typename:range_value_t<Rng>
value_type	include/range/v3/view/sample.hpp	/^            using value_type = range_value_t<Rng>;$/;"	t	class:ranges::sample_view::cursor	typeref:typename:range_value_t<Rng>
value_type	include/range/v3/view/set_algorithm.hpp	/^            using value_type = common_type_t<range_value_t<R1>, range_value_t<R2>>;$/;"	t	struct:ranges::detail::set_symmetric_difference_cursor	typeref:typename:common_type_t<range_value_t<R1>,range_value_t<R2>>
value_type	include/range/v3/view/set_algorithm.hpp	/^            using value_type = common_type_t<range_value_t<R1>, range_value_t<R2>>;$/;"	t	struct:ranges::detail::set_union_cursor	typeref:typename:common_type_t<range_value_t<R1>,range_value_t<R2>>
value_type	include/range/v3/view/set_algorithm.hpp	/^            using value_type = range_value_t<R1>;$/;"	t	struct:ranges::detail::set_intersection_cursor	typeref:typename:range_value_t<R1>
value_type	include/range/v3/view/set_algorithm.hpp	/^            using value_type = range_value_t<constify_if<Rng1>>;$/;"	t	struct:ranges::detail::set_difference_cursor	typeref:typename:range_value_t<constify_if<Rng1>>
value_type	include/range/v3/view/span.hpp	/^        using value_type = meta::_t<std::remove_cv<T>>;$/;"	t	struct:ranges::span	typeref:typename:meta::_t<std::remove_cv<T>>
value_type	include/range/v3/view/split.hpp	/^                constexpr explicit value_type(split_outer_iterator i)$/;"	f	struct:ranges::detail::split_outer_iterator::value_type
value_type	include/range/v3/view/split.hpp	/^            struct value_type : view_interface<value_type>$/;"	s	struct:ranges::detail::split_outer_iterator
value_type	include/range/v3/view/split.hpp	/^            using value_type = range_value_t<Base>;$/;"	t	struct:ranges::detail::split_inner_iterator	typeref:typename:range_value_t<Base>
value_type	include/range/v3/view/transform.hpp	/^            using value_type =$/;"	t	struct:ranges::iter_transform2_view::cursor	typeref:typename:detail::decay_t<invoke_result_t<meta::const_if_c<Const,Fun> &,copy_tag,iterator_t<R1>,iterator_t<R2>>>
value_type	include/range/v3/view/transform.hpp	/^            using value_type =$/;"	t	struct:ranges::iter_transform_view::adaptor	typeref:typename:detail::decay_t<invoke_result_t<Fun &,copy_tag,iterator_t<CRng>>>
value_type	include/range/v3/view/zip_with.hpp	/^            using value_type = detail::decay_t<invoke_result_t<$/;"	t	struct:ranges::iter_zip_with_view::cursor	typeref:typename:detail::decay_t<invoke_result_t<fun_ref_ &,copy_tag,iterator_t<meta::const_if_c<Const,Rngs>>...>>
value_type	include/std/detail/associated_types.hpp	/^            using value_type = T;$/;"	t	struct:ranges::detail::with_value_type_	typeref:typename:T
value_type	test/p.cpp	/^  using value_type = std::tuple<std::string, abo::TreeSha>;$/;"	t	struct:aiterator	typeref:typename:std::tuple<std::string,abo::TreeSha>	file:
value_type_	include/range/v3/iterator/traits.hpp	/^        struct value_type_ : meta::defer<iter_value_t, T>$/;"	s	namespace:ranges::detail
value_type_t	include/range/v3/iterator/traits.hpp	/^    using value_type_t RANGES_DEPRECATED($/;"	t	namespace:ranges	typeref:typename:iter_value_t<T>
values_fn	include/range/v3/view/map.hpp	/^        struct values_fn$/;"	s	namespace:ranges::views
var_	include/range/v3/detail/variant.hpp	/^            Variant * var_;$/;"	m	struct:ranges::detail::emplace_fn	typeref:typename:Variant *
var_	include/range/v3/detail/variant.hpp	/^            Variant * var_;$/;"	m	struct:ranges::detail::variant_visitor	typeref:typename:Variant *
variant	include/range/v3/detail/variant.hpp	/^        constexpr variant(detail::empty_variant_tag) noexcept$/;"	f	struct:ranges::variant
variant	include/range/v3/detail/variant.hpp	/^        variant(variant && that)$/;"	f	struct:ranges::variant
variant	include/range/v3/detail/variant.hpp	/^        variant(variant const & that)$/;"	f	struct:ranges::variant
variant	include/range/v3/detail/variant.hpp	/^    struct variant$/;"	s	namespace:ranges
variant_base	include/range/v3/detail/variant.hpp	/^        struct variant_base : variant_get<Variant>$/;"	s	namespace:ranges::detail
variant_base	include/range/v3/detail/variant.hpp	/^        struct variant_base<variant<Ts...>, true> : variant_get<variant<Ts...>>$/;"	s	namespace:ranges::detail
variant_core_access	include/range/v3/detail/variant.hpp	/^        struct variant_core_access$/;"	s	namespace:ranges::detail
variant_data	include/range/v3/detail/variant.hpp	/^        using variant_data = meta::_t<variant_data_<meta::transform<$/;"	t	namespace:ranges::detail
variant_data_	include/range/v3/detail/variant.hpp	/^        struct variant_data_$/;"	s	namespace:ranges::detail
variant_data_	include/range/v3/detail/variant.hpp	/^        struct variant_data_<meta::list<T, Ts...>, false>$/;"	s	namespace:ranges::detail
variant_data_	include/range/v3/detail/variant.hpp	/^        struct variant_data_<meta::list<T, Ts...>, true>$/;"	s	namespace:ranges::detail
variant_datum_t	include/range/v3/detail/variant.hpp	/^        using variant_datum_t =$/;"	t	namespace:ranges::detail	typeref:typename:detail::indexed_datum<meta::at_c<meta::list<Ts...>,Index>,meta::size_t<Index>>
variant_deref_	include/range/v3/detail/variant.hpp	/^        constexpr T & variant_deref_(T * t) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:T &
variant_deref_	include/range/v3/detail/variant.hpp	/^        inline void variant_deref_(void const volatile *) noexcept$/;"	f	namespace:ranges::detail	typeref:typename:void
variant_equal_	include/range/v3/detail/variant.hpp	/^        constexpr bool variant_equal_(std::size_t n, Data0 const & self,$/;"	f	namespace:ranges::detail	typeref:typename:bool
variant_equal_	include/range/v3/detail/variant.hpp	/^        constexpr bool variant_equal_(std::size_t, variant_nil, variant_nil)$/;"	f	namespace:ranges::detail	typeref:typename:bool
variant_get	include/range/v3/detail/variant.hpp	/^        struct variant_get$/;"	s	namespace:ranges::detail
variant_move_copy_	include/range/v3/detail/variant.hpp	/^        inline std::size_t variant_move_copy_(std::size_t, variant_nil, variant_nil)$/;"	f	namespace:ranges::detail	typeref:typename:std::size_t
variant_move_copy_	include/range/v3/detail/variant.hpp	/^        std::size_t variant_move_copy_(std::size_t n, Data0 & self, Data1 && that)$/;"	f	namespace:ranges::detail	typeref:typename:std::size_t
variant_nil	include/range/v3/detail/variant.hpp	/^        using variant_nil = indexed_datum<void, meta::npos>;$/;"	t	namespace:ranges::detail	typeref:typename:indexed_datum<void,meta::npos>
variant_unique	include/range/v3/detail/variant.hpp	/^    struct variant_unique$/;"	s	namespace:ranges
variant_unique_t	include/range/v3/detail/variant.hpp	/^    using variant_unique_t = meta::_t<variant_unique<Var>>;$/;"	t	namespace:ranges	typeref:typename:meta::_t<variant_unique<Var>>
variant_visit_	include/range/v3/detail/variant.hpp	/^        constexpr int variant_visit_(std::size_t n, Data & self, Fun fun, Proj proj = {})$/;"	f	namespace:ranges::detail	typeref:typename:int
variant_visit_	include/range/v3/detail/variant.hpp	/^        constexpr int variant_visit_(std::size_t, variant_nil, Fun, Proj = {})$/;"	f	namespace:ranges::detail	typeref:typename:int
variant_visit_results	include/range/v3/detail/variant.hpp	/^        struct variant_visit_results$/;"	s	namespace:ranges::detail
variant_visit_results_t	include/range/v3/detail/variant.hpp	/^        using variant_visit_results_t =$/;"	t	namespace:ranges::detail
variant_visitor	include/range/v3/detail/variant.hpp	/^        struct variant_visitor$/;"	s	namespace:ranges::detail
view	include/range/v3/view/view.hpp	/^        using view RANGES_DEPRECATED($/;"	t	namespace:ranges::views	typeref:typename:old_view_<ViewFn>
view_	include/range/v3/view/any_view.hpp	/^            any_input_view_interface<Ref> * view_ = nullptr;$/;"	m	struct:ranges::detail::any_input_cursor	typeref:typename:any_input_view_interface<Ref> *
view_	include/range/v3/view/cartesian_product.hpp	/^            constify_if<cartesian_product_view> * view_;$/;"	m	struct:ranges::cartesian_product_view::cursor	typeref:typename:constify_if<cartesian_product_view> *
view_	include/range/v3/view/generate.hpp	/^            generate_view * view_;$/;"	m	struct:ranges::generate_view::cursor	typeref:typename:generate_view *
view_access	include/range/v3/view/view.hpp	/^        using view_access RANGES_DEPRECATED($/;"	t	namespace:ranges::views	typeref:typename:view_access_
view_access_	include/range/v3/view/view.hpp	/^        struct view_access_$/;"	s	namespace:ranges::views
view_adaptor	include/range/v3/view/adaptor.hpp	/^        explicit constexpr view_adaptor(BaseRng && rng)$/;"	f	struct:ranges::view_adaptor
view_adaptor	include/range/v3/view/adaptor.hpp	/^    struct view_adaptor : view_facade<Derived, Cardinality>$/;"	s	namespace:ranges
view_as_cursor	include/range/v3/view/facade.hpp	/^            explicit view_as_cursor(Derived const * derived)$/;"	f	struct:ranges::view_facade::view_as_cursor
view_as_cursor	include/range/v3/view/facade.hpp	/^        struct view_as_cursor : Derived$/;"	s	struct:ranges::view_facade
view_closure	include/range/v3/view/view.hpp	/^            constexpr explicit view_closure(ViewFn fn)$/;"	f	struct:ranges::views::view_closure
view_closure	include/range/v3/view/view.hpp	/^        struct RANGES_EMPTY_BASES view_closure$/;"	s	namespace:ranges::views
view_closure_base	include/range/v3/view/view.hpp	/^        struct view_closure_base$/;"	s	namespace:ranges::views
view_closure_base_detail	include/range/v3/view/view.hpp	/^        namespace view_closure_base_detail$/;"	n	namespace:ranges::views
view_detail_	include/range/v3/range/concepts.hpp	/^    namespace view_detail_$/;"	n	namespace:ranges
view_facade	include/range/v3/view/facade.hpp	/^    struct view_facade : view_interface<Derived, Cardinality>$/;"	s	namespace:ranges
view_interface	include/range/v3/view/interface.hpp	/^            using view_interface = ranges::view_interface<Derived, ranges::unknown>;$/;"	t	namespace:ranges::cpp20	typeref:typename:ranges::view_interface<Derived,ranges::unknown>
view_interface	include/range/v3/view/interface.hpp	/^    struct view_interface : basic_view<Cardinality>$/;"	s	namespace:ranges
views	include/range/v3/experimental/view/shared.hpp	/^        namespace views$/;"	n	namespace:ranges::experimental
views	include/range/v3/range_fwd.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/addressof.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/adjacent_filter.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/adjacent_remove_if.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/all.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/all.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/c_str.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/cache1.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/cartesian_product.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/chunk.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/common.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/common.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/concat.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/const.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/counted.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/counted.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/cycle.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/delimit.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/drop.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/drop.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/drop_exactly.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/drop_last.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/drop_while.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/drop_while.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/empty.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/empty.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/enumerate.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/exclusive_scan.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/filter.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/filter.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/for_each.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/generate.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/generate_n.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/group_by.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/indices.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/indirect.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/intersperse.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/iota.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/iota.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/join.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/join.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/linear_distribute.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/map.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/map.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/move.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/partial_sum.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/ref.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/remove.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/remove_if.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/repeat.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/repeat_n.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/replace.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/replace_if.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/reverse.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/reverse.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/sample.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/set_algorithm.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/single.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/single.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/slice.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/sliding.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/split.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/split.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/split_when.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/stride.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/tail.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/take.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/take.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/take_exactly.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/take_last.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/take_while.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/take_while.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/tokenize.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/transform.hpp	/^        namespace views$/;"	n	namespace:ranges::cpp20
views	include/range/v3/view/transform.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/trim.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/unbounded.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/unique.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/view.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/zip.hpp	/^    namespace views$/;"	n	namespace:ranges
views	include/range/v3/view/zip_with.hpp	/^    namespace views$/;"	n	namespace:ranges
views_	include/range/v3/view/cartesian_product.hpp	/^        std::tuple<Views...> views_;$/;"	m	struct:ranges::cartesian_product_view	typeref:typename:std::tuple<Views...>
visit	include/range/v3/detail/variant.hpp	/^        detail::variant_visit_results_t<composed<Fun, unbox_fn>, Ts...> visit(Fun fun)$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_visit_results_t<composed<Fun,unbox_fn>,Ts...>
visit	include/range/v3/detail/variant.hpp	/^        visit(Fun fun) const$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_visit_results_t<composed<Fun,unbox_fn>,add_const_t<Ts>...>
visit_i	include/range/v3/detail/variant.hpp	/^        detail::variant_visit_results_t<Fun, Ts...> visit_i(Fun fun)$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_visit_results_t<Fun,Ts...>
visit_i	include/range/v3/detail/variant.hpp	/^        detail::variant_visit_results_t<Fun, add_const_t<Ts>...> visit_i(Fun fun) const$/;"	f	struct:ranges::variant	typeref:typename:detail::variant_visit_results_t<Fun,add_const_t<Ts>...>
void_	include/meta/meta.hpp	/^    using void_ = invoke<id<void>, Ts...>;$/;"	t	namespace:meta	typeref:typename:invoke<id<void>,Ts...>
void_	include/meta/meta.hpp	/^    using void_ = void;$/;"	t	namespace:meta	typeref:typename:void
vw_	include/range/v3/view/view.hpp	/^            ViewFn vw_;$/;"	m	struct:ranges::views::old_view_	typeref:typename:ViewFn
what	include/range/v3/utility/any.hpp	/^        virtual const char * what() const noexcept override$/;"	f	struct:ranges::bad_any_cast	typeref:typename:const char *
what	include/range/v3/utility/optional.hpp	/^        virtual const char * what() const noexcept override$/;"	f	struct:ranges::bad_optional_access	typeref:typename:const char *
where_	include/range/v3/iterator/insert_iterators.hpp	/^        typename Container::iterator where_ = typename Container::iterator();$/;"	m	struct:ranges::insert_iterator	typeref:typename:Container::iterator
which_adaptor_value_	include/range/v3/view/adaptor.hpp	/^        constexpr auto which_adaptor_value_(priority_tag<1>)$/;"	f	namespace:ranges::detail	typeref:typename:always_<int,decltype (Adapt::read (std::declval<BaseIter const &> (),adaptor_base_current_mem_fn{}))>
which_adaptor_value_	include/range/v3/view/adaptor.hpp	/^        constexpr auto which_adaptor_value_(priority_tag<2>)$/;"	f	namespace:ranges::detail	typeref:typename:always_<int,typename Adapt::value_type>
which_adaptor_value_	include/range/v3/view/adaptor.hpp	/^        constexpr int which_adaptor_value_(priority_tag<0>)$/;"	f	namespace:ranges::detail	typeref:typename:int
with_braced_init_args	include/range/v3/detail/with_braced_init_args.hpp	/^        struct with_braced_init_args : ImplFn$/;"	s	namespace:ranges::detail
with_difference_type_	include/std/detail/associated_types.hpp	/^        struct with_difference_type_$/;"	s	namespace:ranges::detail
with_iterator_category	include/range/v3/iterator/basic_iterator.hpp	/^        struct with_iterator_category : Base$/;"	s	namespace:ranges::detail
with_iterator_category	include/range/v3/iterator/basic_iterator.hpp	/^        struct with_iterator_category<Category>$/;"	s	namespace:ranges::detail
with_value_type_	include/std/detail/associated_types.hpp	/^        struct with_value_type_$/;"	s	namespace:ranges::detail
with_value_type_	include/std/detail/associated_types.hpp	/^        struct with_value_type_<T const volatile, true>$/;"	s	namespace:ranges::detail
with_value_type_	include/std/detail/associated_types.hpp	/^        struct with_value_type_<T const, true>$/;"	s	namespace:ranges::detail
with_value_type_	include/std/detail/associated_types.hpp	/^        struct with_value_type_<T volatile, true>$/;"	s	namespace:ranges::detail
with_value_type_	include/std/detail/associated_types.hpp	/^        struct with_value_type_<T, true>$/;"	s	namespace:ranges::detail
write	include/range/v3/iterator/move_iterators.hpp	/^            auto write(T && t) const noexcept(noexcept(*it_ = std::move(t)))$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:auto
write	include/range/v3/iterator/move_iterators.hpp	/^            auto write(T && t) noexcept(noexcept(*it_ = std::move(t)))$/;"	f	struct:ranges::detail::move_into_cursor	typeref:typename:auto
write_	include/range/v3/iterator/basic_iterator.hpp	/^            constexpr void write_(T && t) const$/;"	f	struct:ranges::detail::basic_proxy_reference_	typeref:typename:void
xNil	include/concepts/concepts.hpp	/^        enum class xNil {};$/;"	g	namespace:concepts::detail
xNil	include/concepts/concepts.hpp	/^        using xNil = Nil;$/;"	t	namespace:concepts::detail	typeref:typename:Nil
yield_fn	include/range/v3/view/for_each.hpp	/^    struct yield_fn$/;"	s	namespace:ranges
yield_from_fn	include/range/v3/view/for_each.hpp	/^    struct yield_from_fn$/;"	s	namespace:ranges
yield_if_fn	include/range/v3/view/for_each.hpp	/^    struct yield_if_fn$/;"	s	namespace:ranges
yield_value	include/range/v3/experimental/utility/generator.hpp	/^            auto yield_value(Arg && arg) noexcept($/;"	f	struct:ranges::detail::generator_promise	typeref:typename:auto
zero	include/range/v3/view/chunk.hpp	/^            constexpr explicit zero(T const &) noexcept$/;"	f	struct:ranges::detail::zero
zero	include/range/v3/view/chunk.hpp	/^        struct zero$/;"	s	namespace:ranges::detail
zero_	include/range/v3/view/split_when.hpp	/^                bool zero_;$/;"	m	struct:ranges::split_when_view::cursor::search_pred	typeref:typename:bool
zero_	include/range/v3/view/split_when.hpp	/^            bool zero_;$/;"	m	struct:ranges::split_when_view::cursor	typeref:typename:bool
zip_cardinality	include/range/v3/view/zip_with.hpp	/^        using zip_cardinality = std::integral_constant<$/;"	t	namespace:ranges::detail
zip_fn	include/range/v3/view/zip.hpp	/^        struct zip_fn$/;"	s	namespace:ranges::views
zip_view	include/range/v3/view/zip.hpp	/^        explicit zip_view(Rngs... rngs)$/;"	f	struct:ranges::zip_view
zip_view	include/range/v3/view/zip.hpp	/^    struct zip_view : iter_zip_with_view<detail::indirect_zip_fn_, Rngs...>$/;"	s	namespace:ranges
zip_with_fn	include/range/v3/view/zip_with.hpp	/^        struct zip_with_fn$/;"	s	namespace:ranges::views
zip_with_view	include/range/v3/view/zip_with.hpp	/^        explicit zip_with_view(Fun fun, Rngs... rngs)$/;"	f	struct:ranges::zip_with_view
zip_with_view	include/range/v3/view/zip_with.hpp	/^        explicit zip_with_view(Rngs... rngs)$/;"	f	struct:ranges::zip_with_view
zip_with_view	include/range/v3/view/zip_with.hpp	/^    struct zip_with_view : iter_zip_with_view<indirected<Fun>, Rngs...>$/;"	s	namespace:ranges
~S	test/p.cpp	/^  ~S() noexcept { puts("~S()"); }$/;"	f	struct:S	file:
~coroutine_owner	include/range/v3/experimental/utility/generator.hpp	/^            ~coroutine_owner()$/;"	f	struct:ranges::experimental::coroutine_owner
~interface	include/range/v3/utility/any.hpp	/^            virtual ~interface()$/;"	f	struct:ranges::any::interface
~optional_storage	include/range/v3/utility/optional.hpp	/^                ~optional_storage()$/;"	f	struct:ranges::detail::optional_adl::optional_storage
~raw_buffer	include/range/v3/utility/memory.hpp	/^        ~raw_buffer()$/;"	f	struct:ranges::raw_buffer
~scope_exit	include/range/v3/utility/scope_exit.hpp	/^        ~scope_exit()$/;"	f	struct:ranges::scope_exit
~semiregular_box	include/range/v3/utility/semiregular_box.hpp	/^        ~semiregular_box()$/;"	f	struct:ranges::semiregular_box
~type	include/range/v3/detail/variant.hpp	/^                ~type()$/;"	f	struct:ranges::detail::variant_data_::type
~variant_base	include/range/v3/detail/variant.hpp	/^            ~variant_base()$/;"	f	struct:ranges::detail::variant_base
