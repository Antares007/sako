!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
ABO_NEWTYPE_HPP	newtype.hpp	/^#define ABO_NEWTYPE_HPP$/;"	d
ABO_UNION_HPP	union.hpp	/^#define ABO_UNION_HPP$/;"	d
AB_GIT_H	git_.hpp	/^#define AB_GIT_H$/;"	d
Addable	newtype.hpp	/^template <typename T> struct Addable : crtp<T, Addable> {$/;"	s	namespace:abo::nt
Addable	ntskills.hpp	/^template <typename T> struct Addable : crtp<T, Addable> {$/;"	s	namespace:nt
BUILD_SHARED_LIBS	CMakeLists.txt	/^set(BUILD_SHARED_LIBS OFF CACHE BOOL "" FORCE)$/;"	v
Bark	git_.hpp	/^template <typename Pith> struct Bark {$/;"	s	namespace:abo
BlobId	git.hpp	/^using BlobId = nt::NamedType<std::string, struct BlobIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct BlobIdTag>
C	git.hpp	/^  using C = int (*)(T **, Args...);$/;"	t	struct:git::make
C	git.hpp	/^  using C = int (*)(T *, Args...);$/;"	t	struct:git::make2
CommitId	git.hpp	/^using CommitId = nt::NamedType<std::string, struct CommIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct CommIdTag>
Comparable	ntskills.hpp	/^template <typename T> struct Comparable : crtp<T, Comparable> {$/;"	s	namespace:nt
D	git.hpp	/^  using D = void (*)(T *);$/;"	t	struct:git::make
Entry	git.hpp	/^using Entry =$/;"	t	namespace:git	typeref:typename:std::tuple<Name,std::variant<TreeId,BlobId,ExecId,LinkId,CommitId>>
ExecId	git.hpp	/^using ExecId = nt::NamedType<std::string, struct ExecIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct ExecIdTag>
FLUENT_EBCO	nt.hpp	/^#define FLUENT_EBCO /;"	d
FLUENT_EBCO	nt.hpp	/^#define FLUENT_EBCO$/;"	d
GIT_H	git.hpp	/^#define GIT_H /;"	d
Hashable	ntskills.hpp	/^template <typename T> struct Hashable {$/;"	s	namespace:nt
ImplicitlyConvertibleTo	ntskills.hpp	/^template <typename Destination> struct ImplicitlyConvertibleTo {$/;"	s	namespace:nt
Incrementable	ntskills.hpp	/^template <typename T> struct Incrementable : crtp<T, Incrementable> {$/;"	s	namespace:nt
IsNotReference	nt.hpp	/^using IsNotReference =$/;"	t	namespace:nt	typeref:typename:std::enable_if<!std::is_reference<T> void>::type
L	lr.hpp	/^struct L {$/;"	s	namespace:lr
LR	git.hpp	/^template <typename R> using LR = lr::LR<R>;$/;"	t	namespace:git	typeref:typename:lr::LR<R>
LR	lr.hpp	/^template <typename... Rights> using LR = std::variant<L, Rights...>;$/;"	t	namespace:lr	typeref:typename:std::variant<L,Rights...>
LR_H	lr.hpp	/^#define LR_H /;"	d
LinkId	git.hpp	/^using LinkId = nt::NamedType<std::string, struct LinkIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct LinkIdTag>
Multiplicable	ntskills.hpp	/^template <typename T> struct Multiplicable : crtp<T, Multiplicable> {$/;"	s	namespace:nt
Name	git.hpp	/^using Name = nt::NamedType<std::string, struct NameTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct NameTag>
NamedType	nt.hpp	/^  explicit constexpr NamedType(T &&value) : value_(std::move(value)) {}$/;"	f	class:nt::NamedType
NamedType	nt.hpp	/^  explicit constexpr NamedType(T const &value) : value_(value) {}$/;"	f	class:nt::NamedType
NamedType	nt.hpp	/^class FLUENT_EBCO NamedType$/;"	c	namespace:nt
Negatable	ntskills.hpp	/^template <typename T> struct Negatable : crtp<T, Negatable> {$/;"	s	namespace:nt
NewType	newtype.hpp	/^#define NewType(/;"	d
O	git.hpp	/^  struct O {$/;"	s	struct:git::TreeBark
O	git_.hpp	/^struct O {};$/;"	s	namespace:abo
OVERLOADED_H	overloaded.hpp	/^#define OVERLOADED_H /;"	d
PreIncrementable	ntskills.hpp	/^template <typename T> struct PreIncrementable : crtp<T, PreIncrementable> {$/;"	s	namespace:nt
Printable	ntskills.hpp	/^template <typename T> struct Printable : crtp<T, Printable> {$/;"	s	namespace:nt
Ref	git.hpp	/^using Ref = nt::NamedType<int, struct RefTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<int,struct RefTag>
S	p.cpp	/^  S() noexcept { puts("S()"); }$/;"	f	struct:S	file:
S	p.cpp	/^  S(S &&) noexcept { puts("S(S &&)"); }$/;"	f	struct:S	file:
S	p.cpp	/^  S(S const &) noexcept { puts("S(const S &)"); }$/;"	f	struct:S	file:
S	p.cpp	/^struct S {$/;"	s	file:
STATIC	CMakeLists.txt	/^set(STATIC ON CACHE BOOL "" FORCE)$/;"	v
Subtractable	ntskills.hpp	/^template <typename T> struct Subtractable : crtp<T, Subtractable> {$/;"	s	namespace:nt
TagId	git.hpp	/^using TagId = nt::NamedType<std::string, struct TagIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct TagIdTag>
TreeBark	git.hpp	/^  TreeBark(const UPtr<git_repository> &rhs) : repo(rhs) {}$/;"	f	struct:git::TreeBark
TreeBark	git.hpp	/^struct TreeBark {$/;"	s	namespace:git
TreeId	git.hpp	/^using TreeId = nt::NamedType<std::string, struct TreeIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct TreeIdTag>
UNDERLYING_FUNCTIONALITIES_HPP	ntskills.hpp	/^#define UNDERLYING_FUNCTIONALITIES_HPP$/;"	d
UPtr	git.hpp	/^template <typename T> using UPtr = std::unique_ptr<T, void (*)(T *)>;$/;"	t	namespace:git
UPtr	oset.cpp	/^template <typename T> using UPtr = std::unique_ptr<T, void (*)(T *)>;$/;"	t	file:
UnderlyingType	nt.hpp	/^  using UnderlyingType = T;$/;"	t	class:nt::NamedType	typeref:typename:T
__anon0bf614d90102	lr.hpp	/^          overloaded{[](L &&l) { return R(std::forward<L>(l)); },$/;"	f	struct:lr::fmap	file:
__anon0bf614d90202	lr.hpp	/^                     [&](auto &&a) { return f(std::forward<decltype(a)>(a)); }},$/;"	f	struct:lr::fmap	file:
__anon0bf614d90302	lr.hpp	/^              [](L &&l) { return LR<R>(std::forward<L>(l)); },$/;"	f	struct:lr::fmap	file:
__anon0bf614d90402	lr.hpp	/^              [&](auto &&a) { return LR<R>(f(std::forward<decltype(a)>(a))); }},$/;"	f	struct:lr::fmap	file:
__anon3b5b11db0102	main.cpp	/^            lr::fmap([](const git::UPtr<git_repository> &repo) {$/;"	f	function:main	file:
__anon3b5b11db0202	main.cpp	/^              return bark([&repo](const TreeBark::O &) {$/;"	f	function:main::__anon3b5b11db0102	file:
__anon3b5b11db0302	main.cpp	/^                       lr::fmap([&](const auto &id) {$/;"	f	function:main::__anon3b5b11db0102::__anon3b5b11db0202	file:
__anon3b5b11db0402	main.cpp	/^                       lr::fmap([](const auto &pTree) {$/;"	f	function:main::__anon3b5b11db0102::__anon3b5b11db0202	file:
__anon3b5b11db0502	main.cpp	/^            | lr::fmap([](auto &&a) { return a; });$/;"	f	function:main	file:
__anon3b5b11db0602	main.cpp	/^                 [](lr::L &&l) { std::cout << "L: " << l.message; },$/;"	f	function:main	file:
__anon3b5b11db0702	main.cpp	/^                 [](git_oid &&l) { std::cout << "R: " << git_oid_tostr_s(&l); },$/;"	f	function:main	file:
__anon50b6bbe40102	union.hpp	/^    return pith([&o](auto &&... x) {$/;"	f	struct:abo::union_fn	file:
__anon748ef1b10102	oset.cpp	/^  return union_fn{[c, d, &args...](auto o) {$/;"	f	function:makeuptr	file:
__anon748ef1b10202	oset.cpp	/^  union_fn{[](auto o) {$/;"	f	function:main	file:
__anon748ef1b10302	oset.cpp	/^        [&](int err, const char *p) { o(err, p); },$/;"	f	function:main::__anon748ef1b10202	file:
__anon748ef1b10402	oset.cpp	/^        [&](UPtr<git_repository> &&repo) {$/;"	f	function:main::__anon748ef1b10202	file:
__anon748ef1b10502	oset.cpp	/^  }}([](float) {}, [](int, const char *) {}, [](int) {}, [](const char *) {});$/;"	f	function:main	file:
__anon748ef1b10602	oset.cpp	/^  }}([](float) {}, [](int, const char *) {}, [](int) {}, [](const char *) {});$/;"	f	function:main	file:
__anon748ef1b10702	oset.cpp	/^  }}([](float) {}, [](int, const char *) {}, [](int) {}, [](const char *) {});$/;"	f	function:main	file:
__anon748ef1b10802	oset.cpp	/^  }}([](float) {}, [](int, const char *) {}, [](int) {}, [](const char *) {});$/;"	f	function:main	file:
__anonf9a9c0fa0102	git.cpp	/^  auto f = lr::fmap{[](git_oid &&) { return 1; }};$/;"	f	function:git::commit	file:
__anonf9a9d63f0102	git.hpp	/^             | lr::fmap([](auto) { return LR<git_oid>(lr::L{"9"}); });$/;"	f	function:git::TreeBark::operator ()	file:
abo	git_.hpp	/^namespace abo {$/;"	n
abo	newtype.hpp	/^namespace abo::nt {$/;"	n
abo	union.hpp	/^namespace abo {$/;"	n
aiterator	p.cpp	/^struct aiterator {$/;"	s	file:
argument	nt.hpp	/^  struct argument {$/;"	s	class:nt::NamedType
begin	p.cpp	/^  aiterator begin() { return aiterator{}; }$/;"	f	struct:tree_iterator	typeref:typename:aiterator	file:
c	git.hpp	/^  C c;$/;"	m	struct:git::make	typeref:typename:C
c	git.hpp	/^  C c;$/;"	m	struct:git::make2	typeref:typename:C
commit	git.cpp	/^lr::LR<git_oid> commit(const char *, lr::LR<git_oid> &&tree,$/;"	f	namespace:git	typeref:typename:lr::LR<git_oid>
create	lr.hpp	/^template <typename T> inline constexpr std::variant<L, T> create(T &&t) {$/;"	f	namespace:lr	typeref:typename:std::variant<L,T>
crtp	newtype.hpp	/^template <typename T, template <typename> class crtpType> struct crtp {$/;"	s	namespace:abo::nt
crtp	ntskills.hpp	/^template <typename T, template <typename> class crtpType> struct crtp {$/;"	s	namespace:nt
d	git.hpp	/^  D d;$/;"	m	struct:git::make	typeref:typename:D
difference_type	p.cpp	/^  using difference_type = int;$/;"	t	struct:aiterator	typeref:typename:int	file:
end	p.cpp	/^  aiterator end() { return aiterator{}; }$/;"	f	struct:tree_iterator	typeref:typename:aiterator	file:
f	lr.hpp	/^  F f;$/;"	m	struct:lr::fmap	typeref:typename:F
fmap	lr.hpp	/^  fmap(F &&r) : f(std::forward<F>(r)) {}$/;"	f	struct:lr::fmap
fmap	lr.hpp	/^template <typename F> struct fmap {$/;"	s	namespace:lr
get	newtype.hpp	/^  constexpr T const &get() const { return value; }$/;"	f	struct:abo::nt::newtype	typeref:typename:T const &
get	nt.hpp	/^  constexpr T &get() { return value_; }$/;"	f	class:nt::NamedType	typeref:typename:T &
get	nt.hpp	/^  constexpr std::remove_reference_t<T> const &get() const { return value_; }$/;"	f	class:nt::NamedType	typeref:typename:std::remove_reference_t<T> const &
git	git.cpp	/^namespace git {$/;"	n	file:
git	git.hpp	/^namespace git {$/;"	n
is_hashable	ntskills.hpp	/^  static constexpr bool is_hashable = true;$/;"	m	struct:nt::Hashable	typeref:typename:bool
islr	lr.hpp	/^template <typename T> struct islr : std::false_type {};$/;"	s	namespace:lr
islr_t	lr.hpp	/^template <typename T> using islr_t = typename islr<T>::type;$/;"	t	namespace:lr	typeref:typename:islr<T>::type
islr_v	lr.hpp	/^template <typename T> inline constexpr bool islr_v = islr<T>::value;$/;"	v	namespace:lr	typeref:typename:bool
iterator_category	p.cpp	/^  using iterator_category = std::input_iterator_tag;$/;"	t	struct:aiterator	typeref:typename:std::input_iterator_tag	file:
lookupTree	main.cpp	/^static auto lookupTree = make(git_tree_lookup, git_tree_free);$/;"	v	typeref:typename:auto	file:
lr	lr.hpp	/^namespace lr {$/;"	n
main	CMakeLists.txt	/^add_executable(main$/;"	t
main	CMakeLists.txt	/^project(main VERSION 0.1.0)$/;"	p
main	main.cpp	/^int main() {$/;"	f	typeref:typename:int
main	oset.cpp	/^int main() {$/;"	f	typeref:typename:int
main	p.cpp	/^int main() {$/;"	f	typeref:typename:int
make	git.hpp	/^  make(C _c, D _d) : c(_c), d(_d) {}$/;"	f	struct:git::make
make	git.hpp	/^template <typename T, typename... Args> struct make {$/;"	s	namespace:git
make2	git.hpp	/^  make2(C _c) : c(_c) {}$/;"	f	struct:git::make2
make2	git.hpp	/^template <typename T, typename... Args> struct make2 {$/;"	s	namespace:git
make_named	nt.hpp	/^constexpr StrongType<T> make_named(T const &value) {$/;"	f	namespace:nt	typeref:typename:StrongType<T>
makeuptr	oset.cpp	/^constexpr auto makeuptr(int (*c)(T **, Args...), void (*d)(T *),$/;"	f	typeref:typename:auto
message	lr.hpp	/^  std::string message;$/;"	m	struct:lr::L	typeref:typename:std::string
named_type_impl_h	nt.hpp	/^#define named_type_impl_h$/;"	d
newtype	newtype.hpp	/^  constexpr newtype(U &&u) : value(std::forward<U>(u)) {}$/;"	f	struct:abo::nt::newtype
newtype	newtype.hpp	/^struct newtype : Skills<newtype<Tag, T, Skills...>>... {$/;"	s	namespace:abo::nt
nt	newtype.hpp	/^namespace abo::nt {$/;"	n	namespace:abo
nt	nt.hpp	/^namespace nt {$/;"	n
nt	ntskills.hpp	/^namespace nt {$/;"	n
oidFromStr	main.cpp	/^static auto oidFromStr = make2(git_oid_fromstr);$/;"	v	typeref:typename:auto	file:
openRepository	main.cpp	/^static auto openRepository = make(git_repository_open, git_repository_free);$/;"	v	typeref:typename:auto	file:
operator !=	ntskills.hpp	/^  bool operator!=(T const &other) const { return !(*this == other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator ()	git.hpp	/^  lr::LR<T> operator()(Args &&... args) const {$/;"	f	struct:git::make2	typeref:typename:lr::LR<T>
operator ()	git.hpp	/^  lr::LR<UPtr<T>> operator()(Args &&... args) const {$/;"	f	struct:git::make	typeref:typename:lr::LR<UPtr<T>>
operator ()	git.hpp	/^  template <typename Pith> LR<git_oid> operator()(Pith &&pith) const {$/;"	f	struct:git::TreeBark	typeref:typename:LR<git_oid>
operator ()	git_.hpp	/^  LR<TreeSha> operator()(const Repo &) const {$/;"	f	struct:abo::Bark	typeref:typename:LR<TreeSha>
operator *	ntskills.hpp	/^  T operator*(T const &other) const {$/;"	f	struct:nt::Multiplicable	typeref:typename:T
operator +	lr.hpp	/^  L operator+(const L &other) { return L(this->message + other.message); }$/;"	f	struct:lr::L	typeref:typename:L
operator +	newtype.hpp	/^  T operator+(T const &other) const {$/;"	f	struct:abo::nt::Addable	typeref:typename:T
operator +	ntskills.hpp	/^  T operator+(T const &other) const {$/;"	f	struct:nt::Addable	typeref:typename:T
operator ++	ntskills.hpp	/^  T &operator++() {$/;"	f	struct:nt::PreIncrementable	typeref:typename:T &
operator +=	ntskills.hpp	/^  T &operator+=(T const &other) {$/;"	f	struct:nt::Incrementable	typeref:typename:T &
operator -	ntskills.hpp	/^  T operator-() const { return T(-this->underlying().get()); }$/;"	f	struct:nt::Negatable	typeref:typename:T
operator -	ntskills.hpp	/^  T operator-(T const &other) const {$/;"	f	struct:nt::Subtractable	typeref:typename:T
operator ->	ntskills.hpp	/^  T *operator->() { return std::addressof(this->underlying().get()); }$/;"	f	typeref:struct:MethodCallable T *
operator <	ntskills.hpp	/^  bool operator<(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator <<	ntskills.hpp	/^std::ostream &operator<<(std::ostream &os,$/;"	f	namespace:nt	typeref:typename:std::ostream &
operator <=	ntskills.hpp	/^  bool operator<=(T const &other) const { return !(*this > other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator =	nt.hpp	/^    template <typename U> NamedType operator=(U &&value) const {$/;"	f	struct:nt::NamedType::argument	typeref:typename:NamedType
operator =	p.cpp	/^  S &operator=(S &&) noexcept {$/;"	f	struct:S	typeref:typename:S &	file:
operator =	p.cpp	/^  S &operator=(const S &) noexcept {$/;"	f	struct:S	typeref:typename:S &	file:
operator ==	ntskills.hpp	/^  bool operator==(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator >	ntskills.hpp	/^  bool operator>(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator >=	ntskills.hpp	/^  bool operator>=(T const &other) const { return !(*this < other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator Destination	ntskills.hpp	/^    operator Destination() const { return this->underlying().get(); }$/;"	f	struct:nt::ImplicitlyConvertibleTo::templ
operator T&	ntskills.hpp	/^  operator T &() { return this->underlying().get(); }$/;"	f	namespace:nt	typeref:struct:FunctionCallable
operator ref	nt.hpp	/^  operator ref() { return ref(value_); }$/;"	f	class:nt::NamedType
operator |	lr.hpp	/^template <typename A, typename F> decltype(auto) operator|(A &&a, F &&f) {$/;"	f	namespace:lr	typeref:typename:decltype (auto)
overloaded	overloaded.hpp	/^template <class... Ts> struct overloaded : Ts... { using Ts::operator()...; };$/;"	s
pith	git_.hpp	/^  Pith pith;$/;"	m	struct:abo::Bark	typeref:typename:Pith
pith	union.hpp	/^  P pith;$/;"	m	struct:abo::union_fn	typeref:typename:P
pointer	p.cpp	/^  using pointer = value_type *;$/;"	t	struct:aiterator	typeref:typename:value_type *	file:
print	ntskills.hpp	/^  void print(std::ostream &os) const { os << this->underlying().get(); }$/;"	f	struct:nt::Printable	typeref:typename:void
ref	nt.hpp	/^  using ref = NamedType<T &, Parameter, Skills...>;$/;"	t	class:nt::NamedType	typeref:typename:NamedType<T &,Parameter,Skills...>
reference	p.cpp	/^  using reference = value_type &;$/;"	t	struct:aiterator	typeref:typename:value_type &	file:
repo	git.hpp	/^  const UPtr<git_repository> &repo;$/;"	m	struct:git::TreeBark	typeref:typename:const UPtr<git_repository> &
templ	ntskills.hpp	/^  template <typename T> struct templ : crtp<T, templ> {$/;"	s	struct:nt::ImplicitlyConvertibleTo
tree_iterator	p.cpp	/^template <typename T> struct tree_iterator {$/;"	s	file:
underlying	newtype.hpp	/^  T &underlying() { return static_cast<T &>(*this); }$/;"	f	struct:abo::nt::crtp	typeref:typename:T &
underlying	newtype.hpp	/^  T const &underlying() const { return static_cast<T const &>(*this); }$/;"	f	struct:abo::nt::crtp	typeref:typename:T const &
underlying	ntskills.hpp	/^  T &underlying() { return static_cast<T &>(*this); }$/;"	f	struct:nt::crtp	typeref:typename:T &
underlying	ntskills.hpp	/^  T const &underlying() const { return static_cast<T const &>(*this); }$/;"	f	struct:nt::crtp	typeref:typename:T const &
union_fn	union.hpp	/^template <typename P> struct union_fn {$/;"	s	namespace:abo
value	newtype.hpp	/^  T value;$/;"	m	struct:abo::nt::newtype	typeref:typename:T
value	nt.hpp	/^    typename std::enable_if<!std::is_reference<T>::value, void>::type;$/;"	t	namespace:nt	typeref:typename:std::enable_if<!std::is_reference<T>::
value_	nt.hpp	/^  T value_;$/;"	m	class:nt::NamedType	typeref:typename:T
value_type	p.cpp	/^  using value_type = std::tuple<std::string, abo::TreeSha>;$/;"	t	struct:aiterator	typeref:typename:std::tuple<std::string,abo::TreeSha>	file:
~S	p.cpp	/^  ~S() noexcept { puts("~S()"); }$/;"	f	struct:S	file:
