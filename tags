!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
ABO_NEWTYPE_HPP	include/newtype.hpp	/^#define ABO_NEWTYPE_HPP$/;"	d
ABO_UNION_HPP	include/union.hpp	/^#define ABO_UNION_HPP$/;"	d
AB_GIT_H	include/git_.hpp	/^#define AB_GIT_H$/;"	d
Addable	include/newtype.hpp	/^template <typename T> struct Addable : crtp<T, Addable> {$/;"	s	namespace:abo::nt
Addable	include/ntskills.hpp	/^template <typename T> struct Addable : crtp<T, Addable> {$/;"	s	namespace:nt
Bark	include/git_.hpp	/^template <typename Pith> struct Bark {$/;"	s	namespace:abo
BlobId	include/git.hpp	/^using BlobId = nt::NamedType<std::string, struct BlobIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct BlobIdTag>
C	include/git.hpp	/^  using C = int (*)(T **, Args...);$/;"	t	struct:git::make
C	include/git.hpp	/^  using C = int (*)(T *, Args...);$/;"	t	struct:git::make2
CommitId	include/git.hpp	/^using CommitId = nt::NamedType<std::string, struct CommIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct CommIdTag>
Comparable	include/ntskills.hpp	/^template <typename T> struct Comparable : crtp<T, Comparable> {$/;"	s	namespace:nt
D	include/git.hpp	/^  using D = void (*)(T *);$/;"	t	struct:git::make
Entry	include/git.hpp	/^using Entry =$/;"	t	namespace:git	typeref:typename:std::tuple<Name,std::variant<TreeId,BlobId,ExecId,LinkId,CommitId>>
ExecId	include/git.hpp	/^using ExecId = nt::NamedType<std::string, struct ExecIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct ExecIdTag>
FLUENT_EBCO	include/nt.hpp	/^#define FLUENT_EBCO /;"	d
FLUENT_EBCO	include/nt.hpp	/^#define FLUENT_EBCO$/;"	d
GIT_H	include/git.hpp	/^#define GIT_H /;"	d
Hashable	include/ntskills.hpp	/^template <typename T> struct Hashable {$/;"	s	namespace:nt
ImplicitlyConvertibleTo	include/ntskills.hpp	/^template <typename Destination> struct ImplicitlyConvertibleTo {$/;"	s	namespace:nt
Incrementable	include/ntskills.hpp	/^template <typename T> struct Incrementable : crtp<T, Incrementable> {$/;"	s	namespace:nt
IsNotReference	include/nt.hpp	/^using IsNotReference =$/;"	t	namespace:nt	typeref:typename:std::enable_if<!std::is_reference<T> void>::type
L	include/lr.hpp	/^struct L {$/;"	s	namespace:lr
LR	include/git.hpp	/^template <typename R> using LR = lr::LR<R>;$/;"	t	namespace:git	typeref:typename:lr::LR<R>
LR	include/lr.hpp	/^template <typename... Rights> using LR = std::variant<L, Rights...>;$/;"	t	namespace:lr	typeref:typename:std::variant<L,Rights...>
LR_H	include/lr.hpp	/^#define LR_H /;"	d
LinkId	include/git.hpp	/^using LinkId = nt::NamedType<std::string, struct LinkIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct LinkIdTag>
Multiplicable	include/ntskills.hpp	/^template <typename T> struct Multiplicable : crtp<T, Multiplicable> {$/;"	s	namespace:nt
Name	include/git.hpp	/^using Name = nt::NamedType<std::string, struct NameTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct NameTag>
NamedType	include/nt.hpp	/^  explicit constexpr NamedType(T &&value) : value_(std::move(value)) {}$/;"	f	class:nt::NamedType
NamedType	include/nt.hpp	/^  explicit constexpr NamedType(T const &value) : value_(value) {}$/;"	f	class:nt::NamedType
NamedType	include/nt.hpp	/^class FLUENT_EBCO NamedType$/;"	c	namespace:nt
Negatable	include/ntskills.hpp	/^template <typename T> struct Negatable : crtp<T, Negatable> {$/;"	s	namespace:nt
NewType	include/newtype.hpp	/^#define NewType(/;"	d
O	include/git.hpp	/^  struct O {$/;"	s	struct:git::TreeBark
O	include/git_.hpp	/^struct O {};$/;"	s	namespace:abo
OVERLOADED_H	include/overloaded.hpp	/^#define OVERLOADED_H /;"	d
PreIncrementable	include/ntskills.hpp	/^template <typename T> struct PreIncrementable : crtp<T, PreIncrementable> {$/;"	s	namespace:nt
Printable	include/ntskills.hpp	/^template <typename T> struct Printable : crtp<T, Printable> {$/;"	s	namespace:nt
Ref	include/git.hpp	/^using Ref = nt::NamedType<int, struct RefTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<int,struct RefTag>
S	test/p.cpp	/^  S() noexcept { puts("S()"); }$/;"	f	struct:S	file:
S	test/p.cpp	/^  S(S &&) noexcept { puts("S(S &&)"); }$/;"	f	struct:S	file:
S	test/p.cpp	/^  S(S const &) noexcept { puts("S(const S &)"); }$/;"	f	struct:S	file:
S	test/p.cpp	/^struct S {$/;"	s	file:
Subtractable	include/ntskills.hpp	/^template <typename T> struct Subtractable : crtp<T, Subtractable> {$/;"	s	namespace:nt
TagId	include/git.hpp	/^using TagId = nt::NamedType<std::string, struct TagIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct TagIdTag>
TreeBark	include/git.hpp	/^  TreeBark(const UPtr<git_repository> &rhs) : repo(rhs) {}$/;"	f	struct:git::TreeBark
TreeBark	include/git.hpp	/^struct TreeBark {$/;"	s	namespace:git
TreeId	include/git.hpp	/^using TreeId = nt::NamedType<std::string, struct TreeIdTag>;$/;"	t	namespace:git	typeref:typename:nt::NamedType<std::string,struct TreeIdTag>
UNDERLYING_FUNCTIONALITIES_HPP	include/ntskills.hpp	/^#define UNDERLYING_FUNCTIONALITIES_HPP$/;"	d
UPtr	include/git.hpp	/^template <typename T> using UPtr = std::unique_ptr<T, void (*)(T *)>;$/;"	t	namespace:git
UPtr	test/oset.cpp	/^template <typename T> using UPtr = std::unique_ptr<T, void (*)(T *)>;$/;"	t	file:
UnderlyingType	include/nt.hpp	/^  using UnderlyingType = T;$/;"	t	class:nt::NamedType	typeref:typename:T
__anon139f36490102	test/git.cpp	/^  auto f = lr::fmap{[](git_oid &&) { return 1; }};$/;"	f	function:git::commit	file:
__anon320e76b20102	include/git.hpp	/^             | lr::fmap([](auto) { return LR<git_oid>(lr::L{"9"}); });$/;"	f	function:git::TreeBark::operator ()	file:
__anon34c545170102	include/union.hpp	/^    return pith([&o, &firstrun](auto &&... x) {$/;"	f	function:abo::union_fn::operator ()	file:
__anon5b3ef2ec0102	include/lr.hpp	/^          overloaded{[](L &&l) { return R(std::forward<L>(l)); },$/;"	f	struct:lr::fmap	file:
__anon5b3ef2ec0202	include/lr.hpp	/^                     [&](auto &&a) { return f(std::forward<decltype(a)>(a)); }},$/;"	f	struct:lr::fmap	file:
__anon5b3ef2ec0302	include/lr.hpp	/^              [](L &&l) { return LR<R>(std::forward<L>(l)); },$/;"	f	struct:lr::fmap	file:
__anon5b3ef2ec0402	include/lr.hpp	/^              [&](auto &&a) { return LR<R>(f(std::forward<decltype(a)>(a))); }},$/;"	f	struct:lr::fmap	file:
__anon93ff310a0102	test/main.cpp	/^            lr::fmap([](const git::UPtr<git_repository> &repo) {$/;"	f	function:main	file:
__anon93ff310a0202	test/main.cpp	/^              return bark([&repo](const TreeBark::O &) {$/;"	f	function:main::__anon93ff310a0102	file:
__anon93ff310a0302	test/main.cpp	/^                       lr::fmap([&](const auto &id) {$/;"	f	function:main::__anon93ff310a0102::__anon93ff310a0202	file:
__anon93ff310a0402	test/main.cpp	/^                       lr::fmap([](const auto &pTree) {$/;"	f	function:main::__anon93ff310a0102::__anon93ff310a0202	file:
__anon93ff310a0502	test/main.cpp	/^            | lr::fmap([](auto &&a) { return a; });$/;"	f	function:main	file:
__anon93ff310a0602	test/main.cpp	/^                 [](lr::L &&l) { std::cout << "L: " << l.message; },$/;"	f	function:main	file:
__anon93ff310a0702	test/main.cpp	/^                 [](git_oid &&l) { std::cout << "R: " << git_oid_tostr_s(&l); },$/;"	f	function:main	file:
__anoncd3310e00102	test/oset.cpp	/^      [c, d, args = std::tuple{std::forward<Args>(args)...}](auto o) {$/;"	f	function:makeuptr	file:
__anoncd3310e00202	test/oset.cpp	/^  return union_fn{[c, args = std::tuple{std::forward<Args>(args)...}](auto o) {$/;"	f	function:run	file:
__anoncd3310e00302	test/oset.cpp	/^  constexpr static auto left = []() {$/;"	f	function:main	file:
__anoncd3310e00402	test/oset.cpp	/^    return [](int, std::string s) { std::cout << s << '\\n'; };$/;"	f	function:main::__anoncd3310e00302	file:
__anoncd3310e00502	test/oset.cpp	/^  oid(overloaded{left(), [](auto x) { std::cout << pf(x) << '\\n'; }});$/;"	f	function:main	file:
__anoncd3310e00602	test/oset.cpp	/^  union_fn{[](auto o) {$/;"	f	function:main	file:
__anoncd3310e00702	test/oset.cpp	/^        left(), [&](UPtr<git_repository> &&repo) {$/;"	f	function:main::__anoncd3310e00602	file:
__anoncd3310e00802	test/oset.cpp	/^      [](float) {},$/;"	f	function:main	file:
__anoncd3310e00902	test/oset.cpp	/^      [](int i, std::string &&m) { std::cout << i << ' ' << m << '\\n'; },$/;"	f	function:main	file:
__anoncd3310e00a02	test/oset.cpp	/^      [](int) {}, [](const char *) {}});$/;"	f	function:main	file:
__anoncd3310e00b02	test/oset.cpp	/^      [](int) {}, [](const char *) {}});$/;"	f	function:main	file:
abo	include/git_.hpp	/^namespace abo {$/;"	n
abo	include/newtype.hpp	/^namespace abo::nt {$/;"	n
abo	include/union.hpp	/^namespace abo {$/;"	n
aiterator	test/p.cpp	/^struct aiterator {$/;"	s	file:
argument	include/nt.hpp	/^  struct argument {$/;"	s	class:nt::NamedType
begin	test/p.cpp	/^  aiterator begin() { return aiterator{}; }$/;"	f	struct:tree_iterator	typeref:typename:aiterator	file:
c	include/git.hpp	/^  C c;$/;"	m	struct:git::make	typeref:typename:C
c	include/git.hpp	/^  C c;$/;"	m	struct:git::make2	typeref:typename:C
commit	test/git.cpp	/^lr::LR<git_oid> commit(const char *, lr::LR<git_oid> &&tree,$/;"	f	namespace:git	typeref:typename:lr::LR<git_oid>
create	include/lr.hpp	/^template <typename T> inline constexpr std::variant<L, T> create(T &&t) {$/;"	f	namespace:lr	typeref:typename:std::variant<L,T>
crtp	include/newtype.hpp	/^template <typename T, template <typename> class crtpType> struct crtp {$/;"	s	namespace:abo::nt
crtp	include/ntskills.hpp	/^template <typename T, template <typename> class crtpType> struct crtp {$/;"	s	namespace:nt
d	include/git.hpp	/^  D d;$/;"	m	struct:git::make	typeref:typename:D
difference_type	test/p.cpp	/^  using difference_type = int;$/;"	t	struct:aiterator	typeref:typename:int	file:
end	test/p.cpp	/^  aiterator end() { return aiterator{}; }$/;"	f	struct:tree_iterator	typeref:typename:aiterator	file:
f	include/lr.hpp	/^  F f;$/;"	m	struct:lr::fmap	typeref:typename:F
fmap	include/lr.hpp	/^  fmap(F &&r) : f(std::forward<F>(r)) {}$/;"	f	struct:lr::fmap
fmap	include/lr.hpp	/^template <typename F> struct fmap {$/;"	s	namespace:lr
get	include/newtype.hpp	/^  constexpr T const &get() const { return value; }$/;"	f	struct:abo::nt::newtype	typeref:typename:T const &
get	include/nt.hpp	/^  constexpr T &get() { return value_; }$/;"	f	class:nt::NamedType	typeref:typename:T &
get	include/nt.hpp	/^  constexpr std::remove_reference_t<T> const &get() const { return value_; }$/;"	f	class:nt::NamedType	typeref:typename:std::remove_reference_t<T> const &
git	include/git.hpp	/^namespace git {$/;"	n
git	test/git.cpp	/^namespace git {$/;"	n	file:
is_hashable	include/ntskills.hpp	/^  static constexpr bool is_hashable = true;$/;"	m	struct:nt::Hashable	typeref:typename:bool
islr	include/lr.hpp	/^template <typename T> struct islr : std::false_type {};$/;"	s	namespace:lr
islr_t	include/lr.hpp	/^template <typename T> using islr_t = typename islr<T>::type;$/;"	t	namespace:lr	typeref:typename:islr<T>::type
islr_v	include/lr.hpp	/^template <typename T> inline constexpr bool islr_v = islr<T>::value;$/;"	v	namespace:lr	typeref:typename:bool
iterator_category	test/p.cpp	/^  using iterator_category = std::input_iterator_tag;$/;"	t	struct:aiterator	typeref:typename:std::input_iterator_tag	file:
lookupTree	test/main.cpp	/^static auto lookupTree = make(git_tree_lookup, git_tree_free);$/;"	v	typeref:typename:auto	file:
lr	include/lr.hpp	/^namespace lr {$/;"	n
main	test/main.cpp	/^int main() {$/;"	f	typeref:typename:int
main	test/oset.cpp	/^int main() {$/;"	f	typeref:typename:int
main	test/p.cpp	/^int main() {$/;"	f	typeref:typename:int
make	include/git.hpp	/^  make(C _c, D _d) : c(_c), d(_d) {}$/;"	f	struct:git::make
make	include/git.hpp	/^template <typename T, typename... Args> struct make {$/;"	s	namespace:git
make2	include/git.hpp	/^  make2(C _c) : c(_c) {}$/;"	f	struct:git::make2
make2	include/git.hpp	/^template <typename T, typename... Args> struct make2 {$/;"	s	namespace:git
make_named	include/nt.hpp	/^constexpr StrongType<T> make_named(T const &value) {$/;"	f	namespace:nt	typeref:typename:StrongType<T>
makeuptr	test/oset.cpp	/^constexpr auto makeuptr(int (*c)(T **, Args...), void (*d)(T *),$/;"	f	typeref:typename:auto
message	include/lr.hpp	/^  std::string message;$/;"	m	struct:lr::L	typeref:typename:std::string
named_type_impl_h	include/nt.hpp	/^#define named_type_impl_h$/;"	d
newtype	include/newtype.hpp	/^  constexpr newtype(U &&u) : value(std::forward<U>(u)) {}$/;"	f	struct:abo::nt::newtype
newtype	include/newtype.hpp	/^struct newtype : Skills<newtype<Tag, T, Skills...>>... {$/;"	s	namespace:abo::nt
nt	include/newtype.hpp	/^namespace abo::nt {$/;"	n	namespace:abo
nt	include/nt.hpp	/^namespace nt {$/;"	n
nt	include/ntskills.hpp	/^namespace nt {$/;"	n
oidFromStr	test/main.cpp	/^static auto oidFromStr = make2(git_oid_fromstr);$/;"	v	typeref:typename:auto	file:
openRepository	test/main.cpp	/^static auto openRepository = make(git_repository_open, git_repository_free);$/;"	v	typeref:typename:auto	file:
operator !=	include/ntskills.hpp	/^  bool operator!=(T const &other) const { return !(*this == other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator ()	include/git.hpp	/^  lr::LR<T> operator()(Args &&... args) const {$/;"	f	struct:git::make2	typeref:typename:lr::LR<T>
operator ()	include/git.hpp	/^  lr::LR<UPtr<T>> operator()(Args &&... args) const {$/;"	f	struct:git::make	typeref:typename:lr::LR<UPtr<T>>
operator ()	include/git.hpp	/^  template <typename Pith> LR<git_oid> operator()(Pith &&pith) const {$/;"	f	struct:git::TreeBark	typeref:typename:LR<git_oid>
operator ()	include/git_.hpp	/^  LR<TreeSha> operator()(const Repo &) const {$/;"	f	struct:abo::Bark	typeref:typename:LR<TreeSha>
operator ()	include/union.hpp	/^  auto operator()(O &&o) const -> decltype(pith(std::declval<O>())) {$/;"	f	struct:abo::union_fn	typeref:typename:decltype (pith (std::declval<O> ()))
operator *	include/ntskills.hpp	/^  T operator*(T const &other) const {$/;"	f	struct:nt::Multiplicable	typeref:typename:T
operator +	include/lr.hpp	/^  L operator+(const L &other) { return L(this->message + other.message); }$/;"	f	struct:lr::L	typeref:typename:L
operator +	include/newtype.hpp	/^  T operator+(T const &other) const {$/;"	f	struct:abo::nt::Addable	typeref:typename:T
operator +	include/ntskills.hpp	/^  T operator+(T const &other) const {$/;"	f	struct:nt::Addable	typeref:typename:T
operator ++	include/ntskills.hpp	/^  T &operator++() {$/;"	f	struct:nt::PreIncrementable	typeref:typename:T &
operator +=	include/ntskills.hpp	/^  T &operator+=(T const &other) {$/;"	f	struct:nt::Incrementable	typeref:typename:T &
operator -	include/ntskills.hpp	/^  T operator-() const { return T(-this->underlying().get()); }$/;"	f	struct:nt::Negatable	typeref:typename:T
operator -	include/ntskills.hpp	/^  T operator-(T const &other) const {$/;"	f	struct:nt::Subtractable	typeref:typename:T
operator ->	include/ntskills.hpp	/^  T *operator->() { return std::addressof(this->underlying().get()); }$/;"	f	typeref:struct:MethodCallable T *
operator <	include/ntskills.hpp	/^  bool operator<(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator <<	include/ntskills.hpp	/^std::ostream &operator<<(std::ostream &os,$/;"	f	namespace:nt	typeref:typename:std::ostream &
operator <=	include/ntskills.hpp	/^  bool operator<=(T const &other) const { return !(*this > other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator =	include/nt.hpp	/^    template <typename U> NamedType operator=(U &&value) const {$/;"	f	struct:nt::NamedType::argument	typeref:typename:NamedType
operator =	test/p.cpp	/^  S &operator=(S &&) noexcept {$/;"	f	struct:S	typeref:typename:S &	file:
operator =	test/p.cpp	/^  S &operator=(const S &) noexcept {$/;"	f	struct:S	typeref:typename:S &	file:
operator ==	include/ntskills.hpp	/^  bool operator==(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator >	include/ntskills.hpp	/^  bool operator>(T const &other) const {$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator >=	include/ntskills.hpp	/^  bool operator>=(T const &other) const { return !(*this < other); }$/;"	f	struct:nt::Comparable	typeref:typename:bool
operator Destination	include/ntskills.hpp	/^    operator Destination() const { return this->underlying().get(); }$/;"	f	struct:nt::ImplicitlyConvertibleTo::templ
operator T&	include/ntskills.hpp	/^  operator T &() { return this->underlying().get(); }$/;"	f	namespace:nt	typeref:struct:FunctionCallable
operator ref	include/nt.hpp	/^  operator ref() { return ref(value_); }$/;"	f	class:nt::NamedType
operator |	include/lr.hpp	/^template <typename A, typename F> decltype(auto) operator|(A &&a, F &&f) {$/;"	f	namespace:lr	typeref:typename:decltype (auto)
overloaded	include/overloaded.hpp	/^template <class... Ts> struct overloaded : Ts... { using Ts::operator()...; };$/;"	s
pf	test/oset.cpp	/^template <typename... Args> std::string pf(Args &&...) {$/;"	f	typeref:typename:std::string
pith	include/git_.hpp	/^  Pith pith;$/;"	m	struct:abo::Bark	typeref:typename:Pith
pith	include/union.hpp	/^  P pith;$/;"	m	struct:abo::union_fn	typeref:typename:P
pointer	test/p.cpp	/^  using pointer = value_type *;$/;"	t	struct:aiterator	typeref:typename:value_type *	file:
print	include/ntskills.hpp	/^  void print(std::ostream &os) const { os << this->underlying().get(); }$/;"	f	struct:nt::Printable	typeref:typename:void
ref	include/nt.hpp	/^  using ref = NamedType<T &, Parameter, Skills...>;$/;"	t	class:nt::NamedType	typeref:typename:NamedType<T &,Parameter,Skills...>
reference	test/p.cpp	/^  using reference = value_type &;$/;"	t	struct:aiterator	typeref:typename:value_type &	file:
repo	include/git.hpp	/^  const UPtr<git_repository> &repo;$/;"	m	struct:git::TreeBark	typeref:typename:const UPtr<git_repository> &
run	test/oset.cpp	/^constexpr auto run(int (*c)(T *, Args...), Args &&... args) {$/;"	f	typeref:typename:auto
templ	include/ntskills.hpp	/^  template <typename T> struct templ : crtp<T, templ> {$/;"	s	struct:nt::ImplicitlyConvertibleTo
tree_iterator	test/p.cpp	/^template <typename T> struct tree_iterator {$/;"	s	file:
underlying	include/newtype.hpp	/^  T &underlying() { return static_cast<T &>(*this); }$/;"	f	struct:abo::nt::crtp	typeref:typename:T &
underlying	include/newtype.hpp	/^  T const &underlying() const { return static_cast<T const &>(*this); }$/;"	f	struct:abo::nt::crtp	typeref:typename:T const &
underlying	include/ntskills.hpp	/^  T &underlying() { return static_cast<T &>(*this); }$/;"	f	struct:nt::crtp	typeref:typename:T &
underlying	include/ntskills.hpp	/^  T const &underlying() const { return static_cast<T const &>(*this); }$/;"	f	struct:nt::crtp	typeref:typename:T const &
union_fn	include/union.hpp	/^template <typename P> struct union_fn {$/;"	s	namespace:abo
value	include/newtype.hpp	/^  T value;$/;"	m	struct:abo::nt::newtype	typeref:typename:T
value	include/nt.hpp	/^    typename std::enable_if<!std::is_reference<T>::value, void>::type;$/;"	t	namespace:nt	typeref:typename:std::enable_if<!std::is_reference<T>::
value_	include/nt.hpp	/^  T value_;$/;"	m	class:nt::NamedType	typeref:typename:T
value_type	test/p.cpp	/^  using value_type = std::tuple<std::string, abo::TreeSha>;$/;"	t	struct:aiterator	typeref:typename:std::tuple<std::string,abo::TreeSha>	file:
~S	test/p.cpp	/^  ~S() noexcept { puts("~S()"); }$/;"	f	struct:S	file:
